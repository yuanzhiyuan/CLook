{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","js/bam.js","js/bedwig.js","js/bigwig.js","js/bin.js","js/browser-ui.js","js/cbrowser.js","js/chainset.js","js/cigar.js","js/color.js","js/das.js","js/domui.js","js/encode.js","js/ensembljson.js","js/export-config.js","js/export-image.js","js/export-ui.js","js/exports.js","js/feature-draw.js","js/feature-popup.js","js/features.js","js/glyphs.js","js/jbjson.js","js/kspace.js","js/lh3utils.js","js/memstore.js","js/numformats.js","js/overlay.js","js/probe.js","js/sample.js","js/search.js","js/sequence-draw.js","js/session.js","js/sha1.js","js/sourceadapters.js","js/sourcecompare.js","js/spans.js","js/style.js","js/svg-export.js","js/svg-utils.js","js/tabix-source.js","js/tabix.js","js/thub.js","js/tier-actions.js","js/tier-edit.js","js/tier.js","js/track-adder.js","js/trix.js","js/twoBit.js","js/utils.js","js/vcf.js","js/version.js","js/zoomslider.js","node_modules/browserify/node_modules/process/browser.js","node_modules/es6-promise/dist/es6-promise.js","node_modules/jszlib/js/inflate.js"],"names":[],"mappings":"AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3hBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7hFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACl1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5rCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnkDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC5VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/uDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACtmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACz4CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/eA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC1IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACv8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"dalliance-all.js","sourceRoot":"/source/","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bam.js: indexed binary alignments\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n}\n\n\nvar BAM_MAGIC = 0x14d4142;\nvar BAI_MAGIC = 0x1494142;\n\nvar BamFlags = {\n    MULTIPLE_SEGMENTS:       0x1,\n    ALL_SEGMENTS_ALIGN:      0x2,\n    SEGMENT_UNMAPPED:        0x4,\n    NEXT_SEGMENT_UNMAPPED:   0x8,\n    REVERSE_COMPLEMENT:      0x10,\n    NEXT_REVERSE_COMPLEMENT: 0x20,\n    FIRST_SEGMENT:           0x40,\n    LAST_SEGMENT:            0x80,\n    SECONDARY_ALIGNMENT:     0x100,\n    QC_FAIL:                 0x200,\n    DUPLICATE:               0x400,\n    SUPPLEMENTARY:           0x800\n};\n\nfunction BamFile() {\n}\n\n\n// Calculate the length (in bytes) of the BAI ref starting at offset.\n// Returns {nbin, length, minBlockIndex}\nfunction _getBaiRefLength(uncba, offset) {\n    var p = offset;\n    var nbin = readInt(uncba, p); p += 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(uncba, p);\n        var nchnk = readInt(uncba, p+4);\n        p += 8 + (nchnk * 16);\n    }\n    var nintv = readInt(uncba, p); p += 4;\n\n    var minBlockIndex = 1000000000;\n    var q = p;\n    for (var i = 0; i < nintv; ++i) {\n        var v = readVob(uncba, q); q += 8;\n        if (v) {\n            var bi = v.block;\n            if (v.offset > 0)\n                bi += 65536;\n\n            if (bi < minBlockIndex)\n                minBlockIndex = bi;\n            break;\n        }\n    }\n    p += (nintv * 8);\n\n    return {\n        minBlockIndex: minBlockIndex,\n        nbin: nbin,\n        length: p - offset\n    };\n}\n\n\nfunction makeBam(data, bai, indexChunks, callback, attempted) {\n    // Do an initial probe on the BAM file to catch any mixed-content errors.\n    data.slice(0, 10).fetch(function(header) {\n        if (header) {\n            return makeBam2(data, bai, indexChunks, callback, attempted);\n        } else {\n            return callback(null, \"Couldn't access BAM.\");\n        }\n    }, {timeout: 5000});\n}\n\nfunction makeBam2(data, bai, indexChunks, callback, attempted) {\n    var bam = new BamFile();\n    bam.data = data;\n    bam.bai = bai;\n    bam.indexChunks = indexChunks;\n\n    var minBlockIndex = bam.indexChunks ? bam.indexChunks.minBlockIndex : 1000000000;\n\n    // Fills out bam.chrToIndex and bam.indexToChr based on the first few bytes of the BAM.\n    function parseBamHeader(r) {\n        if (!r) {\n            return callback(null, \"Couldn't access BAM\");\n        }\n\n        var unc = unbgzf(r, r.byteLength);\n        var uncba = new Uint8Array(unc);\n\n        var magic = readInt(uncba, 0);\n        if (magic != BAM_MAGIC) {\n            return callback(null, \"Not a BAM file, magic=0x\" + magic.toString(16));\n        }\n        var headLen = readInt(uncba, 4);\n        var header = '';\n        for (var i = 0; i < headLen; ++i) {\n            header += String.fromCharCode(uncba[i + 8]);\n        }\n\n        var nRef = readInt(uncba, headLen + 8);\n        var p = headLen + 12;\n\n        bam.chrToIndex = {};\n        bam.indexToChr = [];\n        for (var i = 0; i < nRef; ++i) {\n            var lName = readInt(uncba, p);\n            var name = '';\n            for (var j = 0; j < lName-1; ++j) {\n                name += String.fromCharCode(uncba[p + 4 + j]);\n            }\n            var lRef = readInt(uncba, p + lName + 4);\n            bam.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                bam.chrToIndex[name.substring(3)] = i;\n            } else {\n                bam.chrToIndex['chr' + name] = i;\n            }\n            bam.indexToChr.push(name);\n\n            p = p + 8 + lName;\n        }\n\n        if (bam.indices) {\n            return callback(bam);\n        }\n    }\n\n    function parseBai(header) {\n        if (!header) {\n            return \"Couldn't access BAI\";\n        }\n\n        var uncba = new Uint8Array(header);\n        var baiMagic = readInt(uncba, 0);\n        if (baiMagic != BAI_MAGIC) {\n            return callback(null, 'Not a BAI file, magic=0x' + baiMagic.toString(16));\n        }\n\n        var nref = readInt(uncba, 4);\n\n        bam.indices = [];\n\n        var p = 8;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var o = _getBaiRefLength(uncba, blockStart);\n            p += o.length;\n\n            minBlockIndex = Math.min(o.minBlockIndex, minBlockIndex);\n\n            var nbin = o.nbin;\n\n            if (nbin > 0) {\n                bam.indices[ref] = new Uint8Array(header, blockStart, p - blockStart);\n            }\n        }\n\n        return true;\n    }\n\n    if (!bam.indexChunks) {\n        bam.bai.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(\n            var result = parseBai(header);\n            if (result !== true) {\n                if (bam.bai.url && typeof(attempted) === \"undefined\") {\n                    // Already attempted x.bam.bai not there so now trying x.bai\n                    bam.bai.url = bam.data.url.replace(new RegExp('.bam$'), '.bai');\n                    \n                     // True lets us know we are making a second attempt\n                    makeBam2(data, bam.bai, indexChunks, callback, true);\n                }\n                else {\n                    // We've attempted x.bam.bai & x.bai and nothing worked\n                    callback(null, result);\n                }\n            } else {\n              bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n            }\n        });   // Timeout on first request to catch Chrome mixed-content error.\n    } else {\n        var chunks = bam.indexChunks.chunks;\n        bam.indices = []\n        for (var i = 0; i < chunks.length; i++) {\n           bam.indices[i] = null;  // To be filled out lazily as needed\n        }\n        bam.data.slice(0, minBlockIndex).fetch(parseBamHeader);\n    }\n}\n\n\n\nBamFile.prototype.blocksForRange = function(refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [], otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p+4);\n//        dlog('bin=' + bin + '; nchnk=' + nchnk);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p);\n                var ce = readVob(index, p + 8);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p +=  (nchnk * 16);\n        }\n    }\n    // console.log('leafChunks = ' + miniJSONify(leafChunks));\n    // console.log('otherChunks = ' + miniJSONify(otherChunks));\n\n    var nintv = readInt(index, p);\n    var lowest = null;\n    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb =  readVob(index, p + 4 + (i * 8));\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {\n            lowest = lb;\n        }\n    }\n    // console.log('Lowest LB = ' + lowest);\n    \n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    }\n    // console.log('prunedOtherChunks = ' + miniJSONify(prunedOtherChunks));\n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function(c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block\n                cur = new Chunk(cur.minv, nc.maxv);\n            } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n    // console.log('mergedChunks = ' + miniJSONify(mergedChunks));\n\n    return mergedChunks;\n}\n\nBamFile.prototype.fetch = function(chr, min, max, callback, opts) {\n    var thisB = this;\n    opts = opts || {};\n\n    var chrId = this.chrToIndex[chr];\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        // Fetch this portion of the BAI if it hasn't been loaded yet.\n        if (this.indices[chrId] === null && this.indexChunks.chunks[chrId]) {\n            var start_stop = this.indexChunks.chunks[chrId];\n            return this.bai.slice(start_stop[0], start_stop[1]).fetch(function(data) {\n                var buffer = new Uint8Array(data);\n                this.indices[chrId] = buffer;\n                return this.fetch(chr, min, max, callback, opts);\n            }.bind(this));\n        }\n\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n    \n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1<<16); // *sigh*\n            // console.log('fetching ' + fetchMin + ':' + fetchMax);\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            var finished = thisB.readBamRecords(ba, chunks[index].minv.offset, records, min, max, chrId, opts);\n            data = null;\n            ++index;\n            if (finished)\n                return callback(records);\n            else\n                return tramp();\n        }\n    }\n    tramp();\n}\n\nvar SEQRET_DECODER = ['=', 'A', 'C', 'x', 'G', 'x', 'x', 'x', 'T', 'x', 'x', 'x', 'x', 'x', 'x', 'N'];\nvar CIGAR_DECODER = ['M', 'I', 'D', 'N', 'S', 'H', 'P', '=', 'X', '?', '?', '?', '?', '?', '?', '?'];\n\nfunction BamRecord() {\n}\n\nBamFile.prototype.readBamRecords = function(ba, offset, sink, min, max, chrId, opts) {\n    while (true) {\n        var blockSize = readInt(ba, offset);\n        var blockEnd = offset + blockSize + 4;\n        if (blockEnd >= ba.length) {\n            return false;\n        }\n\n        var record = new BamRecord();\n\n        var refID = readInt(ba, offset + 4);\n        var pos = readInt(ba, offset + 8);\n        \n        var bmn = readInt(ba, offset + 12);\n        var bin = (bmn & 0xffff0000) >> 16;\n        var mq = (bmn & 0xff00) >> 8;\n        var nl = bmn & 0xff;\n\n        var flag_nc = readInt(ba, offset + 16);\n        var flag = (flag_nc & 0xffff0000) >> 16;\n        var nc = flag_nc & 0xffff;\n    \n        var lseq = readInt(ba, offset + 20);\n        \n        var nextRef  = readInt(ba, offset + 24);\n        var nextPos = readInt(ba, offset + 28);\n        \n        var tlen = readInt(ba, offset + 32);\n    \n        record.segment = this.indexToChr[refID];\n        record.flag = flag;\n        record.pos = pos;\n        record.mq = mq;\n        if (opts.light)\n            record.seqLength = lseq;\n\n        if (!opts.light) {\n            if (nextRef >= 0) {\n                record.nextSegment = this.indexToChr[nextRef];\n                record.nextPos = nextPos;\n            }\n\n            var readName = '';\n            for (var j = 0; j < nl-1; ++j) {\n                readName += String.fromCharCode(ba[offset + 36 + j]);\n            }\n            record.readName = readName;\n        \n            var p = offset + 36 + nl;\n\n            var cigar = '';\n            for (var c = 0; c < nc; ++c) {\n                var cigop = readInt(ba, p);\n                cigar = cigar + (cigop>>4) + CIGAR_DECODER[cigop & 0xf];\n                p += 4;\n            }\n            record.cigar = cigar;\n        \n            var seq = '';\n            var seqBytes = (lseq + 1) >> 1;\n            for (var j = 0; j < seqBytes; ++j) {\n                var sb = ba[p + j];\n                seq += SEQRET_DECODER[(sb & 0xf0) >> 4];\n                if (seq.length < lseq)\n                    seq += SEQRET_DECODER[(sb & 0x0f)];\n            }\n            p += seqBytes;\n            record.seq = seq;\n\n            var qseq = '';\n            for (var j = 0; j < lseq; ++j) {\n                qseq += String.fromCharCode(ba[p + j] + 33);\n            }\n            p += lseq;\n            record.quals = qseq;\n\n            while (p < blockEnd) {\n                var tag = String.fromCharCode(ba[p], ba[p + 1]);\n                var type = String.fromCharCode(ba[p + 2]);\n                var value;\n\n                if (type == 'A') {\n                    value = String.fromCharCode(ba[p + 3]);\n                    p += 4;\n                } else if (type == 'i' || type == 'I') {\n                    value = readInt(ba, p + 3);\n                    p += 7;\n                } else if (type == 'c' || type == 'C') {\n                    value = ba[p + 3];\n                    p += 4;\n                } else if (type == 's' || type == 'S') {\n                    value = readShort(ba, p + 3);\n                    p += 5;\n                } else if (type == 'f') {\n                    value = readFloat(ba, p + 3);\n                    p += 7;\n                } else if (type == 'Z' || type == 'H') {\n                    p += 3;\n                    value = '';\n                    for (;;) {\n                        var cc = ba[p++];\n                        if (cc == 0) {\n                            break;\n                        } else {\n                            value += String.fromCharCode(cc);\n                        }\n                    }\n                } else if (type == 'B') {\n                    var atype = String.fromCharCode(ba[p + 3]);\n                    var alen = readInt(ba, p + 4);\n                    var elen;\n                    var reader;\n                    if (atype == 'i' || atype == 'I' || atype == 'f') {\n                        elen = 4;\n                        if (atype == 'f')\n                            reader = readFloat;\n                        else\n                            reader = readInt;\n                    } else if (atype == 's' || atype == 'S') {\n                        elen = 2;\n                        reader = readShort;\n                    } else if (atype == 'c' || atype == 'C') {\n                        elen = 1;\n                        reader = readByte;\n                    } else {\n                        throw 'Unknown array type ' + atype;\n                    }\n\n                    p += 8;\n                    value = [];\n                    for (var i = 0; i < alen; ++i) {\n                        value.push(reader(ba, p));\n                        p += elen;\n                    }\n                } else {\n                    throw 'Unknown type '+ type;\n                }\n                record[tag] = value;\n            }\n        }\n\n        if (!min || record.pos <= max && record.pos + lseq >= min) {\n            if (chrId === undefined || refID == chrId) {\n                sink.push(record);\n            }\n        }\n        if (record.pos > max) {\n            return true;\n        }\n        offset = blockEnd;\n    }\n\n    // Exits via top of loop.\n};\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeBam: makeBam,\n        BAM_MAGIC: BAM_MAGIC,\n        BAI_MAGIC: BAI_MAGIC,\n        BamFlags: BamFlags\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// bedwig.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var sa = require('./sourceadapters');\n    var dalliance_registerParserFactory = sa.registerParserFactory;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n}\n\n\nfunction BedWigParser(type) {\n    this.type = type;\n}\n\nBedWigParser.prototype.createSession = function(sink) {\n    if (this.type == 'wig')\n        return new WigParseSession(this, sink);\n    else\n        return new BedParseSession(this, sink);\n}\n\nvar __KV_REGEXP=/([^=]+)=(.+)/;\nvar __SPACE_REGEXP=/\\s/;\nvar BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\nfunction BedParseSession(parser, sink) {\n    this.parser = parser;\n    this.sink = sink;\n}\n\nBedParseSession.prototype.parse = function(line) {\n    var toks = line.split(__SPACE_REGEXP);\n    if (toks.length < 3)\n        return;\n\n    var start = parseInt(toks[1]) + 1;\n    var end = parseInt(toks[2]);\n\n    var f = {segment: toks[0], \n             min: start,\n             max: end};\n\n    if (toks.length > 3 && toks[3] !== '.') {\n        f.label = toks[3];\n    }\n\n    if (toks.length > 4) {\n        f.score = parseFloat(toks[4])\n    }\n\n    if (toks.length > 5) {\n        f.orientation = toks[5];\n    }\n\n    if (toks.length > 8) {\n        var color = toks[8];\n        if (BED_COLOR_REGEXP.test(color)) {\n            f.itemRgb = 'rgb(' + color + ')';\n        }\n    }\n\n    if (toks.length >= 12) {\n        var thickStart = parseInt(toks[6]);\n        var thickEnd   = parseInt(toks[7]);\n        var blockCount = parseInt(toks[9]);\n        var blockSizes = toks[10].split(',').map(function(x) {return parseInt(x)});\n        var blockStarts = toks[11].split(',').map(function(x) {return parseInt(x)});\n\n        f.type = 'transcript'\n        var grp = new DASGroup();\n        grp.id = toks[3];\n        grp.type = 'transcript'\n        grp.notes = [];\n        f.groups = [grp];\n\n        if (toks.length > 12) {\n            var geneId = toks[12];\n            var geneName = geneId;\n            if (toks.length > 13) {\n                geneName = toks[13];\n            }\n            var gg = new DASGroup();\n            gg.id = geneId;\n            gg.label = geneName;\n            gg.type = 'gene';\n            f.groups.push(gg);\n        }  \n\n        var spans = null;\n        for (var b = 0; b < blockCount; ++b) {\n            var bmin = blockStarts[b] + start;\n            var bmax = bmin + blockSizes[b];\n            var span = new Range(bmin, bmax);\n            if (spans) {\n                spans = union(spans, span);\n            } else {\n                spans = span;\n            }\n        }\n                    \n        var tsList = spans.ranges();\n        for (var s = 0; s < tsList.length; ++s) {\n            var ts = tsList[s];\n            var bf = shallowCopy(f);\n            bf.min = ts.min();\n            bf.max = ts.max();\n            this.sink(bf);\n        }\n\n        if (thickEnd > thickStart) {\n            var codingRegion = (f.orientation == '+') ? \n                new Range(thickStart, thickEnd + 3) : \n                new Range(thickStart - 3, thickEnd);\n                // +/- 3 to account for stop codon\n\n            var tl = intersection(spans, codingRegion);\n            if (tl) {\n                f.type = 'translation';\n                var tlList = tl.ranges();\n                var readingFrame = 0;\n                for (var s = 0; s < tlList.length; ++s) {\n                    // Record reading frame for every exon\n                    var index = s;\n                    if (f.orientation == '-')\n                        index = tlList.length - s - 1;\n                    var ts = tlList[index];\n                    var bf = shallowCopy(f);\n                    bf.min = ts.min();\n                    bf.max = ts.max();\n                    f.readframe = readingFrame;\n                    var length = ts.max() - ts.min();\n                    readingFrame = (readingFrame + length) % 3;\n                    this.sink(bf);\n                }\n            }\n        }\n    } else {\n        this.sink(f);\n    }\n}\n\nBedParseSession.prototype.flush = function() {};\n\nfunction WigParseSession(parser, sink) {\n    this.parser = parser;\n    this.sink = sink;\n    this.wigState = null;\n}\n\nWigParseSession.prototype.parse = function(line) {\n    var toks = line.split(__SPACE_REGEXP);\n\n    if (toks[0] == 'fixedStep') {\n        this.wigState = 'fixedStep';\n        this.chr = this.pos = this.step = null;\n        this.span = 1;\n\n        for (var ti = 1; ti < toks.length; ++ti) {\n            var m = __KV_REGEXP.exec(toks[ti]);\n            if (m) {\n                if (m[1] == 'chrom') {\n                    this.chr = m[2];\n                } else if (m[1] == 'start') {\n                    this.pos = parseInt(m[2]);\n                } else if (m[1] == 'step') {\n                    this.step = parseInt(m[2]);\n                } else if (m[1] == 'span') {\n                    this.span = parseInt(m[2]);\n                }\n            }\n        }\n    } else if (toks[0] == 'variableStep') {\n        this.wigState = 'variableStep';\n        this.chr = null;\n        this.span = 1;\n\n        for (var ti = 1; ti < toks.length; ++ti) {\n            var m = __KV_REGEXP.exec(toks[ti]);\n            if (m[1] == 'chrom') {\n                this.chr = m[2];\n            } else if (m[1] == 'span') {\n                this.span = parseInt(m[2]);\n            }\n        }\n    } else {\n        if (!this.wigState) {\n            if (toks.length < 4)\n                return;\n\n            var f = {segment: toks[0], \n                     min: parseInt(toks[1]) + 1, \n                     max: parseInt(toks[2]),\n                     score: parseFloat(toks[3])};\n\n            this.sink(f);\n        } else if (this.wigState == 'fixedStep') {\n            if (toks.length != 1)\n                return;\n            var score = parseFloat(toks[0]);\n            var f = {segment: this.chr, min: this.pos, max: this.pos + this.span - 1, score: score};\n            this.pos += this.step;\n            this.sink(f);\n        } else if (this.wigState == 'variableStep') {\n            if (toks.length != 2)\n                return;\n            var pos = parseInt(toks[0]);\n            var score = parseFloat(toks[1]);\n            var f = {segment: this.chr, min: pos, max: pos + this.span - 1, score: score};\n            this.sink(f);\n        }\n    }\n}\n\nWigParseSession.prototype.flush = function() {};\n\nBedWigParser.prototype.getStyleSheet = function(callback) {\n    var thisB = this;\n    var stylesheet = new DASStylesheet();\n\n    if (this.type == 'wig') {\n        var wigStyle = new DASStyle();\n        wigStyle.glyph = 'HISTOGRAM';\n        wigStyle.BGCOLOR = 'blue';\n        wigStyle.HEIGHT=30;\n        stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n    } else {\n        var wigStyle = new DASStyle();\n        wigStyle.glyph = 'BOX';\n        wigStyle.FGCOLOR = 'black';\n        wigStyle.BGCOLOR = 'blue'\n        wigStyle.HEIGHT = 8;\n        wigStyle.BUMP = true;\n        wigStyle.LABEL = true;\n        wigStyle.ZINDEX = 20;\n        stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n\n        var wigStyle = new DASStyle();\n        wigStyle.glyph = 'BOX';\n        wigStyle.FGCOLOR = 'black';\n        wigStyle.BGCOLOR = 'red'\n        wigStyle.HEIGHT = 10;\n        wigStyle.BUMP = true;\n        wigStyle.ZINDEX = 20;\n        stylesheet.pushStyle({type: 'translation'}, null, wigStyle);\n                \n        var tsStyle = new DASStyle();\n        tsStyle.glyph = 'BOX';\n        tsStyle.FGCOLOR = 'black';\n        tsStyle.BGCOLOR = 'white';\n        tsStyle.HEIGHT = 10;\n        tsStyle.ZINDEX = 10;\n        tsStyle.BUMP = true;\n        tsStyle.LABEL = true;\n        stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n\n        var densStyle = new DASStyle();\n        densStyle.glyph = 'HISTOGRAM';\n        densStyle.COLOR1 = 'white';\n        densStyle.COLOR2 = 'black';\n        densStyle.HEIGHT=30;\n        stylesheet.pushStyle({type: 'density'}, null, densStyle);\n    }\n\n    return callback(stylesheet);\n}\n\ndalliance_registerParserFactory('bed', function(t) {return new BedWigParser(t)});\ndalliance_registerParserFactory('wig', function(t) {return new BedWigParser(t)});","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// bigwig.js: indexed binary WIG (and BED) files\n//\n\n\"use strict\";\n\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var das = require('./das');\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nvar BIG_WIG_MAGIC = 0x888FFC26;\nvar BIG_WIG_MAGIC_BE = 0x26FC8F88;\nvar BIG_BED_MAGIC = 0x8789F2EB;\nvar BIG_BED_MAGIC_BE = 0xEBF28987;\n\n\nvar BIG_WIG_TYPE_GRAPH = 1;\nvar BIG_WIG_TYPE_VSTEP = 2;\nvar BIG_WIG_TYPE_FSTEP = 3;\n  \nvar M1 = 256;\nvar M2 = 256*256;\nvar M3 = 256*256*256;\nvar M4 = 256*256*256*256;\n\nvar BED_COLOR_REGEXP = new RegExp(\"^[0-9]+,[0-9]+,[0-9]+\");\n\nfunction bwg_readOffset(ba, o) {\n    var offset = ba[o] + ba[o+1]*M1 + ba[o+2]*M2 + ba[o+3]*M3 + ba[o+4]*M4;\n    return offset;\n}\n\nfunction BigWig() {\n}\n\nBigWig.prototype.readChromTree = function(callback) {\n    var thisB = this;\n    this.chromsToIDs = {};\n    this.idsToChroms = {};\n    this.maxID = 0;\n\n    var udo = this.unzoomedDataOffset;\n    var eb = (udo - this.chromTreeOffset) & 3;\n    udo = udo + 4 - eb;\n\n    this.data.slice(this.chromTreeOffset, udo - this.chromTreeOffset).fetch(function(bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        var bptReadNode = function(offset) {\n            var nodeType = ba[offset];\n            var cnt = sa[(offset/2) + 1];\n            offset += 4;\n            for (var n = 0; n < cnt; ++n) {\n                if (nodeType == 0) {\n                    offset += keySize;\n                    var childOffset = bwg_readOffset(ba, offset);\n                    offset += 8;\n                    childOffset -= thisB.chromTreeOffset;\n                    bptReadNode(childOffset);\n                } else {\n                    var key = '';\n                    for (var ki = 0; ki < keySize; ++ki) {\n                        var charCode = ba[offset++];\n                        if (charCode != 0) {\n                            key += String.fromCharCode(charCode);\n                        }\n                    }\n                    var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n                    var chromSize = (ba[offset + 7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n                    offset += 8;\n\n                    thisB.chromsToIDs[key] = chromId;\n                    if (key.indexOf('chr') == 0) {\n                        thisB.chromsToIDs[key.substr(3)] = chromId;\n                    }\n                    thisB.idsToChroms[chromId] = key;\n                    thisB.maxID = Math.max(thisB.maxID, chromId);\n                }\n            }\n        };\n        bptReadNode(rootNodeOffset);\n\n        callback(thisB);\n    });\n}\n\nfunction BigWigView(bwg, cirTreeOffset, cirTreeLength, isSummary) {\n    this.bwg = bwg;\n    this.cirTreeOffset = cirTreeOffset;\n    this.cirTreeLength = cirTreeLength;\n    this.isSummary = isSummary;\n}\n\n\n\nBigWigView.prototype.readWigData = function(chrName, min, max, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.readWigDataById(chr, min, max, callback);\n    }\n}\n\nBigWigView.prototype.readWigDataById = function(chr, min, max, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.readWigDataById(chr, min, max, callback);\n        });\n        return;\n    }\n\n    var blocksToFetch = [];\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var filter = function(chromId, fmin, fmax, toks) {\n        return ((chr < 0 || chromId == chr) && fmin <= max && fmax >= min);\n    }\n\n    var cirFobRecur = function(offset, level) {\n        if (thisB.bwg.instrument)\n            console.log('level=' + level + '; offset=' + offset + '; time=' + (Date.now()|0));\n\n        outstanding += offset.length;\n\n        if (offset.length == 1 && offset[0] - thisB.cirTreeOffset == 48 && thisB.cachedCirRoot) {\n            cirFobRecur2(thisB.cachedCirRoot, 0, level);\n            --outstanding;\n            if (outstanding == 0) {\n                thisB.fetchFeatures(filter, blocksToFetch, callback);\n            }\n            return;\n        }\n\n        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n        \n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    }\n\n    var cirFobStartFetch = function(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n\n                    if (offset[i] - thisB.cirTreeOffset == 48 && offset[i] - fr.min() == 0)\n                        thisB.cachedCirRoot = resultBuffer;\n\n                    --outstanding;\n                    if (outstanding == 0) {\n                        thisB.fetchFeatures(filter, blocksToFetch, callback);\n                    }\n                }\n            }\n        });\n    }\n\n    var cirFobRecur2 = function(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset/2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                var blockSize = bwg_readOffset(ba, offset+24);\n                if (((chr < 0 || startChrom < chr) || (startChrom == chr && startBase <= max)) &&\n                    ((chr < 0 || endChrom   > chr) || (endChrom == chr && endBase >= min)))\n                {\n                    blocksToFetch.push({offset: blockOffset, size: blockSize});\n                }\n                offset += 32;\n            }\n        } else {\n            var recurOffsets = [];\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                if ((chr < 0 || startChrom < chr || (startChrom == chr && startBase <= max)) &&\n                    (chr < 0 || endChrom   > chr || (endChrom == chr && endBase >= min)))\n                {\n                    recurOffsets.push(blockOffset);\n                }\n                offset += 24;\n            }\n            if (recurOffsets.length > 0) {\n                cirFobRecur(recurOffsets, level + 1);\n            }\n        }\n    };\n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n}\n\n\nBigWigView.prototype.fetchFeatures = function(filter, blocksToFetch, callback) {\n    var thisB = this;\n\n    blocksToFetch.sort(function(b0, b1) {\n        return (b0.offset|0) - (b1.offset|0);\n    });\n\n    if (blocksToFetch.length == 0) {\n        callback([]);\n    } else {\n        var features = [];\n        var createFeature = function(chr, fmin, fmax, opts) {\n            if (!opts) {\n                opts = {};\n            }\n        \n            var f = new DASFeature();\n            f._chromId = chr;\n            f.segment = thisB.bwg.idsToChroms[chr];\n            f.min = fmin;\n            f.max = fmax;\n            f.type = thisB.bwg.type;\n            \n            for (var k in opts) {\n                f[k] = opts[k];\n            }\n            \n            features.push(f);\n        };\n\n        var tramp = function() {\n            if (blocksToFetch.length == 0) {\n                var afterBWG = Date.now();\n                // dlog('BWG fetch took ' + (afterBWG - beforeBWG) + 'ms');\n                callback(features);\n                return;  // just in case...\n            } else {\n                var block = blocksToFetch[0];\n                if (block.data) {\n                    thisB.parseFeatures(block.data, createFeature, filter);\n                    blocksToFetch.splice(0, 1);\n                    tramp();\n                } else {\n                    var fetchStart = block.offset;\n                    var fetchSize = block.size;\n                    var bi = 1;\n                    while (bi < blocksToFetch.length && blocksToFetch[bi].offset == (fetchStart + fetchSize)) {\n                        fetchSize += blocksToFetch[bi].size;\n                        ++bi;\n                    }\n\n                    thisB.bwg.data.slice(fetchStart, fetchSize).fetch(function(result) {\n                        var offset = 0;\n                        var bi = 0;\n                        while (offset < fetchSize) {\n                            var fb = blocksToFetch[bi];\n                        \n                            var data;\n                            if (thisB.bwg.uncompressBufSize > 0) {\n                                data = jszlib_inflate_buffer(result, offset + 2, fb.size - 2);\n                            } else {\n                                var tmp = new Uint8Array(fb.size);    // FIXME is this really the best we can do?\n                                arrayCopy(new Uint8Array(result, offset, fb.size), 0, tmp, 0, fb.size);\n                                data = tmp.buffer;\n                            }\n                            fb.data = data;\n                            \n                            offset += fb.size;\n                            ++bi;\n                        }\n                        tramp();\n                    });\n                }\n            }\n        }\n        tramp();\n    }\n}\n\nBigWigView.prototype.parseFeatures = function(data, createFeature, filter) {\n    var ba = new Uint8Array(data);\n\n    if (this.isSummary) {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var itemCount = data.byteLength/32;\n        for (var i = 0; i < itemCount; ++i) {\n            var chromId =   la[(i*8)];\n            var start =     la[(i*8)+1];\n            var end =       la[(i*8)+2];\n            var validCnt =  la[(i*8)+3];\n            var minVal    = fa[(i*8)+4];\n            var maxVal    = fa[(i*8)+5];\n            var sumData   = fa[(i*8)+6];\n            var sumSqData = fa[(i*8)+7];\n            \n            if (filter(chromId, start + 1, end)) {\n                var summaryOpts = {type: 'bigwig', score: sumData/validCnt, maxScore: maxVal};\n                if (this.bwg.type == 'bigbed') {\n                    summaryOpts.type = 'density';\n                }\n                createFeature(chromId, start + 1, end, summaryOpts);\n            }\n        }\n    } else if (this.bwg.type == 'bigwig') {\n        var sa = new Int16Array(data);\n        var la = new Int32Array(data);\n        var fa = new Float32Array(data);\n\n        var chromId = la[0];\n        var blockStart = la[1];\n        var blockEnd = la[2];\n        var itemStep = la[3];\n        var itemSpan = la[4];\n        var blockType = ba[20];\n        var itemCount = sa[11];\n        \n        if (blockType == BIG_WIG_TYPE_FSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var score = fa[i + 6];\n                var fmin = blockStart + (i*itemStep) + 1, fmax = blockStart + (i*itemStep) + itemSpan;\n                if (filter(chromId, fmin, fmax))\n                    createFeature(chromId, fmin, fmax, {score: score});\n            }\n        } else if (blockType == BIG_WIG_TYPE_VSTEP) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[(i*2) + 6] + 1;\n                var end = start + itemSpan - 1;\n                var score = fa[(i*2) + 7];\n                if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n            }\n        } else if (blockType == BIG_WIG_TYPE_GRAPH) {\n            for (var i = 0; i < itemCount; ++i) {\n                var start = la[(i*3) + 6] + 1;\n                var end   = la[(i*3) + 7];\n                var score = fa[(i*3) + 8];\n                if (start > end) {\n                    start = end;\n                }\n                if (filter(chromId, start, end))\n                    createFeature(chromId, start, end, {score: score});\n            }\n        } else {\n            console.log('Currently not handling bwgType=' + blockType);\n        }\n    } else if (this.bwg.type == 'bigbed') {\n        var offset = 0;\n        var dfc = this.bwg.definedFieldCount;\n        var schema = this.bwg.schema;\n\n        while (offset < ba.length) {\n            var chromId = (ba[offset+3]<<24) | (ba[offset+2]<<16) | (ba[offset+1]<<8) | (ba[offset+0]);\n            var start = (ba[offset+7]<<24) | (ba[offset+6]<<16) | (ba[offset+5]<<8) | (ba[offset+4]);\n            var end = (ba[offset+11]<<24) | (ba[offset+10]<<16) | (ba[offset+9]<<8) | (ba[offset+8]);\n            offset += 12;\n            var rest = '';\n            while (true) {\n                var ch = ba[offset++];\n                if (ch != 0) {\n                    rest += String.fromCharCode(ch);\n                } else {\n                    break;\n                }\n            }\n\n            var featureOpts = {};\n            \n            var bedColumns;\n            if (rest.length > 0) {\n                bedColumns = rest.split('\\t');\n            } else {\n                bedColumns = [];\n            }\n            if (bedColumns.length > 0 && dfc > 3) {\n                featureOpts.label = bedColumns[0];\n            }\n            if (bedColumns.length > 1 && dfc > 4) {\n                var score = parseInt(bedColumns[1]);\n                if (!isNaN(score))\n                    featureOpts.score = score;\n            }\n            if (bedColumns.length > 2 && dfc > 5) {\n                featureOpts.orientation = bedColumns[2];\n            }\n            if (bedColumns.length > 5 && dfc > 8) {\n                var color = bedColumns[5];\n                if (BED_COLOR_REGEXP.test(color)) {\n                    featureOpts.itemRgb = 'rgb(' + color + ')';\n                }\n            }\n\n            if (bedColumns.length > dfc-3 && schema) {\n                for (var col = dfc - 3; col < bedColumns.length; ++col) {\n                    featureOpts[schema.fields[col+3].name] = bedColumns[col];\n                }\n            }\n\n            if (filter(chromId, start + 1, end, bedColumns)) {\n                if (dfc < 12) {\n                    createFeature(chromId, start + 1, end, featureOpts);\n                } else {\n                    var thickStart = bedColumns[3]|0;\n                    var thickEnd   = bedColumns[4]|0;\n                    var blockCount = bedColumns[6]|0;\n                    var blockSizes = bedColumns[7].split(',');\n                    var blockStarts = bedColumns[8].split(',');\n\n                    if (featureOpts.exonFrames) {\n                        var exonFrames = featureOpts.exonFrames.split(',');\n                        featureOpts.exonFrames = undefined;\n                    }\n                    \n                    featureOpts.type = 'transcript'\n                    var grp = new DASGroup();\n                    for (var k in featureOpts) {\n                        grp[k] = featureOpts[k];\n                    }\n                    grp.id = bedColumns[0];\n                    grp.segment = this.bwg.idsToChroms[chromId];\n                    grp.min = start + 1;\n                    grp.max = end;\n                    grp.notes = [];\n                    featureOpts.groups = [grp];\n\n                    // Moving towards using bigGenePred model, but will\n                    // still support old Dalliance-style BED12+gene-name for the\n                    // foreseeable future.\n                    if (bedColumns.length > 9) {\n                        var geneId = featureOpts.geneName || bedColumns[9];\n                        var geneName = geneId;\n                        if (bedColumns.length > 10) {\n                            geneName = bedColumns[10];\n                        }\n                        if (featureOpts.geneName2)\n                            geneName = featureOpts.geneName2;\n\n                        var gg = shallowCopy(grp);\n                        gg.id = geneId;\n                        gg.label = geneName;\n                        gg.type = 'gene';\n                        featureOpts.groups.push(gg);\n                    }\n\n                    var spanList = [];\n                    for (var b = 0; b < blockCount; ++b) {\n                        var bmin = (blockStarts[b]|0) + start;\n                        var bmax = bmin + (blockSizes[b]|0);\n                        var span = new Range(bmin, bmax);\n                        spanList.push(span);\n                    }\n                    var spans = union(spanList);\n                    \n                    var tsList = spans.ranges();\n                    for (var s = 0; s < tsList.length; ++s) {\n                        var ts = tsList[s];\n                        createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                    }\n\n                    if (thickEnd > thickStart) {\n                        var codingRegion = (featureOpts.orientation == '+') ?\n                            new Range(thickStart, thickEnd + 3) :\n                            new Range(thickStart - 3, thickEnd);\n                            // +/- 3 to account for stop codon\n\n                        var tl = intersection(spans, codingRegion);\n                        if (tl) {\n                            featureOpts.type = 'translation';\n                            var tlList = tl.ranges();\n                            var readingFrame = 0;\n\n                            var tlOffset = 0;\n                            while (tlList[0].min() > tsList[tlOffset].max())\n                                tlOffset++;\n\n                            for (var s = 0; s < tlList.length; ++s) {\n                                // Record reading frame for every exon\n                                var index = s;\n                                if (featureOpts.orientation == '-')\n                                    index = tlList.length - s - 1;\n                                var ts = tlList[index];\n                                featureOpts.readframe = readingFrame;\n                                if (exonFrames) {\n                                    var brf = parseInt(exonFrames[index + tlOffset]);\n                                    if (typeof(brf) === 'number' && brf >= 0 && brf <= 2) {\n                                        featureOpts.readframe = brf;\n                                        featureOpts.readframeExplicit = true;\n                                    }\n                                }\n                                var length = ts.max() - ts.min();\n                                readingFrame = (readingFrame + length) % 3;\n                                createFeature(chromId, ts.min() + 1, ts.max(), featureOpts);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    } else {\n        throw Error(\"Don't know what to do with \" + this.bwg.type);\n    }\n}\n\n//\n// nasty cut/paste, should roll back in!\n//\n\nBigWigView.prototype.getFirstAdjacent = function(chrName, pos, dir, callback) {\n    var chr = this.bwg.chromsToIDs[chrName];\n    if (chr === undefined) {\n        // Not an error because some .bwgs won't have data for all chromosomes.\n        return callback([]);\n    } else {\n        this.getFirstAdjacentById(chr, pos, dir, callback);\n    }\n}\n\nBigWigView.prototype.getFirstAdjacentById = function(chr, pos, dir, callback) {\n    var thisB = this;\n    if (!this.cirHeader) {\n        this.bwg.data.slice(this.cirTreeOffset, 48).fetch(function(result) {\n            thisB.cirHeader = result;\n            var la = new Int32Array(thisB.cirHeader);\n            thisB.cirBlockSize = la[1];\n            thisB.getFirstAdjacentById(chr, pos, dir, callback);\n        });\n        return;\n    }\n\n    var blockToFetch = null;\n    var bestBlockChr = -1;\n    var bestBlockOffset = -1;\n\n    var outstanding = 0;\n\n    var beforeBWG = Date.now();\n\n    var cirFobRecur = function(offset, level) {\n        outstanding += offset.length;\n\n        var maxCirBlockSpan = 4 +  (thisB.cirBlockSize * 32);   // Upper bound on size, based on a completely full leaf node.\n        var spans;\n        for (var i = 0; i < offset.length; ++i) {\n            var blockSpan = new Range(offset[i], offset[i] + maxCirBlockSpan);\n            spans = spans ? union(spans, blockSpan) : blockSpan;\n        }\n        \n        var fetchRanges = spans.ranges();\n        for (var r = 0; r < fetchRanges.length; ++r) {\n            var fr = fetchRanges[r];\n            cirFobStartFetch(offset, fr, level);\n        }\n    }\n\n    var cirFobStartFetch = function(offset, fr, level, attempts) {\n        var length = fr.max() - fr.min();\n        thisB.bwg.data.slice(fr.min(), fr.max() - fr.min()).fetch(function(resultBuffer) {\n            for (var i = 0; i < offset.length; ++i) {\n                if (fr.contains(offset[i])) {\n                    cirFobRecur2(resultBuffer, offset[i] - fr.min(), level);\n                    --outstanding;\n                    if (outstanding == 0) {\n                        if (!blockToFetch) {\n                            if (dir > 0 && (chr != 0 || pos > 0)) {\n                                return thisB.getFirstAdjacentById(0, 0, dir, callback);\n                            } else if (dir < 0 && (chr != thisB.bwg.maxID || pos < 1000000000)) {\n                                return thisB.getFirstAdjacentById(thisB.bwg.maxID, 1000000000, dir, callback);\n                            }\n                            return callback([]);\n                        }\n\n                        thisB.fetchFeatures(function(chrx, fmin, fmax, toks) {\n                            return (dir < 0 && (chrx < chr || fmax < pos)) || (dir > 0 && (chrx > chr || fmin > pos));\n                        }, [blockToFetch], function(features) {\n                            var bestFeature = null;\n                            var bestChr = -1;\n                            var bestPos = -1;\n                            for (var fi = 0; fi < features.length; ++fi) {\n                                var f = features[fi];\n                                var chrx = f._chromId, fmin = f.min, fmax = f.max;\n                                if (bestFeature == null || ((dir < 0) && (chrx > bestChr || fmax > bestPos)) || ((dir > 0) && (chrx < bestChr || fmin < bestPos))) {\n                                    bestFeature = f;\n                                    bestPos = (dir < 0) ? fmax : fmin;\n                                    bestChr = chrx;\n                                }\n                            }\n\n                            if (bestFeature != null) \n                                return callback([bestFeature]);\n                            else\n                                return callback([]);\n                        });\n                    }\n                }\n            }\n        });\n    }\n\n    var cirFobRecur2 = function(cirBlockData, offset, level) {\n        var ba = new Uint8Array(cirBlockData);\n        var sa = new Int16Array(cirBlockData);\n        var la = new Int32Array(cirBlockData);\n\n        var isLeaf = ba[offset];\n        var cnt = sa[offset/2 + 1];\n        offset += 4;\n\n        if (isLeaf != 0) {\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = bwg_readOffset(ba, offset+16);\n                var blockSize = bwg_readOffset(ba, offset+24);\n                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)))) ||\n                    (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)))))\n                {\n                    // console.log('Got an interesting block: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                    if (/_random/.exec(thisB.bwg.idsToChroms[startChrom])) {\n                        // dlog('skipping random: ' + thisB.bwg.idsToChroms[startChrom]);\n                    } else if (blockToFetch == null || ((dir < 0) && (endChrom > bestBlockChr || (endChrom == bestBlockChr && endBase > bestBlockOffset)) ||\n                                                 (dir > 0) && (startChrom < bestBlockChr || (startChrom == bestBlockChr && startBase < bestBlockOffset))))\n                    {\n                        //                        dlog('best is: startBase=' + startChrom + ':' + startBase + '; endBase=' + endChrom + ':' + endBase + '; offset=' + blockOffset + '; size=' + blockSize);\n                        blockToFetch = {offset: blockOffset, size: blockSize};\n                        bestBlockOffset = (dir < 0) ? endBase : startBase;\n                        bestBlockChr = (dir < 0) ? endChrom : startChrom;\n                    }\n                }\n                offset += 32;\n            }\n        } else {\n            var bestRecur = -1;\n            var bestPos = -1;\n            var bestChr = -1;\n            for (var i = 0; i < cnt; ++i) {\n                var lo = offset/4;\n                var startChrom = la[lo];\n                var startBase = la[lo + 1];\n                var endChrom = la[lo + 2];\n                var endBase = la[lo + 3];\n                var blockOffset = (la[lo + 4]<<32) | (la[lo + 5]);\n                if ((dir < 0 && ((startChrom < chr || (startChrom == chr && startBase <= pos)) &&\n                                 (endChrom   >= chr))) ||\n                     (dir > 0 && ((endChrom > chr || (endChrom == chr && endBase >= pos)) &&\n                                  (startChrom <= chr))))\n                {\n                    if (bestRecur < 0 || endBase > bestPos) {\n                        bestRecur = blockOffset;\n                        bestPos = (dir < 0) ? endBase : startBase;\n                        bestChr = (dir < 0) ? endChrom : startChrom;\n                    }\n                }\n                offset += 24;\n            }\n            if (bestRecur >= 0) {\n                cirFobRecur([bestRecur], level + 1);\n            }\n        }\n    };\n    \n\n    cirFobRecur([thisB.cirTreeOffset + 48], 1);\n}\n\nBigWig.prototype.readWigData = function(chrName, min, max, callback) {\n    this.getUnzoomedView().readWigData(chrName, min, max, callback);\n}\n\nBigWig.prototype.getUnzoomedView = function() {\n    if (!this.unzoomedView) {\n        var cirLen = 4000;\n        var nzl = this.zoomLevels[0];\n        if (nzl) {\n            cirLen = this.zoomLevels[0].dataOffset - this.unzoomedIndexOffset;\n        }\n        this.unzoomedView = new BigWigView(this, this.unzoomedIndexOffset, cirLen, false);\n    }\n    return this.unzoomedView;\n}\n\nBigWig.prototype.getZoomedView = function(z) {\n    var zh = this.zoomLevels[z];\n    if (!zh.view) {\n        zh.view = new BigWigView(this, zh.indexOffset, /* this.zoomLevels[z + 1].dataOffset - zh.indexOffset */ 4000, true);\n    }\n    return zh.view;\n}\n\nfunction makeBwg(data, callback, name) {\n    var bwg = new BigWig();\n    bwg.data = data;\n    bwg.name = name;\n    bwg.data.slice(0, 512).salted().fetch(function(result) {\n        if (!result) {\n            return callback(null, \"Couldn't fetch file\");\n        }\n\n        var header = result;\n        var ba = new Uint8Array(header);\n        var sa = new Int16Array(header);\n        var la = new Int32Array(header);\n        var magic = ba[0] + (M1 * ba[1]) + (M2 * ba[2]) + (M3 * ba[3]);\n        if (magic == BIG_WIG_MAGIC) {\n            bwg.type = 'bigwig';\n        } else if (magic == BIG_BED_MAGIC) {\n            bwg.type = 'bigbed';\n        } else if (magic == BIG_WIG_MAGIC_BE || magic == BIG_BED_MAGIC_BE) {\n            return callback(null, \"Currently don't support big-endian BBI files\");\n            \n        } else {\n            return callback(null, \"Not a supported format, magic=0x\" + magic.toString(16));\n            \n        }\n\n        bwg.version = sa[2];             // 4\n        bwg.numZoomLevels = sa[3];       // 6\n        bwg.chromTreeOffset = bwg_readOffset(ba, 8);\n        bwg.unzoomedDataOffset = bwg_readOffset(ba, 16);\n        bwg.unzoomedIndexOffset = bwg_readOffset(ba, 24);\n        bwg.fieldCount = sa[16];         // 32\n        bwg.definedFieldCount = sa[17];  // 34\n        bwg.asOffset = bwg_readOffset(ba, 36);\n        bwg.totalSummaryOffset = bwg_readOffset(ba, 44);\n        bwg.uncompressBufSize = la[13];  // 52\n        bwg.extHeaderOffset = bwg_readOffset(ba, 56);\n\n        bwg.zoomLevels = [];\n        for (var zl = 0; zl < bwg.numZoomLevels; ++zl) {\n            var zlReduction = la[zl*6 + 16]\n            var zlData = bwg_readOffset(ba, zl*24 + 72);\n            var zlIndex = bwg_readOffset(ba, zl*24 + 80);\n            bwg.zoomLevels.push({reduction: zlReduction, dataOffset: zlData, indexOffset: zlIndex});\n        }\n\n        bwg.readChromTree(function() {\n            bwg.getAutoSQL(function(as) {\n                bwg.schema = as;\n                return callback(bwg);\n            });\n        });\n    }, {timeout: 5000});    // Potential timeout on first request to catch mixed-content errors on\n                            // Chromium.\n}\n\n\nBigWig.prototype._tsFetch = function(zoom, chr, min, max, callback) {\n    var bwg = this;\n    if (zoom >= this.zoomLevels.length - 1) {\n        if (!this.topLevelReductionCache) {\n            this.getZoomedView(this.zoomLevels.length - 1).readWigDataById(-1, 0, 300000000, function(feats) {\n                bwg.topLevelReductionCache = feats;\n                return bwg._tsFetch(zoom, chr, min, max, callback);\n            });\n        } else {\n            var f = [];\n            var c = this.topLevelReductionCache;\n            for (var fi = 0; fi < c.length; ++fi) {\n                if (c[fi]._chromId == chr) {\n                    f.push(c[fi]);\n                }\n            }\n            return callback(f);\n        }\n    } else {\n        var view;\n        if (zoom < 0) {\n            view = this.getUnzoomedView();\n        } else {\n            view = this.getZoomedView(zoom);\n        }\n        return view.readWigDataById(chr, min, max, callback);\n    }\n}\n\nBigWig.prototype.thresholdSearch = function(chrName, referencePoint, dir, threshold, callback) {\n    dir = (dir<0) ? -1 : 1;\n    var bwg = this;\n    var initialChr = this.chromsToIDs[chrName];\n    var candidates = [{chrOrd: 0, chr: initialChr, zoom: bwg.zoomLevels.length - 4, min: 0, max: 300000000, fromRef: true}]\n    for (var i = 1; i <= this.maxID + 1; ++i) {\n        var chrId = (initialChr + (dir*i)) % (this.maxID + 1);\n        if (chrId < 0) \n            chrId += (this.maxID + 1);\n        candidates.push({chrOrd: i, chr: chrId, zoom: bwg.zoomLevels.length - 1, min: 0, max: 300000000})\n    }\n       \n    function fbThresholdSearchRecur() {\n    \tif (candidates.length == 0) {\n    \t    return callback(null);\n    \t}\n    \tcandidates.sort(function(c1, c2) {\n    \t    var d = c1.zoom - c2.zoom;\n    \t    if (d != 0)\n    \t\t    return d;\n\n            d = c1.chrOrd - c2.chrOrd;\n            if (d != 0)\n                return d;\n    \t    else\n    \t\t    return c1.min - c2.min * dir;\n    \t});\n\n\t    var candidate = candidates.splice(0, 1)[0];\n        bwg._tsFetch(candidate.zoom, candidate.chr, candidate.min, candidate.max, function(feats) {\n            var rp = dir > 0 ? 0 : 300000000;\n            if (candidate.fromRef)\n                rp = referencePoint;\n            \n            for (var fi = 0; fi < feats.length; ++fi) {\n    \t        var f = feats[fi];\n                var score;\n                if (f.maxScore != undefined)\n                    score = f.maxScore;\n                else\n                    score = f.score;\n\n                if (dir > 0) {\n    \t            if (score > threshold) {\n        \t\t        if (candidate.zoom < 0) {\n        \t\t            if (f.min > rp)\n                                return callback(f);\n        \t\t        } else if (f.max > rp) {\n        \t\t            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n        \t\t        }\n                    }\n                } else {\n                    if (score > threshold) {\n            \t\t    if (candidate.zoom < 0) {\n                \t        if (f.max < rp)\n                \t\t\t    return callback(f);\n                        } else if (f.min < rp) {\n                            candidates.push({chr: candidate.chr, chrOrd: candidate.chrOrd, zoom: candidate.zoom - 2, min: f.min, max: f.max, fromRef: candidate.fromRef});\n                        }\n    \t            }\n                }\n    \t    }\n            fbThresholdSearchRecur();\n        });\n    }\n    \n    fbThresholdSearchRecur();\n}\n\nBigWig.prototype.getAutoSQL = function(callback) {\n    var thisB = this;\n    if (!this.asOffset)\n        return callback(null);\n\n\n    this.data.slice(this.asOffset, 2048).fetch(function(result) {\n        var ba = new Uint8Array(result);\n        var s = '';\n        for (var i = 0; i < ba.length; ++i) {\n            if (ba[i] == 0)\n                break;\n            s += String.fromCharCode(ba[i]);\n        }\n        \n        /* \n         * Quick'n'dirty attempt to parse autoSql format.\n         * See: http://www.linuxjournal.com/files/linuxjournal.com/linuxjournal/articles/059/5949/5949l2.html\n         */\n\n        var header_re = /(\\w+)\\s+(\\w+)\\s+(\"([^\"]+)\")?\\s+\\(\\s*/;\n        var field_re = /([\\w\\[\\]]+)\\s+(\\w+)\\s*;\\s*(\"([^\"]+)\")?\\s*/g;\n\n        var headerMatch = header_re.exec(s);\n        if (headerMatch) {\n            var as = {\n                declType: headerMatch[1],\n                name: headerMatch[2],\n                comment: headerMatch[4],\n\n                fields: []\n            };\n\n            s = s.substring(headerMatch[0]);\n            for (var m = field_re.exec(s); m != null; m = field_re.exec(s)) {\n                as.fields.push({type: m[1],\n                             name: m[2],\n                             comment: m[4]});\n            }\n\n            return callback(as);\n        }\n    });\n}\n\nBigWig.prototype.getExtraIndices = function(callback) {\n    var thisB = this;\n    if (this.version < 4 || this.extHeaderOffset == 0 || this.type != 'bigbed') {\n        return callback(null);\n    } else {\n        this.data.slice(this.extHeaderOffset, 64).fetch(function(result) {\n            if (!result) {\n                return callback(null, \"Couldn't fetch extension header\");\n            }\n\n            var ba = new Uint8Array(result);\n            var sa = new Int16Array(result);\n            var la = new Int32Array(result);\n            \n            var extHeaderSize = sa[0];\n            var extraIndexCount = sa[1];\n            var extraIndexListOffset = bwg_readOffset(ba, 4);\n\n            if (extraIndexCount == 0) {\n                return callback(null);\n            }\n\n            // FIXME 20byte records only make sense for single-field indices.\n            // Right now, these seem to be the only things around, but the format\n            // is actually more general.\n            thisB.data.slice(extraIndexListOffset, extraIndexCount * 20).fetch(function(eil) {\n                if (!eil) {\n                    return callback(null, \"Couldn't fetch index info\");\n                }\n\n                var ba = new Uint8Array(eil);\n                var sa = new Int16Array(eil);\n                var la = new Int32Array(eil);\n\n                var indices = [];\n                for (var ii = 0; ii < extraIndexCount; ++ii) {\n                    var eiType = sa[ii*10];\n                    var eiFieldCount = sa[ii*10 + 1];\n                    var eiOffset = bwg_readOffset(ba, ii*20 + 4);\n                    var eiField = sa[ii*10 + 8]\n                    var index = new BBIExtraIndex(thisB, eiType, eiFieldCount, eiOffset, eiField);\n                    indices.push(index);\n                }\n                callback(indices);\n            });\n        });\n    }\n}\n\nfunction BBIExtraIndex(bbi, type, fieldCount, offset, field) {\n    this.bbi = bbi;\n    this.type = type;\n    this.fieldCount = fieldCount;\n    this.offset = offset;\n    this.field = field;\n}\n\nBBIExtraIndex.prototype.lookup = function(name, callback) {\n    var thisB = this;\n\n    this.bbi.data.slice(this.offset, 32).fetch(function(bpt) {\n        var ba = new Uint8Array(bpt);\n        var sa = new Int16Array(bpt);\n        var la = new Int32Array(bpt);\n        var bptMagic = la[0];\n        var blockSize = la[1];\n        var keySize = la[2];\n        var valSize = la[3];\n        var itemCount = bwg_readOffset(ba, 16);\n        var rootNodeOffset = 32;\n\n        function bptReadNode(nodeOffset) {\n            thisB.bbi.data.slice(nodeOffset, 4 + (blockSize * (keySize + valSize))).fetch(function(node) {\n                var ba = new Uint8Array(node);\n                var sa = new Uint16Array(node);\n                var la = new Uint32Array(node);\n\n                var nodeType = ba[0];\n                var cnt = sa[1];\n\n                var offset = 4;\n                if (nodeType == 0) {\n                    var lastChildOffset = null;\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n\n                        var childOffset = bwg_readOffset(ba, offset);\n                        offset += 8;\n                        \n                        if (name.localeCompare(key) < 0 && lastChildOffset) {\n                            bptReadNode(lastChildOffset);\n                            return;\n                        }\n                        lastChildOffset = childOffset;\n                    }\n                    bptReadNode(lastChildOffset);\n                } else {\n                    for (var n = 0; n < cnt; ++n) {\n                        var key = '';\n                        for (var ki = 0; ki < keySize; ++ki) {\n                            var charCode = ba[offset++];\n                            if (charCode != 0) {\n                                key += String.fromCharCode(charCode);\n                            }\n                        }\n                        \n                        // Specific for EI case.\n                        if (key == name) {\n                            var start = bwg_readOffset(ba, offset);\n                            var length = readInt(ba, offset + 8);\n\n                            return thisB.bbi.getUnzoomedView().fetchFeatures(\n                                function(chr, min, max, toks) {\n                                    if (toks && toks.length > thisB.field - 3)\n                                        return toks[thisB.field - 3] == name;\n                                }, \n                                [{offset: start, size: length}], \n                                callback);\n                        }\n                        offset += valSize;\n                    }\n                    return callback([]);\n                }\n            });\n        }\n\n        bptReadNode(thisB.offset + rootNodeOffset);\n    });\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeBwg: makeBwg,\n        BIG_BED_MAGIC: BIG_BED_MAGIC,\n        BIG_WIG_MAGIC: BIG_WIG_MAGIC\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bin.js general binary data support\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction BlobFetchable(b) {\n    this.blob = b;\n}\n\nBlobFetchable.prototype.slice = function(start, length) {\n    var b;\n\n    if (this.blob.slice) {\n        if (length) {\n            b = this.blob.slice(start, start + length);\n        } else {\n            b = this.blob.slice(start);\n        }\n    } else {\n        if (length) {\n            b = this.blob.webkitSlice(start, start + length);\n        } else {\n            b = this.blob.webkitSlice(start);\n        }\n    }\n    return new BlobFetchable(b);\n}\n\nBlobFetchable.prototype.salted = function() {return this;}\n\nif (typeof(FileReader) !== 'undefined') {\n    // console.log('defining async BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function(callback) {\n        var reader = new FileReader();\n        reader.onloadend = function(ev) {\n            callback(bstringToBuffer(reader.result));\n        };\n        reader.readAsBinaryString(this.blob);\n    }\n\n} else {\n    // if (console && console.log)\n    //    console.log('defining sync BlobFetchable.fetch');\n\n    BlobFetchable.prototype.fetch = function(callback) {\n        var reader = new FileReaderSync();\n        try {\n            var res = reader.readAsArrayBuffer(this.blob);\n            callback(res);\n        } catch (e) {\n            callback(null, e);\n        }\n    }\n}\n\nfunction URLFetchable(url, start, end, opts) {\n    if (!opts) {\n        if (typeof start === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = url;\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\nURLFetchable.prototype.slice = function(s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start, ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new URLFetchable(this.url, ns, ne, this.opts);\n}\n\nvar seed=0;\nvar isSafari = navigator.userAgent.indexOf('Safari') >= 0 && navigator.userAgent.indexOf('Chrome') < 0 ;\n\nURLFetchable.prototype.fetchAsText = function(callback) {\n    var thisB = this;\n\n    this.getURL().then(function(url) {\n        try {\n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n            }\n            req.open('GET', url, true);\n            \n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200 || req.status == 206) {\n                        return callback(req.responseText);\n                    } else {\n                        return callback(null);\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send('');\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null, err);\n    });\n}\n\nURLFetchable.prototype.salted = function() {\n    var o = shallowCopy(this.opts);\n    o.salt = true;\n    return new URLFetchable(this.url, this.start, this.end, o);\n}\n\nURLFetchable.prototype.getURL = function() {\n    if (this.opts.resolver) {\n        return this.opts.resolver(this.url).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(this.url);\n    }\n}\n\nURLFetchable.prototype.fetch = function(callback, opts) {\n    var thisB = this;\n \n    opts = opts || {};\n    var attempt = opts.attempt || 1;\n    var truncatedLength = opts.truncatedLength;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    this.getURL().then(function(url) {\n        try {\n            var timeout;\n            if (opts.timeout && !thisB.opts.credentials) {\n                timeout = setTimeout(\n                    function() {\n                        console.log('timing out ' + url);\n                        req.abort();\n                        return callback(null, 'Timeout');\n                    },\n                    opts.timeout\n                );\n            }\n            \n            var req = new XMLHttpRequest();\n            var length;\n            if ((isSafari || thisB.opts.salt) && url.indexOf('?') < 0) {\n                url = url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++seed));\n            }\n            req.open('GET', url, true);\n            req.overrideMimeType('text/plain; charset=x-user-defined');\n            if (thisB.end) {\n                if (thisB.end - thisB.start > 100000000) {\n                    throw 'Monster fetch!';\n                }\n                req.setRequestHeader('Range', 'bytes=' + thisB.start + '-' + thisB.end);\n                length = thisB.end - thisB.start + 1;\n            }\n            req.responseType = 'arraybuffer';\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (timeout)\n                        clearTimeout(timeout);\n                    if (req.status == 200 || req.status == 206) {\n                        if (req.response) {\n                            var bl = req.response.byteLength;\n                            if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                                return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: bl});\n                            } else {\n                                return callback(req.response);\n                            }\n                        } else if (req.mozResponseArrayBuffer) {\n                            return callback(req.mozResponseArrayBuffer);\n                        } else {\n                            var r = req.responseText;\n                            if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                                return thisB.fetch(callback, {attempt: attempt + 1, truncatedLength: r.length});\n                            } else {\n                                return callback(bstringToBuffer(req.responseText));\n                            }\n                        }\n                    } else {\n                        return thisB.fetch(callback, {attempt: attempt + 1});\n                    }\n                }\n            };\n            if (thisB.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send('');\n        } catch (e) {\n            return callback(null);\n        }\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null, err);\n    });\n}\n                       \nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\n// Read from Uint8Array\n\n(function(global) {\n    var convertBuffer = new ArrayBuffer(8);\n    var ba = new Uint8Array(convertBuffer);\n    var fa = new Float32Array(convertBuffer);\n\n\n    global.readFloat = function(buf, offset) {\n        ba[0] = buf[offset];\n        ba[1] = buf[offset+1];\n        ba[2] = buf[offset+2];\n        ba[3] = buf[offset+3];\n        return fa[0];\n    };\n }(this));\n\nfunction readInt64(ba, offset) {\n    return (ba[offset + 7] << 24) | (ba[offset + 6] << 16) | (ba[offset + 5] << 8) | (ba[offset + 4]);\n}\n\nfunction readInt(ba, offset) {\n    return (ba[offset + 3] << 24) | (ba[offset + 2] << 16) | (ba[offset + 1] << 8) | (ba[offset]);\n}\n\nfunction readShort(ba, offset) {\n    return (ba[offset + 1] << 8) | (ba[offset]);\n}\n\nfunction readByte(ba, offset) {\n    return ba[offset];\n}\n\nfunction readIntBE(ba, offset) {\n    return (ba[offset] << 24) | (ba[offset + 1] << 16) | (ba[offset + 2] << 8) | (ba[offset + 3]);\n}\n\n// Exports if we are being used as a module\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        BlobFetchable: BlobFetchable,\n        URLFetchable: URLFetchable,\n\n        readInt: readInt,\n        readIntBE: readIntBE,\n        readInt64: readInt64,\n        readShort: readShort,\n        readByte: readByte,\n        readFloat: this.readFloat\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n//\n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// browser-us.js: standard UI wiring\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n\n    var nf = require('./numformats');\n    var formatLongInt = nf.formatLongInt;\n\n    var makeZoomSlider = require('./zoomslider');\n\n    // For side effects\n\n    require('./tier-edit');\n    require('./export-config');\n    require('./export-ui');\n    require('./export-image');\n    require('./svg-export');\n    require('./session');\n}\n\n/*\n * Quite a bit of this ought to be done using a templating system, but\n * since web-components isn't quite ready for prime time yet we'll stick\n * with constructing it all in Javascript for now...\n */\n\nBrowser.prototype.initUI = function(holder, genomePanel) {\n    if (!this.noSourceCSS) {\n      ['bootstrap-scoped.css', 'dalliance-scoped.css', 'font-awesome.min.css'].forEach(function(path) {\n        document.head.appendChild(makeElement('link', '', {\n          rel: 'stylesheet',\n          href: this.resolveURL('$$css/' + path)\n        }));\n      }.bind(this));\n    }\n\n    var b = this;\n\n    if (!b.disableDefaultFeaturePopup) {\n        this.addFeatureListener(function(ev, feature, hit, tier) {\n            b.featurePopup(ev, feature, hit, tier);\n        });\n    }\n\n    holder.classList.add('dalliance');\n    var toolbar = b.toolbar = makeElement('div', null, {className: 'btn-toolbar toolbar'});\n\n    var title = b.coordSystem.speciesName + ' ' + b.nameForCoordSystem(b.coordSystem);\n    if (this.setDocumentTitle) {\n        document.title = title + ' :: dalliance';\n    }\n\n    var locField = makeElement('input', '', {className: 'loc-field'});\n    b.makeTooltip(locField, 'Enter a genomic location or gene name');\n    var locStatusField = makeElement('p', '', {className: 'loc-status'});\n\n    var zoomInBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-search-plus'})], {className: 'btn'});\n    var zoomSlider = new makeZoomSlider({width: b.zoomSliderWidth});\n    b.makeTooltip(zoomSlider, \"Highlighted button shows current zoom level, gray button shows inactive zoom level (click or tap SPACE to toggle).\")\n\n    var zoomOutBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-search-minus'})], {className: 'btn'});\n\n    var clearHighlightsButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-eraser'})], {className: 'btn'});\n\n    var addTrackBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-plus'})], {className: 'btn'});\n    var favBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-bookmark'})], {className: 'btn'});\n    var svgBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-print'})], {className: 'btn'});\n    var resetBtn = makeElement('a', [makeElement('i', null, {className: 'fa fa-refresh'})], {className: 'btn'});\n    var optsButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-cogs'})], {className: 'btn'});\n    var helpButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-question'})], {className: 'btn'});\n\n    var tierEditButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-road'})], {className: 'btn'});\n    b.makeTooltip(tierEditButton, 'Configure currently selected track(s) (E)')\n\n    var leapLeftButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-angle-left'})], {className: 'btn'}, {width: '5px'});\n    var leapRightButton = makeElement('a', [makeElement('i', null, {className: 'fa fa-angle-right'})], {className: 'btn pull-right'}, {width: '5px'});\n\n    var modeButtons = makeElement('div', null, {className: 'btn-group pull-right'});\n    if (!this.noTrackAdder)\n        modeButtons.appendChild(addTrackBtn);\n    if (!this.noTrackEditor)\n        modeButtons.appendChild(tierEditButton);\n    if (!this.noExport)\n        modeButtons.appendChild(svgBtn);\n    if (!this.noOptions)\n        modeButtons.appendChild(optsButton);\n    if (!this.noHelp)\n        modeButtons.appendChild(helpButton);\n\n    this.setUiMode = function(m) {\n        this.uiMode = m;\n        var mb = {help: helpButton, add: addTrackBtn, opts: optsButton, 'export': svgBtn, tier: tierEditButton};\n        for (var x in mb) {\n            if (x == m)\n                mb[x].classList.add('active');\n            else\n                mb[x].classList.remove('active');\n        }\n    }\n\n    if (!this.noLeapButtons)\n        toolbar.appendChild(leapRightButton);\n\n    if (modeButtons.firstChild)\n        toolbar.appendChild(modeButtons);\n    \n    if (!this.noLeapButtons)\n        toolbar.appendChild(leapLeftButton);\n    if (!this.noTitle) {\n        toolbar.appendChild(makeElement('div', makeElement('h4', title, {}, {margin: '0px'}), {className: 'btn-group title'}));\n    }\n    if (!this.noLocationField)\n        toolbar.appendChild(makeElement('div', [locField, locStatusField], {className: 'btn-group loc-group'}));\n    if (!this.noClearHighlightsButton)\n        toolbar.appendChild(clearHighlightsButton);\n\n    if (!this.noZoomSlider) {\n        toolbar.appendChild(makeElement('div', [zoomInBtn,\n                                                makeElement('span', zoomSlider, {className: 'btn'}),\n                                                zoomOutBtn], {className: 'btn-group'}));\n    }\n    \n    if (this.toolbarBelow) {\n        holder.appendChild(genomePanel);\n        holder.appendChild(toolbar);\n    } else {\n        holder.appendChild(toolbar);\n        holder.appendChild(genomePanel);\n    }\n\n\n    var lt2 = Math.log(2) / Math.log(10);\n    var lt5 = Math.log(5) / Math.log(10);\n    var roundSliderValue = function(x) {\n        var ltx = (x / b.zoomExpt + Math.log(b.zoomBase)) / Math.log(10);\n        \n        var whole = ltx|0\n        var frac = ltx - whole;\n        var rounded\n\n        if (frac < 0.01)\n            rounded = whole;\n        else if (frac <= (lt2 + 0.01))\n            rounded = whole + lt2;\n        else if (frac <= (lt5 + 0.01))\n            rounded = whole + lt5;\n        else {\n            rounded = whole + 1;\n        }\n\n        return (rounded * Math.log(10) -Math.log(b.zoomBase)) * b.zoomExpt;\n    }\n\n    var markSlider = function(x) {\n        zoomSlider.addLabel(x, humanReadableScale(Math.exp(x / b.zoomExpt) * b.zoomBase));\n    }\n\n    this.addViewListener(function(chr, min, max, _oldZoom, zoom) {\n        locField.value = (chr + ':' + formatLongInt(min) + '..' + formatLongInt(max));\n        zoomSlider.min = zoom.min|0;\n        zoomSlider.max = zoom.max|0;\n        if (zoom.isSnapZooming) {\n            zoomSlider.value = zoom.alternate\n            zoomSlider.value2 = zoom.current;\n            zoomSlider.active = 2;\n        } else {\n            zoomSlider.value = zoom.current;\n            zoomSlider.value2 = zoom.alternate;\n            zoomSlider.active = 1;\n        }\n\n        if (zoom.current == zoom.min)\n            zoomInBtn.classList.add('disabled');\n        else\n            zoomInBtn.classList.remove('disabled');\n\n        if (zoom.current == zoom.max)\n            zoomOutBtn.classList.add('disabled');\n        else\n            zoomOutBtn.classList.remove('disabled');\n\n        zoomSlider.removeLabels();\n        var zmin = zoom.min;\n        var zmax = zoom.max;\n        var zrange = zmax - zmin;\n\n        \n        var numSliderTicks = 4;\n        if (b.zoomSliderWidth && b.zoomSliderWidth < 150)\n            numSliderTicks = 3;\n        markSlider(roundSliderValue(zmin));\n        for (var sti = 1; sti < numSliderTicks - 1; ++sti) {\n            markSlider(roundSliderValue(zmin + (1.0 * sti * zrange / (numSliderTicks -1))));\n        }\n        markSlider(roundSliderValue(zmax));\n\n        if (b.storeStatus) {\n            b.storeViewStatus();\n        }\n\n        if (b.highlights.length > 0) {\n            clearHighlightsButton.style.display = 'inline-block';\n        } else {\n            clearHighlightsButton.style.display = 'none';\n        }\n    });\n\n    this.addTierListener(function() {\n        if (b.storeStatus) {\n            b.storeTierStatus();\n        }\n    });\n\n    locField.addEventListener('keydown', function(ev) {\n        if (ev.keyCode == 40) {\n            ev.preventDefault(); ev.stopPropagation();\n            b.setSelectedTier(0);\n        } if (ev.keyCode == 10 || ev.keyCode == 13) {\n            ev.preventDefault();\n\n\n            var g = locField.value;\n            b.search(g, function(err) {\n                if (err) {\n                    locStatusField.textContent = '' + err;\n                } else {\n                    locStatusField.textContent = '';\n                }\n            });\n        }\n    }, false);\n    \n    var trackAddPopup;\n    addTrackBtn.addEventListener('click', function(ev) {\n        if (trackAddPopup && trackAddPopup.displayed) {\n            b.removeAllPopups();\n        } else {\n            trackAddPopup = b.showTrackAdder(ev);\n        }\n    }, false);\n    b.makeTooltip(addTrackBtn, 'Add a new track from the registry or an indexed file. (A)');\n\n    zoomInBtn.addEventListener('click', function(ev) {\n      ev.stopPropagation(); ev.preventDefault();\n\n      b.zoomStep(-10);\n    }, false);\n    b.makeTooltip(zoomInBtn, 'Zoom in (+)');\n\n    zoomOutBtn.addEventListener('click', function(ev) {\n      ev.stopPropagation(); ev.preventDefault();\n\n      b.zoomStep(10);\n    }, false);\n    b.makeTooltip(zoomOutBtn, 'Zoom out (-)');\n\n    zoomSlider.addEventListener('change', function(ev) {\n        var wantSnap = zoomSlider.active == 2;\n        if (wantSnap != b.isSnapZooming) {\n            b.savedZoom = b.zoomSliderValue  - b.zoomMin;\n            b.isSnapZooming = wantSnap;\n        }\n        var activeZSV = zoomSlider.active == 1 ? zoomSlider.value : zoomSlider.value2;\n\n    \tb.zoomSliderValue = (1.0 * activeZSV);\n    \tb.zoom(Math.exp((1.0 * activeZSV) / b.zoomExpt));\n    }, false);\n\n    favBtn.addEventListener('click', function(ev) {\n       ev.stopPropagation(); ev.preventDefault();\n    }, false);\n    b.makeTooltip(favBtn, 'Favourite regions');\n\n    svgBtn.addEventListener('click', function(ev) {\n       ev.stopPropagation(); ev.preventDefault();\n        b.openExportPanel();\n    }, false);\n    b.makeTooltip(svgBtn, 'Export publication-quality SVG. (X)');\n\n    var optsPopup;\n    optsButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n\n        b.toggleOptsPopup(ev);\n    }, false);\n    b.makeTooltip(optsButton, 'Configure options.');\n\n    helpButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        b.toggleHelpPopup(ev);\n    });\n    b.makeTooltip(helpButton, 'Help; Keyboard shortcuts. (H)');\n\n    tierEditButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        if (b.selectedTiers.length == 1) {\n            b.openTierPanel(b.tiers[b.selectedTiers[0]]);\n        }\n    }, false);\n\n    leapLeftButton.addEventListener('click', function(ev) {\n        b.leap(b.reverseKeyScrolling ? -1 : 1, false);\n    }, false);\n    b.makeTooltip(leapLeftButton, function(ev) {\n        var st = b.getSelectedTier();\n        var tier;\n        if (st >= 0)\n            tier = b.tiers[st];\n\n        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number') {\n            return 'Jump to the next region with a score above the threshold in the selected track \"' + (tier.config.name || tier.dasSource.name) + '\"\" (ctrl+LEFT)';\n        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {\n            return 'Jump to the next feature in the selected track \"' + (tier.config.name || tier.dasSource.name) + '\" (ctrl+LEFT)';\n        } else {\n            return 'Jump left (shift+LEFT)';\n        }\n    });\n\n    leapRightButton.addEventListener('click', function(ev) {\n        b.leap(b.reverseKeyScrolling ? 1 : -1, false);\n    }, false);\n    b.makeTooltip(leapRightButton, function(ev) {\n        var st = b.getSelectedTier();\n        var tier;\n        if (st >= 0)\n            tier = b.tiers[st];\n\n        if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number') {\n            return 'Jump to the next region with a score above the threshold in the selected track \"' + (tier.config.name || tier.dasSource.name) + '\"\" (ctrl+RIGHT)';\n        } else if (tier && tier.featureSource && b.sourceAdapterIsCapable(tier.featureSource, 'leap')) {\n            return 'Jump to the next feature in the selected track \"' + (tier.config.name || tier.dasSource.name) + '\" (ctrl+RIGHT)';\n        } else {\n            return 'Jump right (shift+RIGHT)';\n        }\n    });\n    b.addTierSelectionListener(function() {\n        var st = b.getSelectedTier();\n        var tier;\n        if (st >= 0)\n            tier = b.tiers[st];\n\n        var canLeap = false;\n        if (tier && tier.featureSource) {\n            if (b.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number')\n                canLeap = true;\n            else if (b.sourceAdapterIsCapable(tier.featureSource, 'leap'))\n                canLeap = true;\n        }\n\n        leapLeftButton.firstChild.className = canLeap ? 'fa fa-angle-double-left' : 'fa fa-angle-left';\n        leapRightButton.firstChild.className = canLeap ? 'fa fa-angle-double-right' : 'fa fa-angle-right';\n    });\n\n    clearHighlightsButton.addEventListener('click', function(ev) {\n        b.clearHighlights();\n    }, false);\n    b.makeTooltip(clearHighlightsButton, 'Clear highlights (C)');\n\n    b.addTierSelectionWrapListener(function(dir) {\n        if (dir < 0) {\n            b.setSelectedTier(null);\n            locField.focus();\n        }\n    });\n\n    b.addTierSelectionListener(function(sel) {\n        if (b.uiMode === 'tier') {\n            if (sel.length == 0) {\n                b.hideToolPanel();\n                b.manipulatingTier = null;\n                b.uiMode = 'none';\n            } else {\n                var ft = b.tiers[sel[0]];\n                if (ft != b.manipulatingTier) {\n                    b.openTierPanel(ft);\n                }\n            }\n        }\n    });\n\n    var uiKeyHandler = function(ev) {\n        // console.log('bukh: ' + ev.keyCode);\n        if (ev.keyCode == 65 || ev.keyCode == 97) {  // a\n            ev.preventDefault(); ev.stopPropagation();\n            b.showTrackAdder();\n        } else if (ev.keyCode == 72 || ev.keyCode == 104) { // h\n            ev.stopPropagation(); ev.preventDefault();\n            b.toggleHelpPopup(ev);\n        } else if (ev.keyCode == 69 || ev.keyCode == 101) { //e\n            ev.stopPropagation(); ev.preventDefault();\n            if (b.selectedTiers.length == 1) {\n                b.openTierPanel(b.tiers[b.selectedTiers[0]]);\n            }\n        } else if (ev.keyCode == 88 || ev.keyCode == 120) { // x\n            ev.stopPropagation(); ev.preventDefault();\n            b.openExportPanel();\n        } else if (ev.keyCode == 67 || ev.keyCode == 99) { // c\n            ev.stopPropagation(); ev.preventDefault();\n            b.clearHighlights();\n        }\n    };\n\n    holder.addEventListener('focus', function(ev) {\n        holder.addEventListener('keydown', uiKeyHandler, false);\n    }, false);\n    holder.addEventListener('blur', function(ev) {\n        holder.removeEventListener('keydown', uiKeyHandler, false);\n    }, false);\n\n    holder.addEventListener('keydown', function(ev) {\n        if (ev.keyCode === 27) {\n            if (b.uiMode !== 'none') {\n                // Only consume event if tool panel is open.\n                ev.preventDefault();\n                ev.stopPropagation();\n                b.setUiMode('none');\n                b.hideToolPanel();\n\n                if (b.selectedTiers && b.selectedTiers.length > 0) {\n                    b.browserHolder.focus();\n                }\n            }\n        }\n    }, false);\n}\n\nBrowser.prototype.showToolPanel = function(panel, nowrap) {\n    var thisB = this;\n\n    if (this.activeToolPanel) {\n        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);\n    }\n\n    var content;\n    if (nowrap)\n        content = panel;\n    else\n        content = makeElement('div', panel, {}, {overflowY: 'auto', width: '100%'});\n\n\n    var divider = makeElement('div', makeElement('i', null, {className: 'fa fa-caret-right'}), {className: 'tool-divider'});\n    divider.addEventListener('click', function(ev) {\n        thisB.hideToolPanel();\n        thisB.setUiMode('none');\n    }, false);\n    this.makeTooltip(divider, 'Close tool panel (ESC)');\n    this.activeToolPanel = makeElement('div', [divider, content], {className: 'tool-holder'});\n    this.svgHolder.appendChild(this.activeToolPanel);\n    this.resizeViewer();\n\n    var thisB = this;\n}\n\nBrowser.prototype.hideToolPanel = function() {\n    if (this.activeToolPanel) {\n        this.activeToolPanel.parentElement.removeChild(this.activeToolPanel);\n    }\n    this.svgHolder.style.width = '100%';\n    this.activeToolPanel = null;\n    this.resizeViewer();\n}\n\nBrowser.prototype.toggleHelpPopup = function(ev) {\n    if (this.uiMode === 'help') {\n        this.hideToolPanel();\n        this.setUiMode('none');\n    } else {\n        var helpFrame = makeElement('iframe', null, {scrolling: 'yes', seamless: 'seamless', src: this.resolveURL('$$help/index.html'), className: 'help-panel'});\n        this.showToolPanel(helpFrame, false);\n        this.setUiMode('help');\n    }\n}\n\nBrowser.prototype.toggleOptsPopup = function(ev) {\n    var b = this;\n\n    if (this.uiMode === 'opts') {\n        this.hideToolPanel();\n        this.setUiMode('none');\n    } else {\n        var optsForm = makeElement('div', null, {className: 'form-horizontal'}, {boxSizing: 'border-box', MozBoxSizing: 'border-box', display: 'inline-block', verticalAlign: 'top'});\n        var optsTable = makeElement('table');\n        optsTable.cellPadding = 5;\n\n        var scrollModeButton = makeElement('input', '', {type: 'checkbox', checked: b.reverseScrolling});\n        scrollModeButton.addEventListener('change', function(ev) {\n            b.reverseScrolling = scrollModeButton.checked;\n            b.storeStatus();\n        }, false);\n        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse trackpad scrolling', {align: 'right'}), makeElement('td', scrollModeButton)]));\n\n        var scrollKeyButton = makeElement('input', '', {type: 'checkbox', checked: b.reverseKeyScrolling});\n        scrollKeyButton.addEventListener('change', function(ev) {\n            b.reverseKeyScrolling = scrollKeyButton.checked;\n            b.storeStatus();\n        }, false);\n        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Reverse scrolling buttons and keys', {align: 'right'}), makeElement('td', scrollKeyButton)]));\n\n\n        var rulerSelect = makeElement('select');\n        rulerSelect.appendChild(makeElement('option', 'Left', {value: 'left'}));\n        rulerSelect.appendChild(makeElement('option', 'Center', {value: 'center'}));\n        rulerSelect.appendChild(makeElement('option', 'Right', {value: 'right'}));\n        rulerSelect.appendChild(makeElement('option', 'None', {value: 'none'}));\n        rulerSelect.value = b.rulerLocation;\n        rulerSelect.addEventListener('change', function(ev) {\n            b.rulerLocation = rulerSelect.value;\n            b.positionRuler();\n            for (var ti = 0; ti < b.tiers.length; ++ti) {\n                b.tiers[ti].paintQuant();\n            }\n            b.storeStatus();\n        }, false);\n        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Vertical guideline', {align: 'right'}), makeElement('td', rulerSelect)]));\n        \n        var singleBaseHighlightButton = makeElement('input', '', {type: 'checkbox', checked: b.singleBaseHighlight}); \n        singleBaseHighlightButton.addEventListener('change', function(ev) {\n            b.singleBaseHighlight = singleBaseHighlightButton.checked;\n            b.positionRuler();\n            b.storeStatus();\n        }, false);\n        singleBaseHighlightButton.setAttribute('id','singleBaseHightlightButton'); // making this because access is required when the key 'u' is pressed and the options are visible\n        optsTable.appendChild(makeElement('tr', [makeElement('td', 'Display and highlight current genome location', {align: 'right'}), makeElement('td', singleBaseHighlightButton)]));\n        \n        optsForm.appendChild(optsTable);\n\n        var resetButton = makeElement('button', 'Reset browser', {className: 'btn'}, {marginLeft: 'auto', marginRight: 'auto', display: 'block'});\n        resetButton.addEventListener('click', function(ev) {\n            b.reset();\n        }, false);\n        optsForm.appendChild(resetButton);\n\n        this.showToolPanel(optsForm);\n        this.setUiMode('opts');\n    }\n}\n\nfunction humanReadableScale(x) {\n    var suffix = 'bp';\n    if (x > 1000000000) {\n        x /= 1000000000;\n        suffix = 'Gb';\n    } else if (x > 1000000) {\n        x /= 1000000\n        suffix = 'Mb';\n    } else if (x > 1000) {\n        x /= 1000;\n        suffix = 'kb';\n    }\n    return '' + Math.round(x) + suffix;\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// cbrowser.js: canvas browser container\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var Observed = utils.Observed;\n    var Awaited = utils.Awaited;\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n    var miniJSONify = utils.miniJSONify;\n    var shallowCopy = utils.shallowCopy;\n    var textXHR = utils.textXHR;\n\n    var tier = require('./tier');\n    var DasTier = tier.DasTier;\n\n    var sha1 = require('./sha1');\n    var hex_sha1 = sha1.hex_sha1;\n\n    var thub = require('./thub');\n    var connectTrackHub = thub.connectTrackHub;\n\n    var VERSION = require('./version');\n\n    var nf = require('./numformats');\n    var formatQuantLabel = nf.formatQuantLabel;\n    var formatLongInt = nf.formatLongInt;\n\n    var Chainset = require('./chainset').Chainset;\n\n    var Promise = require('es6-promise').Promise;\n\n    var sourcecompare = require('./sourcecompare');\n    var sourcesAreEqual = sourcecompare.sourcesAreEqual;\n    var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;\n    var sourceDataURI = sourcecompare.sourceDataURI;\n    var sourceStyleURI = sourcecompare.sourceStyleURI;\n}\n\nfunction Region(chr, min, max) {\n    this.min = min;\n    this.max = max;\n    this.chr = chr;\n}\n\nfunction Browser(opts) {\n    if (!opts) {\n        opts = {};\n    }\n\n    this.prefix = '//www.biodalliance.org/release-0.14/';\n\n    this.sources = [];\n    this.tiers = [];\n    this.tierGroups = {};\n\n    this.featureListeners = [];\n    this.featureHoverListeners = [];\n    this.viewListeners = [];\n    this.regionSelectListeners = [];\n    this.tierListeners = [];\n    this.tierSelectionListeners = [];\n    this.tierSelectionWrapListeners = [];\n\n    this.cookieKey = 'browser';\n\n    this.chains = {};\n\n    this.pageName = 'svgHolder'\n    this.maxExtra = 2.5;\n    this.minExtra = 0.5;\n    this.zoomFactor = 1.0;\n    this.maxPixelsPerBase = 10;\n    this.origin = 0;\n    this.targetQuantRes = 1.0;\n    this.featurePanelWidth = 750;\n    this.zoomBase = 100;\n    this.zoomExpt = 30.0; // Back to being fixed....\n    this.zoomSliderValue = 100;\n    this.entryPoints = null;\n    this.currentSeqMax = -1; // init once EPs are fetched.\n\n    this.highlights = [];\n    this.selectedTiers = [1];\n\n    this.maxViewWidth = 500000;\n    this.defaultSubtierMax = 100;\n\n    // Options.\n    \n    this.reverseScrolling = false;\n    this.rulerLocation = 'center';\n    this.defaultHighlightFill = 'red';\n    this.defaultHighlightAlpha = 0.3;\n    this.exportHighlights = true;\n    this.exportRuler = true;\n    this.singleBaseHighlight = true;\n    \n    // Visual config.\n\n    // this.tierBackgroundColors = [\"rgb(245,245,245)\", \"rgb(230,230,250)\" /* 'white' */];\n    this.tierBackgroundColors = [\"rgb(245,245,245)\", 'white'];\n    this.minTierHeight = 20;\n    this.noDefaultLabels = false;\n\n    // Registry\n\n    this.availableSources = new Observed();\n    this.defaultSources = [];\n    this.mappableSources = {};\n\n    // Central DAS Registry no longer available 2015-05\n\n    this.registry = null; // '//www.dasregistry.org/das/sources';\n    this.noRegistryTabs = true;\n\n    this.hubs = [];\n    this.hubObjects = [];\n\n    this.sourceCache = new SourceCache();\n    \n    this.retina = true;\n\n    this.useFetchWorkers = true;\n    this.maxWorkers = 2;\n    this.workerPath = '$$worker-all.js';\n    this.resolvers = {};\n    this.resolverSeed = 1;\n\n    this.assemblyNamePrimary = true;\n    this.assemblyNameUcsc = true;\n\n    // HTTP warning support\n\n    this.httpCanaryURL = 'http://www.biodalliance.org/http-canary.txt';\n    this.httpWarningURL = '//www.biodalliance.org/https.html';\n\n    this.initListeners = [];\n\n    if (opts.baseColors) {\n        this.baseColors = opts.baseColors\n    } else {\n        this.baseColors = {\n            A: 'green',\n            C: 'blue',\n            G: 'orange',\n            T: 'red',\n            '-' : 'hotpink', // deletion\n            'I' : 'red' // insertion\n        };\n    }\n\n    if (opts.viewStart !== undefined && typeof(opts.viewStart) !== 'number') {\n        throw Error('viewStart must be an integer');\n    }\n    if (opts.viewEnd !== undefined && typeof(opts.viewEnd) !== 'number') {\n        throw Error('viewEnd must be an integer');\n    }\n    if (opts.offscreenInitWidth !== undefined && typeof(opts.offscreenInitWidth) !== 'number') {\n        throw Error('offscreenInitWidth must be an integer');\n    }\n\n    for (var k in opts) {\n        this[k] = opts[k];\n    }\n    if (typeof(opts.uiPrefix) === 'string' && typeof(opts.prefix) !== 'string') {\n        this.prefix = opts.uiPrefix;\n    }\n    // If the prefix only starts with a single '/' this is relative to the current\n    // site, so we need to prefix the prefix with //{hostname}\n    if (this.prefix.indexOf('//') < 0 && this.prefix.indexOf('/') === 0) {\n        var location = window.location.hostname;\n        if (window.location.port) {\n            location += ':' + window.location.port\n        };\n        this.prefix = '//' + location + this.prefix;\n    }\n    if (this.prefix.indexOf('//') === 0) {\n        var proto = window.location.protocol;\n        if (proto == 'http:' || proto == 'https:') {\n            // Protocol-relative URLs okay.\n        } else {\n            console.log(window.location.protocol);\n            console.log('WARNING: prefix is set to a protocol-relative URL (' + this.prefix + ' when loading from a non-HTTP source');\n            this.prefix = 'http:' + this.prefix;\n        }\n    }\n\n    if (!this.coordSystem) {\n        throw Error('Coordinate system must be configured');\n    }\n\n    if (this.chr === undefined || this.viewStart === undefined || this.viewEnd === undefined) {\n        throw Error('Viewed region (chr:start..end) must be defined');\n    }\n\n    var thisB = this;\n\n    if (document.readyState === 'complete') {\n        thisB.realInit();\n    } else {\n        var loadListener = function(ev) {\n            window.removeEventListener('load', loadListener, false);\n            thisB.realInit();\n        }\n        window.addEventListener('load', loadListener, false);\n    }\n}\n\nBrowser.prototype.resolveURL = function(url) {\n    return url.replace('$$', this.prefix);\n}\n\nBrowser.prototype.destroy = function() {\n    window.removeEventListener('resize', this.resizeListener, false);\n}\n\nBrowser.prototype.realInit = function() {\n    var self = this;\n\n    if (this.wasInitialized) {\n        console.log('Attemping to call realInit on an already-initialized Dalliance instance');\n        return;\n    }\n\n    this.wasInitialized = true;\n\n    var ua = navigator.userAgent || 'dummy';\n    if (ua.indexOf('Trident') >= 0 && ua.indexOf('rv:11') >= 0) {\n        // console.log('Detected IE11, disabling tier pinning.');\n        this.disablePinning = true;\n    }\n\n    this.defaultChr = this.chr;\n    this.defaultStart = this.viewStart;\n    this.defaultEnd = this.viewEnd;\n    this.defaultSources = [];\n    for (var i = 0; i < this.sources.length; ++i) {\n        var s = this.sources[i];\n        if (s)\n            this.defaultSources.push(s);\n    }\n\n    if (this.restoreStatus) {\n        this.statusRestored = this.restoreStatus();\n    }\n\n    var helpPopup;\n    var thisB = this;\n    this.browserHolderHolder = document.getElementById(this.pageName);\n    this.browserHolderHolder.classList.add('dalliance-injection-point');\n    this.browserHolder = makeElement('div', null, {className: 'dalliance dalliance-root', tabIndex: -1});\n    if (this.maxHeight) {\n        this.browserHolder.style.maxHeight = this.maxHeight + 'px';\n    } else if (this.maxHeight != undefined) {\n        this.browserHolder.style.maxHeight = null;\n    }\n    removeChildren(this.browserHolderHolder);\n    this.browserHolderHolder.appendChild(this.browserHolder);\n    this.svgHolder = makeElement('div', null, {className: 'main-holder'});\n\n    this.initUI(this.browserHolder, this.svgHolder);\n\n    this.pinnedTierHolder = makeElement('div', null, {className: 'tier-holder tier-holder-pinned'});\n    this.tierHolder = makeElement('div', this.makeLoader(24), {className: 'tier-holder tier-holder-rest'});\n\n    this.locSingleBase = makeElement('span', '', {className: 'loc-single-base'});\n    var locSingleBaseHolder = makeElement('div', this.locSingleBase,{className: 'loc-single-base-holder'}); \n    // Add listener to update single base location\n    this.addViewListener(function(chr, minFloor, maxFloor, zoomSliderValue, zoomSliderDict, min, max) {\n        // Just setting textContent causes layout flickering in Blink.\n        // This approach means that the element is never empty.\n        var loc = Math.round((max + min) / 2);\n        self.locSingleBase.appendChild(document.createTextNode(chr + ':' + formatLongInt(loc)));\n        self.locSingleBase.removeChild(self.locSingleBase.firstChild);\n    });\n\n    if (this.disablePinning) {\n        this.tierHolderHolder = this.tierHolder;\n    } else {\n        this.tierHolderHolder = makeElement('div', [locSingleBaseHolder, this.pinnedTierHolder, this.tierHolder], {className: 'tier-holder-holder'});\n        this.svgHolder.appendChild(this.tierHolderHolder);\n    }\n    this.svgHolder.appendChild(this.tierHolderHolder);\n\n    this.bhtmlRoot = makeElement('div');\n    if (!this.disablePoweredBy) {\n        this.bhtmlRoot.appendChild(makeElement('span', ['Powered by ', makeElement('a', 'Biodalliance', {href: 'http://www.biodalliance.org/'}), ' ' + VERSION], {className: 'powered-by'}));\n    }\n    this.browserHolder.appendChild(this.bhtmlRoot);\n    \n    this.resizeListener = function(ev) {\n        thisB.resizeViewer();\n    };\n    window.addEventListener('resize', this.resizeListener, false);\n    this.ruler = makeElement('div', null, {className: 'guideline'})\n    this.ruler2 = makeElement('div', null, {className: 'single-base-guideline'});\n    this.tierHolderHolder.appendChild(this.ruler);\n    this.tierHolderHolder.appendChild(this.ruler2);\n    this.chainConfigs = this.chains || {};\n    this.chains = {};\n    for (var k in this.chainConfigs) {\n        var cc = this.chainConfigs[k];\n        if (cc instanceof Chainset) {\n            console.log('WARNING: Should no longer use \"new Chainset\" in Biodalliance configurations.');\n        }\n        this.chains[k] = new Chainset(cc);\n    }\n\n    var promisedWorkers;\n    if (this.maxWorkers > 0) {\n        var pw = [];\n        for (var fi = 0; fi < this.maxWorkers; ++fi)\n            pw.push(makeFetchWorker(this));\n        promisedWorkers = Promise.all(pw);\n    } else {\n        promisedWorkers = Promise.resolve([]);\n    }\n\n    this.fetchWorkers = null;\n    this.nextWorker = 0;\n    promisedWorkers.then(function(v) {\n        console.log('Booted ' + v.length + ' workers');\n        thisB.fetchWorkers = v; \n    }, function(v) {\n        console.log('Failed to boot workers', v);\n    }).then(function() {\n        if (self.offscreenInitWidth || (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&\n            thisB.tierHolder.getBoundingClientRect().width > 0))\n        {\n            setTimeout(function() {thisB.realInit2()}, 1);\n        } else {\n            var pollInterval = setInterval(function() {\n                if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&\n                    thisB.tierHolder.getBoundingClientRect().width > 0)\n                {\n                    clearInterval(pollInterval);\n                    thisB.realInit2();\n                } \n            }, 300);\n        }\n    });\n}\n\nBrowser.prototype.realInit2 = function() {\n    var thisB = this;\n\n    // Remove the loader icon, if needed\n    removeChildren(this.tierHolder);\n    removeChildren(this.pinnedTierHolder);\n\n    this.featurePanelWidth = this.tierHolder.getBoundingClientRect().width | thisB.offscreenInitWidth | 0;\n    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart);\n    if (!this.zoomMax) {\n        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);\n        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);\n    }\n    this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);\n\n    // Event handlers\n\n    this.tierHolderHolder.addEventListener('mousewheel', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n\n        if (ev.wheelDeltaX) {\n            var delta = ev.wheelDeltaX/5;\n            if (!thisB.reverseScrolling) {\n                delta = -delta;\n            }\n            thisB.move(delta);\n        }\n\n        if (ev.wheelDeltaY) {\n            var delta = ev.wheelDeltaY;\n            if (thisB.reverseScrolling) {\n                delta = -delta;\n            }\n            thisB.tierHolder.scrollTop += delta;\n        }\n    }, false); \n\n    this.tierHolderHolder.addEventListener('MozMousePixelScroll', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        if (ev.axis == 1) {\n            if (ev.detail != 0) {\n                var delta = ev.detail/4;\n                if (thisB.reverseScrolling) {\n                    delta = -delta;\n                }\n                thisB.move(delta);\n            }\n        } else {\n            var delta = ev.detail;\n            if (!thisB.reverseScrolling) {\n              delta = -delta;\n            }\n\n            thisB.tierHolder.scrollTop += delta;\n        }\n    }, false); \n\n    this.tierHolderHolder.addEventListener('touchstart', function(ev) {return thisB.touchStartHandler(ev)}, false);\n    this.tierHolderHolder.addEventListener('touchmove', function(ev) {return thisB.touchMoveHandler(ev)}, false);\n    this.tierHolderHolder.addEventListener('touchend', function(ev) {return thisB.touchEndHandler(ev)}, false);\n    this.tierHolderHolder.addEventListener('touchcancel', function(ev) {return thisB.touchCancelHandler(ev)}, false);\n\n    var keyHandler = function(ev) {\n        // console.log('cbkh: ' + ev.keyCode);\n        if (ev.keyCode == 13) { // enter\n            var layoutsChanged = false;\n            for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                var t = thisB.tiers[ti];\n                if (t.wantedLayoutHeight && t.wantedLayoutHeight != t.layoutHeight) {\n                    t.layoutHeight = t.wantedLayoutHeight;\n                    t.clipTier();\n                    layoutsChanged = true;\n                }\n            }\n            if (layoutsChanged) {\n                thisB.arrangeTiers();\n            }\n        } else if (ev.keyCode == 32 || ev.charCode == 32) { // space\n            if (!thisB.isSnapZooming) {\n                thisB.isSnapZooming = true;\n                var newZoom = (thisB.savedZoom || 0.0) + thisB.zoomMin;\n                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;\n                thisB.zoomSliderValue = newZoom;\n                thisB.zoom(Math.exp((1.0 * newZoom) / thisB.zoomExpt));\n            } else {\n                thisB.isSnapZooming = false;\n                var newZoom = (thisB.savedZoom || 20.0) + thisB.zoomMin;\n                thisB.savedZoom = thisB.zoomSliderValue - thisB.zoomMin;\n                thisB.zoomSliderValue = newZoom;\n                thisB.zoom(Math.exp((1.0 * newZoom) / thisB.zoomExpt));\n            }\n            ev.stopPropagation(); ev.preventDefault();      \n        } else if (ev.keyCode == 85) { // u\n            if (thisB.uiMode === 'opts') { // if the options are visible, toggle the checkbox too\n                var check = document.getElementById(\"singleBaseHightlightButton\").checked;\n                document.getElementById(\"singleBaseHightlightButton\").checked = !check;\n            } \n            thisB.singleBaseHighlight = !thisB.singleBaseHighlight;\n            thisB.positionRuler();\n            ev.stopPropagation(); ev.preventDefault();\n        } else if (ev.keyCode == 39) { // right arrow\n            ev.stopPropagation(); ev.preventDefault();\n            thisB.scrollArrowKey(ev, -1);\n        } else if (ev.keyCode == 37) { // left arrow\n            ev.stopPropagation(); ev.preventDefault();\n            thisB.scrollArrowKey(ev, 1);\n        } else if (ev.keyCode == 38 || ev.keyCode == 87) { // up arrow | w\n            ev.stopPropagation(); ev.preventDefault();\n\n            if (ev.shiftKey) {\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                var tt = thisB.tiers[st];\n                var ch = tt.forceHeight || tt.subtiers[0].height;\n                if (ch >= 40) {\n                    tt.mergeConfig({height: ch-10});\n                }\n            } else if (ev.ctrlKey || ev.metaKey) {\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                var tt = thisB.tiers[st];\n  \n                if (tt.quantLeapThreshold) {\n                    var th = tt.subtiers[0].height;\n                    var tq = tt.subtiers[0].quant;\n                    if (!tq)\n                        return;\n\n                    var qmin = 1.0 * tq.min;\n                    var qmax = 1.0 * tq.max;\n\n                    var qscale = (qmax - qmin) / th;\n                    tt.mergeConfig({quantLeapThreshold: qmin + ((Math.round((tt.quantLeapThreshold - qmin)/qscale)|0)+1)*qscale});\n\n                    tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));\n                }                \n            } else if (ev.altKey) {\n                var cnt = thisB.selectedTiers.length;\n                if (cnt == 0)\n                    return;\n\n                var st = thisB.selectedTiers[0];\n                var contiguous = true;\n                var mt = [];\n                for (var si = 0; si < thisB.selectedTiers.length; ++si) {\n                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);\n                    if (si > 0 && thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] != 1)\n                        contiguous = false;\n                }\n\n                if (contiguous && st <= 0)\n                    return;\n\n                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si)\n                    thisB.tiers.splice(thisB.selectedTiers[si], 1);\n\n                thisB.selectedTiers.splice(0, cnt);\n\n                var ip = contiguous ? st - 1 : st;\n                for (var si = 0; si < mt.length; ++si) {\n                    thisB.tiers.splice(ip+si, 0, mt[si]);\n                    thisB.selectedTiers.push(ip + si);\n                }\n\n                thisB.withPreservedSelection(thisB._ensureTiersGrouped);\n                thisB.markSelectedTiers();\n                thisB.notifyTierSelection();\n                thisB.reorderTiers();\n                thisB.notifyTier(\"selected\", st);\n            } else {\n                var st = thisB.getSelectedTier();\n                if (st > 0) {\n                    thisB.setSelectedTier(st - 1);\n                    var nst = thisB.tiers[thisB.getSelectedTier()];\n                    var top = nst.row.offsetTop, bottom = top + nst.row.offsetHeight;\n                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {\n                        thisB.tierHolder.scrollTop = top;\n                    }\n                } else {\n                    thisB.notifyTierSelectionWrap(-1);\n                }\n            }\n        } else if (ev.keyCode == 40 || ev.keyCode == 83) { // down arrow | s\n            ev.stopPropagation(); ev.preventDefault();\n\n            if (ev.shiftKey) {\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                var tt = thisB.tiers[st];\n                var ch = tt.forceHeight || tt.subtiers[0].height;\n                tt.mergeConfig({height: ch+10});\n            } else if (ev.ctrlKey || ev.metaKey) {\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                var tt = thisB.tiers[st];\n\n                if (tt.quantLeapThreshold) {\n                    var th = tt.subtiers[0].height;\n                    var tq = tt.subtiers[0].quant;\n                    if (!tq)\n                        return;\n\n                    var qmin = 1.0 * tq.min;\n                    var qmax = 1.0 * tq.max;\n                    var qscale = (qmax - qmin) / th;\n\n                    var it = Math.round((tt.quantLeapThreshold - qmin)/qscale)|0;\n                    if (it > 1) {\n                        tt.mergeConfig({quantLeapThreshold: qmin + (it-1)*qscale});\n                        tt.notify('Threshold: ' + formatQuantLabel(tt.quantLeapThreshold));\n                    }\n                }\n            } else if (ev.altKey) {\n                var cnt = thisB.selectedTiers.length;\n                if (cnt == 0)\n                    return;\n\n                var st = thisB.selectedTiers[0];\n                var discontig = 0;\n                var mt = [];\n                for (var si = 0; si < thisB.selectedTiers.length; ++si) {\n                    mt.push(thisB.tiers[thisB.selectedTiers[si]]);\n                    if (si > 0)\n                        discontig += (thisB.selectedTiers[si] - thisB.selectedTiers[si - 1] - 1);\n                }\n                var contiguous = discontig == 0;\n\n                if (contiguous && st + cnt >= thisB.tiers.length)\n                    return;\n\n                for (var si = thisB.selectedTiers.length - 1; si >= 0; --si)\n                    thisB.tiers.splice(thisB.selectedTiers[si], 1);\n\n                thisB.selectedTiers.splice(0, cnt);\n\n                var ip = contiguous ? st + 1 : st + discontig;\n                for (var si = 0; si < mt.length; ++si) {\n                    thisB.tiers.splice(ip+si, 0, mt[si]);\n                    thisB.selectedTiers.push(ip + si);\n                }\n\n                thisB.withPreservedSelection(function() {\n                    thisB._ensureTiersGrouped(true);\n                });\n                thisB.markSelectedTiers();\n                thisB.notifyTierSelection();\n                thisB.reorderTiers();\n                thisB.notifyTier(\"selected\", st);\n            } else {\n                var st = thisB.getSelectedTier();\n                if (st < thisB.tiers.length -1) {\n                    thisB.setSelectedTier(st + 1);\n                    var nst = thisB.tiers[thisB.getSelectedTier()];\n                    var top = nst.row.offsetTop, bottom = top + nst.row.offsetHeight;\n                    if (top < thisB.tierHolder.scrollTop || bottom > thisB.tierHolder.scrollTop + thisB.tierHolder.offsetHeight) {\n                        thisB.tierHolder.scrollTop = Math.min(top, bottom - thisB.tierHolder.offsetHeight);\n                    }\n                }\n            }\n        } else if (ev.keyCode == 187 || ev.keyCode == 61) { // +\n            ev.stopPropagation(); ev.preventDefault();\n            thisB.zoomStep(-10);\n        } else if (ev.keyCode == 189 || ev.keyCode == 173) { // -\n            ev.stopPropagation(); ev.preventDefault();\n            thisB.zoomStep(10);\n        } else if (ev.keyCode == 73 || ev.keyCode == 105) { // i\n            ev.stopPropagation(); ev.preventDefault();\n            var st = thisB.getSelectedTier();\n            if (st < 0) return;\n            var t = thisB.tiers[st];\n            if (!t.infoVisible) {\n                t.infoElement.style.display = 'block';\n                t.updateHeight();\n                t.infoVisible = true;\n            } else {\n                t.infoElement.style.display = 'none';\n                t.updateHeight();\n                t.infoVisible = false;\n            }\n        } else if (ev.keyCode == 84 || ev.keyCode == 116) { // t\n            var bumpStatus;\n            if( ev.shiftKey ){\n                ev.stopPropagation(); ev.preventDefault();\n                for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                    var t = thisB.tiers[ti];\n                    if (t.dasSource.collapseSuperGroups) {\n                        if (bumpStatus === undefined) {\n                            bumpStatus = !t.bumped;\n                        }\n                        t.mergeConfig({bumped: bumpStatus});\n                    }\n                }\n            } else if (!ev.ctrlKey && !ev.metaKey) {\n                ev.stopPropagation(); ev.preventDefault();\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                var t = thisB.tiers[st];\n\n                if (t.dasSource.collapseSuperGroups) {\n                    if (bumpStatus === undefined) {\n                        bumpStatus = !t.bumped;\n                    }\n                    t.mergeConfig({bumped: bumpStatus});\n                }\n            }\n        } else if (ev.keyCode == 77 || ev.keyCode == 109) { // m\n            ev.stopPropagation(); ev.preventDefault();\n            if ((ev.ctrlKey || ev.metaKey) && thisB.selectedTiers.length > 1) {\n                thisB.mergeSelectedTiers();\n            }\n        } else if (ev.keyCode == 68 || ev.keyCode == 100) { // d\n            ev.stopPropagation(); ev.preventDefault();\n            if (ev.ctrlKey || ev.metaKey) {\n                var st = thisB.getSelectedTier();\n                if (st < 0) return;\n                thisB.addTier(thisB.tiers[st].dasSource);\n            }\n        } else if (ev.keyCode == 80 || ev.keyCode == 112) { // p\n            if (ev.ctrlKey || ev.metaKey) {\n                // Need to be careful because order of tiers could change\n                // once we start updating pinning.\n                var tt = [];\n                for (var st = 0; st < thisB.selectedTiers.length; ++st) {\n                    tt.push(thisB.tiers[thisB.selectedTiers[st]]);\n                }\n                for (var ti = 0; ti < tt.length; ++ti) {\n                    tt[ti].mergeConfig({pinned: !tt[ti].pinned});\n                }\n            }\n        } else {\n            // console.log('key: ' + ev.keyCode + '; char: ' + ev.charCode);\n        }\n    };\n\n    this.browserHolder.addEventListener('focus', function(ev) {\n        thisB.browserHolder.addEventListener('keydown', keyHandler, false);\n    }, false);\n    this.browserHolder.addEventListener('blur', function(ev) {\n        thisB.browserHolder.removeEventListener('keydown', keyHandler, false);\n    }, false);\n\n    // Popup support (does this really belong here? FIXME)\n    this.hPopupHolder = makeElement('div');\n    this.hPopupHolder.style['font-family'] = 'helvetica';\n    this.hPopupHolder.style['font-size'] = '12pt';\n    this.hPopupHolder.classList.add('dalliance');\n    document.body.appendChild(this.hPopupHolder);\n\n    for (var t = 0; t < this.sources.length; ++t) {\n        var source = this.sources[t];\n        if (!source)\n            continue;\n        \n        var config = {};\n        if (this.restoredConfigs) {\n            config = this.restoredConfigs[t];\n        }\n\n        if (!source.disabled) {\n            this.makeTier(source, config).then(function(tier) {\n                thisB.refreshTier(tier);\n            });\n        }\n    }\n\n    thisB._ensureTiersGrouped();\n    thisB.arrangeTiers();\n    thisB.reorderTiers();\n\n\n    var ss = this.getSequenceSource();\n    if (ss) {\n        ss.getSeqInfo(this.chr, function(si) {\n            if (si)\n                thisB.currentSeqMax = si.length;\n            else\n                thisB.currentSeqMax = -1;\n        });\n    }\n\n    this.queryRegistry();\n    for (var m in this.chains) {\n        this.queryRegistry(m, true);\n    }\n\n    if (this.hubs) {\n        for (var hi = 0; hi < this.hubs.length; ++hi) {\n            var hc = this.hubs[hi];\n            if (typeof hc == 'string') {\n                hc = {url: hc};\n            };\n\n            (function(hc) {\n                connectTrackHub(hc.url, function(hub, err) {\n                    if (err) {\n                        console.log(err);\n                    } else {\n                        var tdb;\n                        if (hc.genome)\n                            tdb = hub.genomes[hc.genome];\n                        else \n                            tdb = hub.genomes[thisB.coordSystem.ucscName];\n\n                        if (tdb) {\n                            if (hc.mapping) \n                                tdb.mapping = hc.mapping;\n                            if (hc.label)\n                                tdb.hub.altLabel = hc.label\n                            thisB.hubObjects.push(tdb);\n                        }\n                    }\n                }, hc);\n            })(hc);\n        }\n    }\n\n    if (this.fullScreen) {\n        this.setFullScreenHeight();\n    }\n\n    if (!this.statusRestored && this.storeStatus) {\n        this.storeStatus();\n    }\n\n    thisB.setLocation(this.chr, this.viewStart, this.viewEnd, function () {\n        thisB.setSelectedTier(1);\n        // Ping any init listeners.\n        for (var ii = 0; ii < thisB.initListeners.length; ++ii) {\n            try {\n                thisB.initListeners[ii].call(thisB);\n            } catch (e) {\n                console.log(e);\n            }\n        }\n    });\n}\n\n// \n// Touch event support\n//\n\nBrowser.prototype.touchStartHandler = function(ev) {\n    // Events not consumed so they can be interpretted as clicks as well.\n\n    this.touchOriginX = ev.touches[0].pageX;\n    this.touchOriginY = ev.touches[0].pageY;\n    if (ev.touches.length == 2) {\n        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);\n        this.zooming = true;\n        this.zoomLastSep = this.zoomInitialSep = sep;\n        this.zoomInitialScale = this.scale;\n    }\n}\n\nBrowser.prototype.touchMoveHandler = function(ev) {\n    // These events *are* consumed to ensure we never get any dragging that\n    // we don't manage ourselves.\n\n    ev.stopPropagation(); ev.preventDefault();\n    \n    if (ev.touches.length == 1) {\n        var touchX = ev.touches[0].pageX;\n        var touchY = ev.touches[0].pageY;\n        if (this.touchOriginX && touchX != this.touchOriginX) {\n            this.move(touchX - this.touchOriginX);\n        }\n        if (this.touchOriginY && touchY != this.touchOriginY) {\n            this.tierHolder.scrollTop -= (touchY - this.touchOriginY);\n        }\n        this.touchOriginX = touchX;\n        this.touchOriginY = touchY;\n    } else if (this.zooming && ev.touches.length == 2) {\n        var sep = Math.abs(ev.touches[0].pageX - ev.touches[1].pageX);\n        if (sep != this.zoomLastSep) {\n            var cp = (ev.touches[0].pageX + ev.touches[1].pageX)/2;\n            var scp = this.viewStart + (cp/this.scale)|0\n            this.scale = this.zoomInitialScale * (sep/this.zoomInitialSep);\n            this.viewStart = scp - (cp/this.scale)|0;\n            for (var i = 0; i < this.tiers.length; ++i) {\n                this.tiers[i].draw();\n            }\n        }\n        this.zoomLastSep = sep;\n    }\n}\n\nBrowser.prototype.touchEndHandler = function(ev) {\n}\n\nBrowser.prototype.touchCancelHandler = function(ev) {\n}\n\n\nBrowser.prototype.makeTier = function(source, config) {\n    try {\n        return this.realMakeTier(source, config);\n    } catch (e) {\n        console.log('Error initializing', source);\n        console.log(e.stack || e);\n    }\n}\n\nBrowser.prototype.realMakeTier = function(source, config) {\n    var thisB = this;\n    var background = null;\n    if (this.tierBackgroundColors) {\n        background = this.tierBackgroundColors[this.tiers.length % this.tierBackgroundColors.length];\n    }\n\n    var tier = new DasTier(this, source, config, background);\n    tier.oorigin = this.viewStart\n\n    var isDragging = false;\n    var dragOrigin, dragMoveOrigin;\n    var hoverTimeout;\n\n    var featureLookup = function(rx, ry) {\n        var st = tier.subtiers;\n        if (!st) {\n            return;\n        }\n\n        var sti = 0;\n        ry -= tier.padding;;\n        while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {\n            ry = ry - st[sti].height - tier.padding;\n            ++sti;\n        }\n        if (sti >= st.length) {\n            return;\n        }\n\n        var glyphs = st[sti].glyphs;\n        var viewCenter = (thisB.viewStart + thisB.viewEnd)/2;\n        var offset = (tier.glyphCacheOrigin - thisB.viewStart)*thisB.scale;\n        rx -= offset;\n       \n        return glyphLookup(glyphs, rx, ry);\n    }\n\n    var dragMoveHandler = function(ev) {\n        ev.preventDefault(); ev.stopPropagation();\n        var rx = ev.clientX;\n        if (rx != dragMoveOrigin) {\n            thisB.move((rx - dragMoveOrigin), true);\n            dragMoveOrigin = rx;\n        }\n        thisB.isDragging = true;\n    }\n\n    var dragUpHandler = function(ev) {\n        window.removeEventListener('mousemove', dragMoveHandler, true);\n        window.removeEventListener('mouseup', dragUpHandler, true);\n        thisB.move((ev.clientX - dragMoveOrigin)); // Snap back (FIXME: consider animation)\n    }\n        \n\n    tier.viewport.addEventListener('mousedown', function(ev) {\n        thisB.browserHolder.focus();\n        ev.preventDefault();\n        var br = tier.row.getBoundingClientRect();\n        var rx = ev.clientX, ry = ev.clientY;\n\n        window.addEventListener('mousemove', dragMoveHandler, true);\n        window.addEventListener('mouseup', dragUpHandler, true);\n        dragOrigin = dragMoveOrigin = rx;\n        thisB.isDragging = false; // Not dragging until a movement event arrives.\n    }, false);\n\n    tier.viewport.addEventListener('mousemove', function(ev) {\n        var br = tier.row.getBoundingClientRect();\n        var rx = ev.clientX - br.left, ry = ev.clientY - br.top;\n\n        var hit = featureLookup(rx, ry);\n        if (hit && hit.length > 0) {\n            tier.row.style.cursor = 'pointer';\n        } else {\n            tier.row.style.cursor = 'default';\n        }\n\n        if (hoverTimeout) {\n            clearTimeout(hoverTimeout);\n        }\n\n        if (isDragging) {\n            // if (tier.dasSource.tier_type !== 'sequence' && rx != dragMoveOrigin) {\n            //    thisB.move((rx - dragMoveOrigin));\n            //    dragMoveOrigin = rx;\n            // }\n        } else {\n            hoverTimeout = setTimeout(function() {\n                var hit = featureLookup(rx, ry);\n                if (hit && hit.length > 0) {\n                    thisB.notifyFeatureHover(ev, hit[hit.length - 1], hit, tier);\n                }\n            }, 1000);\n        }\n    });\n\n    var doubleClickTimeout = null;\n    tier.viewport.addEventListener('mouseup', function(ev) {\n        var br = tier.row.getBoundingClientRect();\n        var rx = ev.clientX - br.left, ry = ev.clientY - br.top;\n\n        var hit = featureLookup(rx, ry);\n        if (hit && hit.length > 0 && !thisB.isDragging) {\n            if (doubleClickTimeout) {\n                clearTimeout(doubleClickTimeout);\n                doubleClickTimeout = null;\n                thisB.featureDoubleClick(hit, rx, ry);\n            } else {\n                doubleClickTimeout = setTimeout(function() {\n                    doubleClickTimeout = null;\n                    thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);\n                }, 500);\n            }\n        }\n\n        if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {\n            var a = thisB.viewStart + (rx/thisB.scale);\n            var b = thisB.viewStart + (dragOrigin/thisB.scale);\n\n            var min, max;\n            if (a < b) {\n                min = a|0; max = b|0;\n            } else {\n                min = b|0; max = a|0;\n            }\n\n            thisB.notifyRegionSelect(thisB.chr, min, max);\n        }\n        thisB.isDragging = false;\n    }, false);\n\n    tier.viewport.addEventListener('mouseout', function(ev) {\n        isDragging = false;\n    });\n\n    tier.removeButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n            if (thisB.tiers[ti] === tier) {\n                thisB.removeTier({index: ti});\n                break;\n            }\n        }\n    }, false);\n    tier.nameButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n\n        if (ev.shiftKey) {\n            var hitTier = -1;\n            for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                if (thisB.tiers[ti] === tier) {\n                    hitTier = ti;\n                    break;\n                }\n            }\n            if (hitTier >= 0) {\n                var i = thisB.selectedTiers.indexOf(hitTier);\n                if (i >= 0) {\n                    thisB.selectedTiers.splice(i, 1);\n                } else {\n                    thisB.selectedTiers.push(hitTier);\n                    thisB.selectedTiers.sort();\n                }\n                thisB.markSelectedTiers();\n                thisB.notifyTierSelection();\n\n                if (thisB.selectedTiers.length > 0) {\n                    thisB.browserHolder.focus();\n                } else {\n                    thisB.notifyTierSelectionWrap(-1);\n                }\n            }\n        } else {\n            for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                if (thisB.tiers[ti] === tier) {\n                    thisB.browserHolder.focus();\n                    if (thisB.selectedTiers.length != 1 || thisB.selectedTiers[0] != ti) {\n                        thisB.setSelectedTier(ti);\n                        return;\n                    }\n                }\n            }\n\n            if (!tier.infoVisible) {\n                tier.infoElement.style.display = 'block';\n                tier.updateHeight();\n                tier.infoVisible = true;\n            } else {\n                tier.infoElement.style.display = 'none';\n                tier.updateHeight();\n                tier.infoVisible = false;\n            }\n        }\n    }, false);\n    tier.bumpButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        var bumpStatus;\n        var t = tier;\n        if (t.dasSource.collapseSuperGroups) {\n            if (bumpStatus === undefined) {\n                bumpStatus = !t.bumped;\n            }\n            t.mergeConfig({bumped: bumpStatus});\n        }\n    }, false);\n\n    \n    var dragLabel;\n    var dragTierHolder;\n    var dragTierHolderScrollLimit;\n    var tierOrdinal;\n    var yAtLastReorder;\n    var tiersWereReordered = false;\n\n    var labelDragHandler = function(ev) {\n        var label = tier.label;\n\n        ev.stopPropagation(); ev.preventDefault();\n        if (!dragLabel) {\n            if (tier.pinned) {\n                dragTierHolder = thisB.pinnedTierHolder;\n            } else {\n                dragTierHolder = thisB.tierHolder;\n            }\n            dragTierHolderScrollLimit = dragTierHolder.scrollHeight - dragTierHolder.offsetHeight;\n\n            dragLabel = label.cloneNode(true);\n            dragLabel.style.cursor = 'pointer';\n            dragTierHolder.appendChild(dragLabel);\n            label.style.visibility = 'hidden';\n\n            for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                if (thisB.tiers[ti] === tier) {\n                    tierOrdinal = ti;\n                    break;\n                }\n            }\n\n            yAtLastReorder = ev.clientY;\n        }\n        \n        var holderBCR = dragTierHolder.getBoundingClientRect();\n        dragLabel.style.left = (label.getBoundingClientRect().left - holderBCR.left) + 'px'; \n        dragLabel.style.top = (ev.clientY - holderBCR.top + dragTierHolder.scrollTop - 10) + 'px';\n\n        var pty = ev.clientY - holderBCR.top + dragTierHolder.scrollTop;\n        for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n            var tt = thisB.tiers[ti];\n            if (tt.pinned ^ tier.pinned)\n                continue; \n\n            var ttr = tt.row.getBoundingClientRect();\n            pty -= (ttr.bottom - ttr.top);\n            if (pty < 0) {\n                if (ti < tierOrdinal && ev.clientY < yAtLastReorder || ti > tierOrdinal && ev.clientY > yAtLastReorder) {\n                    thisB.withPreservedSelection(function() {\n                        thisB.tiers.splice(tierOrdinal, 1);\n                        thisB.tiers.splice(ti, 0, tier);\n                        thisB._ensureTiersGrouped(ti > tierOrdinal);\n                    });\n\n                    for (var tix = 0; tix < thisB.tiers.length; ++tix)\n                        if (thisB.tiers[tix] == tier)\n                            tierOrdinal = tix;\n\n                    yAtLastReorder = ev.clientY;\n                    thisB.reorderTiers();\n                    dragTierHolder.appendChild(dragLabel); // Because reorderTiers removes all children.\n                    tiersWereReordered = true;\n                }\n                break;\n            }\n        }\n\n        if (dragLabel.offsetTop < dragTierHolder.scrollTop) {\n            dragTierHolder.scrollTop -= (dragTierHolder.scrollTop - dragLabel.offsetTop);\n        } else if ((dragLabel.offsetTop + dragLabel.offsetHeight) > (dragTierHolder.scrollTop + dragTierHolder.offsetHeight)) {\n            dragTierHolder.scrollTop = Math.min(dragTierHolder.scrollTop + \n                                                   (dragLabel.offsetTop + dragLabel.offsetHeight) - \n                                                   (dragTierHolder.scrollTop + dragTierHolder.offsetHeight),\n                                                dragTierHolderScrollLimit);\n        }\n    };\n\n    var labelReleaseHandler = function(ev) {\n        var label = tier.label;\n\n        ev.stopPropagation(); ev.preventDefault();\n        if (dragLabel) {\n            dragLabel.style.cursor = 'auto';\n            dragTierHolder.removeChild(dragLabel);\n            dragLabel = null;\n            label.style.visibility = 'visible';\n        }\n        document.removeEventListener('mousemove', labelDragHandler, false);\n        document.removeEventListener('mouseup', labelReleaseHandler, false);\n\n        if (tiersWereReordered) {\n            for (var ti = 0; ti < thisB.tiers.length; ++ti) {\n                if (thisB.tiers[ti] == tier) {\n                    thisB.setSelectedTier(ti);\n                    break;\n                }\n            }\n            thisB.notifyTier(\"reordered\", tier);\n        }\n    };\n\n    tier.label.addEventListener('mousedown', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        tiersWereReordered = false;\n        document.addEventListener('mousemove', labelDragHandler, false);\n        document.addEventListener('mouseup', labelReleaseHandler, false);\n    }, false);\n\n    this.tiers.push(tier);  // NB this currently tells any extant knownSpace about the new tier.\n    \n // fetches stylesheet\n    return tier.init().then(function (updatedTier) {\n        updatedTier.currentlyHeight = 50;\n        thisB.updateHeight();\n        updatedTier.updateLabel();\n\n        thisB.withPreservedSelection(thisB._ensureTiersGrouped);\n        updatedTier._updateFromConfig();\n        thisB.reorderTiers();\n\n        return updatedTier;\n    });\n}\n\nBrowser.prototype.reorderTiers = function() {\n    removeChildren(this.tierHolder);\n    removeChildren(this.pinnedTierHolder);\n    if (this.disablePinning) {\n        this.tierHolder.appendChild(this.ruler);\n        this.tierHolder.appendChild(this.ruler2);\n    }\n    var hasPinned = false;\n    var pinnedTiers = [], unpinnedTiers = [];\n    for (var i = 0; i < this.tiers.length; ++i) {\n        var t = this.tiers[i];\n        if (t.pinned && !this.disablePinning) {\n            pinnedTiers.push(t);\n            this.pinnedTierHolder.appendChild(this.tiers[i].row);\n            hasPinned = true;\n        } else {\n            unpinnedTiers.push(t);\n            this.tierHolder.appendChild(this.tiers[i].row);\n        }\n    }\n\n    this.withPreservedSelection(function() {\n        this.tiers.splice(0, this.tiers.length);\n        for (var i = 0; i < pinnedTiers.length; ++i)\n            this.tiers.push(pinnedTiers[i]);\n        for (var i = 0; i < unpinnedTiers.length; ++i)\n            this.tiers.push(unpinnedTiers[i]);\n    });\n\n    if (hasPinned)\n        this.pinnedTierHolder.classList.add('tier-holder-pinned-full');\n    else\n        this.pinnedTierHolder.classList.remove('tier-holder-pinned-full');\n\n    this.arrangeTiers();\n}\n\nBrowser.prototype.withPreservedSelection = function(f) {\n    var st = [];\n    for (var xi = 0; xi < this.selectedTiers.length; ++xi) {\n        st.push(this.tiers[this.selectedTiers[xi]]);\n    }\n\n    f.call(this);\n\n    this.selectedTiers = [];\n    for (var sti = 0; sti < this.tiers.length; ++sti) {\n        if (st.indexOf(this.tiers[sti]) >= 0)\n            this.selectedTiers.push(sti);\n    }\n}\n\nBrowser.prototype.refreshTier = function(tier, tierCallback) {\n    tierCallback = tierCallback || defaultTierRenderer;\n    if (this.knownSpace) {\n        this.knownSpace.invalidate(tier, tierCallback);\n    }\n}\n\n/* Internal use only, assumes selection is being managed elsewhere... */\n\nBrowser.prototype._ensureTiersGrouped = function(down) {\n    var groupedTiers = {};\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var t = this.tiers[ti];\n        if (t.dasSource.tierGroup) {\n            pusho(groupedTiers, t.dasSource.tierGroup, t);\n        }   \n    }\n\n    var newTiers = [];\n    if (down)\n        this.tiers.reverse();\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var t = this.tiers[ti];\n        if (t.dasSource.tierGroup) {\n            var nt = groupedTiers[t.dasSource.tierGroup];\n            if (nt) {\n                if (down)\n                    nt.reverse();\n                for (var nti = 0; nti < nt.length; ++nti)\n                    newTiers.push(nt[nti]);\n                groupedTiers[t.dasSource.tierGroup] = null;\n            }\n        } else {\n            newTiers.push(t);\n        }\n    }\n    if (down)\n        newTiers.reverse();\n    this.tiers.splice(0, this.tiers.length);\n    for (var nti = 0; nti < newTiers.length; ++nti)\n        this.tiers.push(newTiers[nti]);\n}\n\nBrowser.prototype.arrangeTiers = function() {\n    var arrangedTiers = [];\n    var groupedTiers = {};\n\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var t = this.tiers[ti];\n        if (t.pinned) {\n            arrangedTiers.push(t);\n            if (t.dasSource.tierGroup) {\n                pusho(groupedTiers, t.dasSource.tierGroup, t);\n            }\n        }\n        \n    }\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var t = this.tiers[ti];\n        if (!t.pinned) {\n            arrangedTiers.push(t);\n            if (t.dasSource.tierGroup) {\n                pusho(groupedTiers, t.dasSource.tierGroup, t);\n            }\n        }\n    }\n\n    for (var g in groupedTiers) {\n        var tiers = groupedTiers[g];\n        var tierGroup = this.tierGroups[g];\n        if (!tierGroup) {\n            tierGroup = {\n                element: makeElement(\n                    'div',\n                    makeElement('span', g, {className: 'tier-group-label'}),\n                    {className: \"tier-group\"})\n            };\n            this.tierGroups[g] = tierGroup;\n        }\n\n        if (tierGroup.element.parentNode)\n            tierGroup.element.parentNode.removeChild(tierGroup.element);\n\n        var holder = tiers[0].pinned ? this.pinnedTierHolder : this.tierHolder;\n        var min = 10000000, max = 0;\n        for (var ti = 0; ti < tiers.length; ++ti) {\n            var row = tiers[ti].row;\n            min = Math.min(min, row.offsetTop);\n            max = Math.max(max, row.offsetTop + row.offsetHeight);\n        }\n        tierGroup.element.style.top = min + 'px';\n        tierGroup.element.style.left = '0px';\n        tierGroup.element.style.height = (max-min) + 'px';\n        holder.appendChild(tierGroup.element);\n    }\n\n    if (this.tierBackgroundColors) {\n        for (var ti = 0; ti < arrangedTiers.length; ++ti) {\n            var t = arrangedTiers[ti];\n            t.setBackground(this.tierBackgroundColors[ti % this.tierBackgroundColors.length]);\n            if (t.dasSource.tierGroup) \n                t.label.style.left = '18px';\n            else\n                t.label.style.left = '2px';\n            t.background = this.tierBackgroundColors[ti % this.tierBackgroundColors.length];\n        }\n    }\n}\n\nBrowser.prototype.refresh = function() {\n\n    this.retrieveTierData(this.tiers, defaultTierRenderer);\n    this.drawOverlays();\n    this.positionRuler();\n\n};\n\nvar defaultTierRenderer = function(status, tier) {\n    tier.draw();\n    tier.updateStatus(status);\n}\n\nBrowser.prototype.retrieveTierData = function(tiers, tierRendererCallback) {\n    this.notifyLocation();\n    var width = (this.viewEnd - this.viewStart) + 1;\n    var minExtraW = (100.0/this.scale)|0;\n    var maxExtraW = (1000.0/this.scale)|0;\n\n    var newOrigin = (this.viewStart + this.viewEnd) / 2;\n    var oh = newOrigin - this.origin;\n    this.origin = newOrigin;\n    this.scaleAtLastRedraw = this.scale;\n    for (var t = 0; t < tiers.length; ++t) {\n        var od = oh;\n        if (tiers[t].originHaxx) {\n            od += tiers[t].originHaxx;\n        }\n        tiers[t].originHaxx = od;\n    }\n\n    var scaledQuantRes = this.targetQuantRes / this.scale;\n\n    var innerDrawnStart = Math.max(1, (this.viewStart|0) - minExtraW);\n    var innerDrawnEnd = Math.min((this.viewEnd|0) + minExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000))\n    var outerDrawnStart = Math.max(1, (this.viewStart|0) - maxExtraW);\n    var outerDrawnEnd = Math.min((this.viewEnd|0) + maxExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000));\n\n    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {\n        var ss = this.getSequenceSource();\n        if (this.knownSpace)\n            this.knownSpace.cancel();\n        // known space is created based on the entire tier list, for future caching purposes, even if only a subset of the tiers are needed to be rendered now.\n        this.knownSpace = new KnownSpace(this.tiers, this.chr, outerDrawnStart, outerDrawnEnd, scaledQuantRes, ss);\n    }\n    \n    var seg = this.knownSpace.bestCacheOverlapping(this.chr, innerDrawnStart, innerDrawnEnd);\n    if (seg && seg.min <= innerDrawnStart && seg.max >= innerDrawnEnd) {\n        this.drawnStart = Math.max(seg.min, outerDrawnStart);\n        this.drawnEnd = Math.min(seg.max, outerDrawnEnd);\n    } else {\n        this.drawnStart = outerDrawnStart;\n        this.drawnEnd = outerDrawnEnd;\n    }\n    // send in the subset of tiers to retrieve.\n    this.knownSpace.retrieveFeatures(tiers, this.chr, this.drawnStart, this.drawnEnd, scaledQuantRes, tierRendererCallback);\n}\n\nfunction setSources(msh, availableSources, maybeMapping) {\n    if (maybeMapping) {\n        for (var s = 0; s < availableSources.length; ++s) {\n            availableSources[s].mapping = maybeMapping;\n        }\n    }\n    msh.set(availableSources);\n}\n\nBrowser.prototype.queryRegistry = function(maybeMapping, tryCache) {\n    if (!this.registry)\n        return;\n\n    var thisB = this;\n    var coords, msh;\n    if (maybeMapping) {\n        coords = this.chains[maybeMapping].coords;\n        if (!thisB.mappableSources[maybeMapping]) {\n            thisB.mappableSources[maybeMapping] = new Observed();\n        }\n        msh = thisB.mappableSources[maybeMapping];\n    } else {\n        coords = this.coordSystem;\n        msh = this.availableSources;\n    }\n    var cacheHash = hex_sha1(miniJSONify(coords));\n    if (tryCache) {\n        var cacheTime = localStorage['dalliance.registry.' + cacheHash + '.last_queried'];\n        if (cacheTime) {\n            try {\n                setSources(msh, JSON.parse(localStorage['dalliance.registry.' + cacheHash + '.sources']), maybeMapping);\n                var cacheAge = (Date.now()|0) - (cacheTime|0);\n                if (cacheAge < (12 * 60 * 60 * 1000)) {\n                    return;\n                }\n            } catch (rex) {\n                console.log('Bad registry cache: ' + rex);\n            }\n        }\n    }\n\n    var rurl = this.registry;\n    if (rurl.indexOf('//') == 0) {\n        var proto = window.location.protocol;\n        if (proto != 'https:' && proto != 'http:')\n            rurl = 'http:' + rurl;\n    }\n    new DASRegistry(rurl).sources(function(sources) {\n        var availableSources = [];\n        for (var s = 0; s < sources.length; ++s) {\n            var source = sources[s];\n            if (!source.coords || source.coords.length == 0) {\n                continue;\n            }\n            var scoords = source.coords[0];\n            if (scoords.taxon != coords.taxon || scoords.auth != coords.auth || scoords.version != coords.version) {\n                continue;\n            }   \n            availableSources.push(source);\n        }\n\n        localStorage['dalliance.registry.' + cacheHash + '.sources'] = JSON.stringify(availableSources);\n        localStorage['dalliance.registry.' + cacheHash + '.last_queried'] = '' + Date.now();\n        \n        setSources(msh, availableSources, maybeMapping);\n    }, function(error) {\n        // msh.set(null);\n    }, coords);\n}\n\n//\n// Navigation\n//\n\nBrowser.prototype.move = function(pos, soft)\n{\n    var wid = this.viewEnd - this.viewStart;\n    var nStart = this.viewStart - ((1.0 * pos) / this.scale);\n    var nEnd = nStart + wid;\n\n    if (!soft) {\n        if (this.currentSeqMax > 0 && nEnd > this.currentSeqMax) {\n            nEnd = this.currentSeqMax;\n            nStart = this.viewEnd - wid;\n        }\n        if (nStart < 1) {\n            nStart = 1;\n            nEnd = nStart + wid;\n        }\n    }\n\n    this.setLocation(null, nStart, nEnd, null, soft);\n}\n\nBrowser.prototype.zoomStep = function(delta) {\n    var oz = 1.0 * this.zoomSliderValue;\n    var nz = oz + delta;\n    if (nz < this.zoomMin) {\n        nz= this.zoomMin;\n    }\n    if (nz > this.zoomMax) {\n        nz = this.zoomMax;\n    }\n\n    if (nz != oz) {\n        this.zoomSliderValue = nz; // FIXME maybe ought to set inside zoom!\n        this.zoom(Math.exp((1.0 * nz) / this.zoomExpt));\n    }\n}\n\nBrowser.prototype.zoom = function(factor) {\n    this.zoomFactor = factor;\n    var viewCenter = Math.round((this.viewStart + this.viewEnd) / 2.0)|0;\n    this.viewStart = viewCenter - this.zoomBase * this.zoomFactor / 2;\n    this.viewEnd = viewCenter + this.zoomBase * this.zoomFactor / 2;\n    if (this.currentSeqMax > 0 && (this.viewEnd > this.currentSeqMax + 5)) {\n        var len = this.viewEnd - this.viewStart + 1;\n        this.viewEnd = this.currentSeqMax;\n        this.viewStart = this.viewEnd - len + 1;\n    }\n    if (this.viewStart < 1) {\n        var len = this.viewEnd - this.viewStart + 1;\n        this.viewStart = 1;\n        this.viewEnd = this.viewStart + len - 1;\n    }\n    this.scale = this.featurePanelWidth / (this.viewEnd - this.viewStart)\n    var width = this.viewEnd - this.viewStart + 1;\n    \n    var scaleRat = (this.scale / this.scaleAtLastRedraw);\n\n    this.notifyLocation();\n    this.refresh();\n}\n\nBrowser.prototype.spaceCheck = function(dontRefresh) {\n    if (!this.knownSpace || this.knownSpace.chr !== this.chr) {\n        this.refresh();\n        return;\n    } \n\n    var width = ((this.viewEnd - this.viewStart)|0) + 1;\n    var minExtraW = (100.0/this.scale)|0;\n    var maxExtraW = (1000.0/this.scale)|0;\n\n    if ((this.drawnStart|0) > Math.max(1, ((this.viewStart|0) - minExtraW)|0)  || (this.drawnEnd|0) < Math.min((this.viewEnd|0) + minExtraW, ((this.currentSeqMax|0) > 0 ? (this.currentSeqMax|0) : 1000000000)))  {\n        this.refresh();\n    }\n}\n\nBrowser.prototype.resizeViewer = function(skipRefresh) {\n    var width = this.tierHolder.getBoundingClientRect().width | 0;\n    if (width == 0)\n        return;\n\n    var oldFPW = Math.max(this.featurePanelWidth, 300); // Can get silly values stored\n                                                        // when the browser is hidden.\n    this.featurePanelWidth = width|0;\n\n    if (oldFPW != this.featurePanelWidth) {\n        this.zoomMax = this.zoomExpt * Math.log(this.maxViewWidth / this.zoomBase);\n        this.zoomMin = this.zoomExpt * Math.log(this.featurePanelWidth / this.maxPixelsPerBase / this.zoomBase);   // FIXME hard-coded minimum.\n        this.zoomSliderValue = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);\n\n        var viewWidth = this.viewEnd - this.viewStart;\n        var nve = this.viewStart + (viewWidth * this.featurePanelWidth) / oldFPW;\n\n        this.viewEnd = nve;\n\n        var wid = this.viewEnd - this.viewStart + 1;\n        if (this.currentSeqMax > 0 && this.viewEnd > this.currentSeqMax) {\n            this.viewEnd = this.currentSeqMax;\n            this.viewStart = this.viewEnd - wid + 1;\n        }\n        if (this.viewStart < 1) {\n            this.viewStart = 1;\n            this.viewEnd = this.viewStart + wid - 1;\n        }\n\n        this.positionRuler();\n\n        if (!skipRefresh) {\n            this.spaceCheck();\n        }\n        this.notifyLocation();\n    }\n\n    if (this.fullScreen) {\n        this.setFullScreenHeight();\n    }\n}\n\nBrowser.prototype.setFullScreenHeight = function() {\n    var rest = document.body.offsetHeight - this.browserHolder.offsetHeight;\n    this.browserHolder.style.maxHeight = Math.max(300, window.innerHeight - rest - 20) + 'px'\n}\n\nBrowser.prototype.addTier = function(conf) {\n    var thisB = this;\n    conf = shallowCopy(conf);\n    conf.disabled = false;\n\n    return this.makeTier(conf).then(function (tier) {\n        thisB.refreshTier(tier);\n        thisB.markSelectedTiers();\n        thisB.positionRuler();\n        thisB.notifyTier(\"added\", tier);\n        return tier;\n    })\n};\n\n\nBrowser.prototype.removeTier = function(conf, force) {\n    var target = -1;\n\n    if (typeof conf.index !== 'undefined' && conf.index >=0 && conf.index < this.tiers.length) {\n        target = conf.index;\n    } else {\n        for (var ti = 0; ti < this.tiers.length; ++ti) {\n            var ts = this.tiers[ti].dasSource;\n            \n            if (sourcesAreEqual(conf, ts)) {\n                target = ti; break;\n            }\n        }\n    }\n\n    if (target < 0) {\n        throw \"Couldn't find requested tier\";\n    }\n\n    var targetTier = this.tiers[target];\n    this.tiers.splice(target, 1);\n\n    var nst = [];\n    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {\n        var st = this.selectedTiers[sti];\n        if (st < target) {\n            nst.push(st);\n        } else if (st > target) {\n            nst.push(st - 1);\n        }\n    }\n    this.selectedTiers = nst;\n    this.markSelectedTiers();\n\n    targetTier.destroy();\n    if (this.knownSpace) {\n        this.knownSpace.featureCache[targetTier] = null;\n    }\n\n    this.reorderTiers();\n    this.notifyTier(\"removed\", targetTier);\n}\n\nBrowser.prototype.removeAllTiers = function() {\n\tvar thisB = this;\n    this.selectedTiers = [];\n    this.markSelectedTiers();\n    this.tiers.forEach(function (targetTier) {\n        targetTier.destroy();\n        if (thisB.knownSpace) {\n            thisB.knownSpace.featureCache[targetTier] = null;\n        }\n    });\n    this.tiers.length = 0;\n    this.reorderTiers();\n    this.notifyTier(\"removedAll\", null);\n}\n\nBrowser.prototype.getSequenceSource = function() {\n    if (this._sequenceSource === undefined)\n        this._sequenceSource = this._getSequenceSource();\n    return this._sequenceSource;\n}\n\nBrowser.prototype._getSequenceSource = function() {\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        if (this.tiers[ti].sequenceSource) {\n            return this.tiers[ti].sequenceSource;\n        }\n    }\n\n    for (var si = 0; si < this.defaultSources.length; ++si) {\n        var s = this.defaultSources[si];\n        if (s.provides_entrypoints || s.tier_type == 'sequence' || s.twoBitURI || s.twoBitBlob) {\n            if (s.twoBitURI || s.twoBitBlob) {\n                return new TwoBitSequenceSource(s);\n            } else if (s.ensemblURI) {\n                return new EnsemblSequenceSource(s);\n            } else {\n                return new DASSequenceSource(s);\n            }\n        }\n    }\n}\n\nBrowser.prototype.setLocation = function(newChr, newMin, newMax, callback, soft) {\n    if (typeof(newMin) !== 'number') {\n        throw Error('minimum must be a number (got ' + JSON.stringify(newMin) + ')');\n    }\n    if (typeof(newMax) !== 'number') {\n        throw Error('maximum must be a number (got ' + JSON.stringify(newMax) + ')');\n    }\n\n    if (newMin > newMax) {\n        var oldNewMin = newMin;\n        newMin = newMax;\n        newMax = oldNewMin;\n    } else if (newMin === newMax) {\n        newMax += 1;\n    }\n\n    if (!callback) {\n        callback = function(err) {\n            if (err) {\n                throw err;\n            }\n        }\n    }\n    var thisB = this;\n\n    if ((!newChr || newChr == this.chr) && this.currentSeqMax > 0) {\n        return this._setLocation(null, newMin, newMax, null, callback, soft);\n    } else {\n        var ss = this.getSequenceSource();\n        if (!ss) {\n            return callback('Need a sequence source');\n        }\n\n        var findChr = newChr || this.chr;\n        ss.getSeqInfo(findChr, function(si) {\n            if (!si) {\n                var altChr;\n                if (findChr.indexOf('chr') == 0) {\n                    altChr = findChr.substr(3);\n                } else {\n                    altChr = 'chr' + findChr;\n                }\n                ss.getSeqInfo(altChr, function(si2) {\n                    if (!si2 && newChr) {\n                        return callback(\"Couldn't find sequence '\" + newChr + \"'\");\n                    } else if (!si2) {\n                        return thisB._setLocation(null, newMin, newMax, null, callback, soft);\n                    } else {\n                        return thisB._setLocation(altChr, newMin, newMax, si2, callback, soft);\n                    }\n                });\n            } else {\n                return thisB._setLocation(newChr, newMin, newMax, si, callback, soft);\n            }\n        });\n    }\n}\n\nBrowser.prototype._setLocation = function(newChr, newMin, newMax, newChrInfo, callback, soft) {\n    var chrChanged = false;\n    if (newChr) {\n        if (newChr.indexOf('chr') == 0)\n            newChr = newChr.substring(3);\n\n        if (this.chr != newChr)\n            chrChanged = true;\n        this.chr = newChr;\n        this.currentSeqMax = newChrInfo.length;\n    }\n\n    newMin = parseFloat(newMin); newMax=parseFloat(newMax);\n\n    var newWidth = Math.max(10, newMax-newMin+1);\n\n    if (!soft) {\n        var csm = this.currentSeqMax;\n        if (csm <= 0)\n            csm = 1000000000000;\n        if (newMin < 1) {\n            newMin = 1; newMax = newMin + newWidth - 1;\n        }\n        if (newMax > csm) {\n            newMax = csm;\n            newMin = Math.max(1, newMax - newWidth + 1);\n        }\n    }\n\n    this.viewStart = newMin;\n    this.viewEnd = newMax;\n    var newScale = Math.max(this.featurePanelWidth || this.offscreenInitWidth, 50) / (this.viewEnd - this.viewStart);\n    var oldScale = this.scale;\n    var scaleChanged = (Math.abs(newScale - oldScale)) > 0.000001;\n    this.scale = newScale;\n\n    var newZS, oldZS;\n    oldZS = this.zoomSliderValue;\n    this.zoomSliderValue = newZS = this.zoomExpt * Math.log((this.viewEnd - this.viewStart + 1) / this.zoomBase);\n    \n    if (scaleChanged || chrChanged) {\n        for (var i = 0; i < this.tiers.length; ++i) {\n            this.tiers[i].viewportHolder.style.left = '5000px';\n            this.tiers[i].overlay.style.left = '5000px';\n        }\n\n        this.refresh();\n\n        if (this.savedZoom) {\n            newZS -= this.zoomMin;\n            oldZS -= this.zoomMin;\n            var difToActive = newZS - oldZS;\n            var difToSaved = newZS - this.savedZoom;\n            if (Math.abs(difToActive) > Math.abs(difToSaved)) {\n                this.isSnapZooming = !this.isSnapZooming;\n                this.savedZoom = oldZS;\n            }\n        } else {\n            this.isSnapZooming = false;\n            this.savedZoom = null;\n        }\n    } else {\n        var viewCenter = (this.viewStart + this.viewEnd)/2;\n    \n        for (var i = 0; i < this.tiers.length; ++i) {\n            var offset = (this.viewStart - this.tiers[i].norigin)*this.scale;\n            this.tiers[i].viewportHolder.style.left = '' + ((-offset|0) - 1000) + 'px';\n            this.tiers[i].drawOverlay();\n        }\n    }\n\n    this.notifyLocation();\n\n    this.spaceCheck();\n    if (this.instrumentActivity)\n        this.activityStartTime = Date.now()|0;\n    return callback();\n}\n\nBrowser.prototype.setCenterLocation = function(newChr, newCenterLoc) {\n    var halfWidth = (this.viewEnd - this.viewStart)/2,\n    newMin = newCenterLoc - halfWidth,\n    newMax = newCenterLoc + halfWidth;\n    this.setLocation(newChr, newMin, newMax);\n}\n\nBrowser.prototype.pingActivity = function() {\n    if (!this.instrumentActivity || !this.activityStartTime)\n        return;\n\n    var activity = 0;\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        if (this.tiers[ti].loaderButton.style.display !== 'none')\n            ++activity;\n    }\n\n    if (activity == 0) {\n        var now = Date.now()|0;\n        console.log('Loading took ' + (now-this.activityStartTime) + 'ms');\n        this.activityStartTime = null;\n    }\n}\n\nBrowser.prototype.addInitListener = function(handler) {\n    this.initListeners.push(handler);\n}\n\nBrowser.prototype.addFeatureListener = function(handler, opts) {\n    opts = opts || {};\n    this.featureListeners.push(handler);\n}\n\nBrowser.prototype.removeFeatureListener = function(handler, opts) {\n    var idx = arrayIndexOf(this.featureListeners, handler);\n    if (idx >= 0) {\n        this.featureListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyFeature = function(ev, feature, hit, tier) {\n  for (var fli = 0; fli < this.featureListeners.length; ++fli) {\n      try {\n          if (this.featureListeners[fli](ev, feature, hit, tier))\n            return;\n      } catch (ex) {\n          console.log(ex.stack);\n      }\n  }\n}\n\nBrowser.prototype.addFeatureHoverListener = function(handler, opts) {\n    opts = opts || {};\n    this.featureHoverListeners.push(handler);\n}\n\nBrowser.prototype.removeFeatureHoverListener = function(handler, opts) {\n    var idx = arrayIndexOf(this.featureHoverListeners, handler);\n    if (idx >= 0) {\n        this.featureHoverListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyFeatureHover = function(ev, feature, hit, tier) {\n    for (var fli = 0; fli < this.featureHoverListeners.length; ++fli) {\n        try {\n            this.featureHoverListeners[fli](ev, feature, hit, tier);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n}\n\nBrowser.prototype.addViewListener = function(handler, opts) {\n    opts = opts || {};\n    this.viewListeners.push(handler);\n}\n\nBrowser.prototype.removeViewListener = function(handler, opts) {\n    var idx = arrayIndexOf(this.viewListeners, handler);\n    if (idx >= 0) {\n        this.viewListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyLocation = function() {\n    var nvs = Math.max(1, this.viewStart|0);\n    var nve = this.viewEnd|0;\n    if (this.currentSeqMax > 0 && nve > this.currentSeqMax)\n        nve = this.currentSeqMax;\n\n    for (var lli = 0; lli < this.viewListeners.length; ++lli) {\n        try {\n            this.viewListeners[lli](\n                this.chr, \n                nvs, \n                nve, \n                this.zoomSliderValue, \n                {current: this.zoomSliderValue,\n                 alternate: (this.savedZoom+this.zoomMin) || this.zoomMin,\n                 isSnapZooming: this.isSnapZooming,\n                 min: this.zoomMin, \n                 max: this.zoomMax},\n                 this.viewStart,\n                 this.viewEnd);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n}\n\nBrowser.prototype.addTierListener = function(handler) {\n    this.tierListeners.push(handler);\n}\n\nBrowser.prototype.removeTierListener = function(handler) {\n    var idx = arrayIndexOf(this.tierListeners, handler);\n    if (idx >= 0) {\n        this.tierListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyTier = function(status, tier) {\n    for (var tli = 0; tli < this.tierListeners.length; ++tli) {\n        try {\n            this.tierListeners[tli](status, tier);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n}\n\nBrowser.prototype.addRegionSelectListener = function(handler) {\n    this.regionSelectListeners.push(handler);\n}\n\nBrowser.prototype.removeRegionSelectListener = function(handler) {\n    var idx = arrayIndexOf(this.regionSelectListeners, handler);\n    if (idx >= 0) {\n        this.regionSelectListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyRegionSelect = function(chr, min, max) {\n    for (var rli = 0; rli < this.regionSelectListeners.length; ++rli) {\n        try {\n            this.regionSelectListeners[rli](chr, min, max);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n}\n\n\nBrowser.prototype.highlightRegion = function(chr, min, max) {\n    var thisB = this;\n    \n    if (chr == this.chr) {\n        return this._highlightRegion(chr, min, max);\n    }\n\n    var ss = this.getSequenceSource();\n    if (!ss) {\n        throw 'Need a sequence source';\n    }\n\n    ss.getSeqInfo(chr, function(si) {\n        if (!si) {\n            var altChr;\n            if (chr.indexOf('chr') == 0) {\n                altChr = chr.substr(3);\n            } else {\n                altChr = 'chr' + chr;\n            }\n            ss.getSeqInfo(altChr, function(si2) {\n                if (!si2) {\n                    // Fail silently.\n                } else {\n                    return thisB._highlightRegion(altChr, min, max);\n                }\n            });\n        } else {\n            return thisB._highlightRegion(chr, min, max);\n        }\n    });\n}\n\nBrowser.prototype._highlightRegion = function(chr, min, max) {\n    for (var hi = 0; hi < this.highlights.length; ++hi) {\n        var h = this.highlights[hi];\n        if (h.chr == chr && h.min == min && h.max == max)\n            return;\n    }\n\n    this.highlights.push(new Region(chr, min, max));\n    var visStart = this.viewStart - (1000/this.scale);\n    var visEnd = this.viewEnd + (1000/this.scale);\n    if ((chr == this.chr || chr == ('chr'+this.chr)) && min < visEnd && max > visStart) {\n        this.drawOverlays();\n    }\n\n    this.notifyLocation();\n}\n\nBrowser.prototype.clearHighlights = function() {\n    this.highlights = [];\n    this.drawOverlays();\n    this.notifyLocation();\n}\n\nBrowser.prototype.drawOverlays = function() {\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        this.tiers[ti].drawOverlay();\n    }\n}\n\nBrowser.prototype.featuresInRegion = function(chr, min, max) {\n    var features = [];\n    if (chr !== this.chr) {\n        return [];\n    }\n\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var fl = this.tiers[ti].currentFeatures || [];\n        for (var fi = 0; fi < fl.length; ++fi) {\n            var f = fl[fi];\n            if (f.min <= max && f.max >= min) {\n                features.push(f);\n            }\n        }\n    }\n    return features;\n}\n\n\nBrowser.prototype.getSelectedTier = function() {\n    if (this.selectedTiers.length > 0) \n        return this.selectedTiers[0];\n    else\n        return -1;\n}\n\nBrowser.prototype.setSelectedTier = function(t) {\n    if (t == null) {\n        this.selectedTiers = [];\n    } else {\n        this.selectedTiers = [t];\n    }\n    this.markSelectedTiers();\n    this.notifyTierSelection();\n}\n\nBrowser.prototype.markSelectedTiers = function() {\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var button = this.tiers[ti].nameButton;\n\n        if (this.selectedTiers.indexOf(ti) >= 0) {\n            button.classList.add('active');\n        } else {\n            button.classList.remove('active');\n        }\n    }\n    if (this.selectedTiers.length > 0) {\n        var browserMid = this.browserHolder.offsetTop + this.browserHolder.offsetHeight/2;\n        if (browserMid > document.body.scrollTop && (browserMid + 100) < document.body.scrollTop + window.innerHeight)\n            this.browserHolder.focus();\n    }\n}\n\nBrowser.prototype.addTierSelectionListener = function(handler) {\n    this.tierSelectionListeners.push(handler);\n}\n\nBrowser.prototype.removeTierSelectionListener = function(handler) {\n    var idx = arrayIndexOf(this.tierSelectionListeners, handler);\n    if (idx >= 0) {\n        this.tierSelectionListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyTierSelection = function() {\n    for (var fli = 0; fli < this.tierSelectionListeners.length; ++fli) {\n        try {\n            this.tierSelectionListeners[fli](this.selectedTiers);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n\n}\n\nBrowser.prototype.addTierSelectionWrapListener = function(f) {\n    this.tierSelectionWrapListeners.push(f);\n}\n\nBrowser.prototype.removeTierSelectionWrapListener = function(handler) {\n    var idx = arrayIndexOf(this.tierSelectionWrapListeners, handler);\n    if (idx >= 0) {\n        this.tierSelectionWrapListeners.splice(idx, 1);\n    }\n}\n\nBrowser.prototype.notifyTierSelectionWrap = function(i) {\n    for (var fli = 0; fli < this.tierSelectionWrapListeners.length; ++fli) {\n        try {\n            this.tierSelectionWrapListeners[fli](i);\n        } catch (ex) {\n            console.log(ex.stack);\n        }\n    }\n}\n\n\nBrowser.prototype.positionRuler = function() {\n    var display = 'none';\n    var left = '';\n    var right = '';\n\n    if (this.rulerLocation == 'center') {\n        display = 'block';\n        left = '' + ((this.featurePanelWidth/2)|0) + 'px';\n    } else if (this.rulerLocation == 'left') {\n        display = 'block';\n        left = '0px';\n    } else if (this.rulerLocation == 'right') {\n        display = 'block';\n        right = '0px'\n    } else {\n        display = 'none';\n    }\n\n    this.ruler.style.display = display;\n    this.ruler.style.left = left;\n    this.ruler.style.right = right;\n\n    if(this.singleBaseHighlight) {\n        this.ruler2.style.display = 'block';\n        this.ruler2.style.borderWidth = '1px';\n        if (this.scale < 1) {\n            this.ruler2.style.width = '0px';\n            this.ruler2.style.borderRightWidth = '0px' \n        } else {\n            this.ruler2.style.width = this.scale + 'px';\n            this.ruler2.style.borderRightWidth = '1px' \n        } \n        // Position accompanying single base location text\n        this.locSingleBase.style.visibility = 'visible';\n        var centreOffset = this.featurePanelWidth/2 - this.locSingleBase.offsetWidth/2 + this.ruler2.offsetWidth/2; \n        this.locSingleBase.style.left = '' + (centreOffset|0) + 'px';\n    } else {\n        this.locSingleBase.style.visibility = 'hidden';\n        this.ruler2.style.width = '1px';\n        this.ruler2.style.borderWidth = '0px';\n        this.ruler2.style.display = this.rulerLocation == 'center' ? 'none' : 'block';\n    }\n   \n    this.ruler2.style.left = '' + ((this.featurePanelWidth/2)|0) + 'px';\n    \n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var tier = this.tiers[ti];\n        var q = tier.quantOverlay;\n\n        var quant;\n        if (tier.subtiers && tier.subtiers.length > 0)\n            quant = tier.subtiers[0].quant;\n\n        if (q) {\n            q.style.display = quant ? display : 'none';\n            q.style.left = left;\n            q.style.right = right;\n        }\n    }\n}\n\nBrowser.prototype.featureDoubleClick = function(hit, rx, ry) {\n    if (!hit || hit.length == 0)\n        return;\n\n    var f = hit[hit.length - 1];\n\n    if (!f.min || !f.max) {\n        return;\n    }\n\n    var fstart = (((f.min|0) - (this.viewStart|0)) * this.scale);\n    var fwidth = (((f.max - f.min) + 1) * this.scale);\n    \n    var newMid = (((f.min|0) + (f.max|0)))/2;\n    if (fwidth > 10) {\n        var frac = (1.0 * (rx - fstart)) / fwidth;\n        if (frac < 0.3) {\n            newMid = (f.min|0);\n        } else  if (frac > 0.7) {\n            newMid = (f.max|0) + 1;\n        }\n    }\n\n    var width = this.viewEnd - this.viewStart;\n    this.setLocation(null, newMid - (width/2), newMid + (width/2));\n}\n\nBrowser.prototype.zoomForScale = function(scale) {\n    var ssScale;\n    if (scale > 0.2) {\n        ssScale = 'high';\n    } else if (scale > 0.01) {\n        ssScale = 'medium';\n    } else  {\n        ssScale = 'low';\n    }\n    return ssScale;\n}\n\nBrowser.prototype.zoomForCurrentScale = function() {\n    return this.zoomForScale(this.scale);\n}\n\nBrowser.prototype.updateHeight = function() {\n    var tierTotal = 0;\n    for (var ti = 0; ti < this.tiers.length; ++ti) \n        tierTotal += (this.tiers[ti].currentHeight || 30);\n    this.ruler.style.height = '' + tierTotal + 'px';\n    this.ruler2.style.height = '' + tierTotal + 'px';\n    this.browserHolder.style.display = 'block';\n    this.browserHolder.style.display = '-webkit-flex';\n    this.browserHolder.style.display = 'flex';\n    // this.svgHolder.style.maxHeight = '' + Math.max(tierTotal, 500) + 'px';\n}\n\nBrowser.prototype.scrollArrowKey = function(ev, dir) {\n    if (this.reverseKeyScrolling)\n        dir = -dir;\n    \n    if (ev.ctrlKey || ev.metaKey) {\n        var fedge = false;\n        if(ev.shiftKey){\n            fedge = true;\n        }\n\n        this.leap(dir, fedge);\n    } else if (this.scale > 1) {\n        // per-base scrolling mode, tries to perfectly center.\n        var mid = (this.viewStart + this.viewEnd)/2\n        var err = mid - Math.round(mid);\n        var n = 1;\n        if (ev.shiftKey)\n            n *= 10;\n        if (dir > 0) {\n            n = -n;\n            n -= err;\n            if (err > 0)\n                n += 1;\n        } else {\n            n -= err;\n            if (err < 0)\n                n -= 1;\n        }\n        this.setLocation(null, this.viewStart + n, this.viewEnd + n);\n    } else {\n        this.move(ev.shiftKey ? 100*dir : 25*dir);\n    }\n}\n\nBrowser.prototype.leap = function(dir, fedge) {\n    var thisB = this;\n    var pos=((thisB.viewStart + thisB.viewEnd + 1)/2)|0;\n    if (dir > 0 && thisB.viewStart <= 1) {\n        pos -= 100000000;\n    } else if (dir < 0 && thisB.viewEnd >= thisB.currentSeqMax) {\n        pos += 100000000;\n    }\n\n    var st = thisB.getSelectedTier();\n    if (st < 0) return;\n    var tier = thisB.tiers[st];\n\n    if (tier && ((tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'quantLeap') && typeof(tier.quantLeapThreshold) == 'number')\n                 || (tier.featureSource && this.sourceAdapterIsCapable(tier.featureSource, 'leap')))) {\n        tier.findNextFeature(\n              thisB.chr,\n              pos,\n              -dir,\n              fedge,\n              function(nxt) {\n                  if (nxt) {\n                      var nmin = nxt.min;\n                      var nmax = nxt.max;\n                      if (fedge) { \n                        if (dir > 0) {\n                          if (nmin>pos+1) {\n                              nmax=nmin;\n                          } else {\n                              nmax++;\n                              nmin=nmax\n                          }\n                        } else {\n                            if (nmax<pos-1) {\n                                nmax++;\n                                nmin=nmax;\n                            } else {\n                                nmax=nmin;\n                            }\n                        } \n                      }\n                      var wid = thisB.viewEnd - thisB.viewStart + 1;\n                      if(parseFloat(wid/2) == parseInt(wid/2)){wid--;}\n                      var newStart = (nmin + nmax - wid)/2 + 1;\n                      var newEnd = newStart + wid - 1;\n                      var pos2=pos;\n                      thisB.setLocation(nxt.segment, newStart, newEnd);\n                  } else {\n                      alert('no next feature'); // FIXME better reporting would be nice!\n                  }\n              });\n    } else {\n        this.move(100*dir);\n    }\n}\n\nfunction glyphLookup(glyphs, rx, ry, matches) {\n    matches = matches || [];\n\n    for (var gi = glyphs.length - 1; gi >= 0; --gi) {\n        var g = glyphs[gi];\n        if (!g.notSelectable && g.min() <= rx && g.max() >= rx) {\n            if (g.minY) {\n                if (ry < g.minY() || ry > g.maxY())\n                    continue;\n            }\n\n            if (g.feature) {\n                matches.push(g.feature);\n            } else if (g.group) {\n                matches.push(g.group);\n            }\n    \n            if (g.glyphs) {\n                return glyphLookup(g.glyphs, rx, ry, matches);\n            } else if (g.glyph) {\n                return glyphLookup([g.glyph], rx, ry, matches);\n            } else {\n                return matches;\n            }\n        }\n    }\n    return matches;\n}\n\nBrowser.prototype.nameForCoordSystem = function(cs) {\n    var primary = null, ucsc = null;\n    if (this.assemblyNamePrimary) {\n        primary = '' + cs.auth;\n        if (typeof(cs.version) !== 'undefined')\n            primary += cs.version;\n    }\n    if (this.assemblyNameUcsc) {\n        ucsc = cs.ucscName;\n    }\n    if (primary != null && ucsc != null)\n        return primary + '/' + ucsc;\n    else \n        return primary || ucsc || 'unknown';\n}\n\nBrowser.prototype.makeLoader = function(size) {\n    size = size || 16;\n    var retina = window.devicePixelRatio > 1;\n    if (size < 20) {\n        return makeElement('img', null, {src: this.resolveURL('$$img/spinner_' + (retina ? 16 : 32) + '.gif'), width: '16', height: '16'});\n    } else {\n        return makeElement('img', null, {src: this.resolveURL('$$img/spinner_' + (retina ? 24 : 48) + '.gif'), width: '24', height: '24'});\n    }\n}\n\nBrowser.prototype.canFetchPlainHTTP = function() {\n    var self = this;\n    if (!this._plainHTTPPromise) {\n        var worker = this.getWorker();\n        if (worker) {\n            this._plainHTTPPromise = new Promise(function(resolve, reject) {\n                worker.postCommand(\n                    {command: 'textxhr',\n                     uri: self.httpCanaryURL},\n                    function(result, err) {\n                        if (result) {\n                            resolve(true);\n                        } else {\n                            resolve(false);\n                        }\n                    });\n                });\n        } else {\n           this._plainHTTPPromise = new Promise(function(resolve, reject) {\n                textXHR(\n                    self.httpCanaryURL,\n                    function(result, err) {\n                        if (result) {\n                            resolve(true);\n                        } else {\n                            resolve(false);\n                        }\n                    },\n                    {timeout: 2000}\n                );\n            });\n        }\n    }\n    return this._plainHTTPPromise;\n}\n\nBrowser.prototype.getWorker = function() {\n    if (!this.useFetchWorkers || !this.fetchWorkers || this.fetchWorkers.length==0)\n        return null;\n\n    if (this.nextWorker >= this.fetchWorkers.length)\n        this.nextWorker = 0;\n    return this.fetchWorkers[this.nextWorker++];\n}\n\nBrowser.prototype.registerResolver = function(resolver) {\n    var id = 'res' + (++this.resolverSeed);\n    this.resolvers[id] = resolver;\n    return id;\n}\n\nfunction FetchWorker(browser, worker) {\n    var thisB = this;\n    this.tagSeed = 0;\n    this.callbacks = {};\n    this.browser = browser;\n    this.worker = worker;\n\n    this.worker.onmessage = function(ev) {\n        var data = ev.data;\n\n        if (!data.cmd) {\n            var cb = thisB.callbacks[data.tag];\n            if (cb) {\n                cb(data.result, data.error);\n                delete thisB.callbacks[data.tag];\n            }\n        } else if (data.cmd == 'resolve') {\n            var resolver = thisB.browser.resolvers[data.resolver];\n            if (resolver) {\n                resolver(data.url).then(function(url) {\n                    thisB.worker.postMessage({\n                        tag: data.tag,\n                        url: url\n                    });\n                }).catch(function(err){\n                    console.log(err);\n                    thisB.worker.postMessage({\n                        tag: data.tag,\n                        err: err.toString()\n                    });\n                });\n            } else {\n                console.log('No resolver ' + data.resolver);\n            }\n        } else {\n            console.log('Bad worker callback ' + data.cmd);\n        }\n    };\n}\n\nfunction makeFetchWorker(browser) {\n    var wurl = browser.resolveURL(browser.workerPath);\n    if (wurl.indexOf('//') == 0) {\n        var proto = window.location.protocol;\n        if (proto == 'https:')\n            wurl = 'https:' + wurl;\n        else\n            wurl = 'http:' + wurl;\n    }\n\n    var wscript = 'importScripts(\"' + wurl + '?version=' + VERSION + '\");';\n    var wblob = new Blob([wscript], {type: 'application/javascript'});\n\n\n    return new Promise(function(resolve, reject) {\n        var worker = new Worker(URL.createObjectURL(wblob));\n\n        worker.onmessage = function(ev) {\n            if (ev.data.tag === 'init') {\n                console.log('Worker initialized');\n                resolve(new FetchWorker(browser, worker))\n            }\n            \n        }\n\n        worker.onerror = function(ev) {\n            reject(ev.message);\n        }\n    });    \n}\n\nFetchWorker.prototype.postCommand = function(cmd, callback, transfer) {\n    var tag = 'x' + (++this.tagSeed);\n    cmd.tag = tag;\n    this.callbacks[tag] = callback;\n    this.worker.postMessage(cmd, transfer);\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        Browser: Browser\n    };\n\n    // Required because they add stuff to Browser.prototype\n    require('./browser-ui');\n    require('./track-adder');\n    require('./feature-popup');\n    require('./tier-actions');\n    require('./domui');\n    require('./search');\n\n    var sa = require('./sourceadapters');\n    var TwoBitSequenceSource = sa.TwoBitSequenceSource;\n    var EnsemblSequenceSource = sa.EnsemblSequenceSource;\n    var DASSequenceSource = sa.DASSequenceSource;\n\n    var KnownSpace = require('./kspace').KnownSpace;\n\n    var DASRegistry = require('./das').DASRegistry;\n}\n\nfunction SourceCache() {\n    this.sourcesByURI = {}\n}\n\nSourceCache.prototype.get = function(conf) {\n    var scb = this.sourcesByURI[sourceDataURI(conf)];\n    if (scb) {\n        for (var si = 0; si < scb.configs.length; ++si) {\n            if (sourcesAreEqualModuloStyle(scb.configs[si], conf)) {\n                return scb.sources[si];\n            }\n        }\n    }\n}\n\nSourceCache.prototype.put = function(conf, source) {\n    var uri = sourceDataURI(conf);\n    var scb = this.sourcesByURI[uri];\n    if (!scb) {\n        scb = {configs: [], sources: []};\n        this.sourcesByURI[uri] = scb;\n    }\n    scb.configs.push(conf);\n    scb.sources.push(source);\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// chainset.js: liftover support\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var das = require('./das');\n    var DASSource = das.DASSource;\n    var DASSegment = das.DASSegment;\n\n    var utils = require('./utils');\n    var pusho = utils.pusho;\n    var shallowCopy = utils.shallowCopy;\n\n    var parseCigar = require('./cigar').parseCigar;\n\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n\n    var bbi = require('./bigwig');\n    var makeBwg = bbi.makeBwg;\n\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction Chainset(conf, srcTag, destTag, coords) {\n    if (typeof(conf) == 'string') {\n        this.uri = conf;\n        this.srcTag = srcTag;\n        this.destTag = destTag;\n        this.coords = coords;\n    } else {\n        this.uri = conf.uri;\n        this.srcTag = conf.srcTag;\n        this.destTag = conf.destTag;\n        this.coords = shallowCopy(conf.coords);\n        this.type = conf.type;\n        this.credentials = conf.credentials;\n    }\n\n    this.chainsBySrc = {};\n    this.chainsByDest = {};\n    this.postFetchQueues = {};\n    this.fetchedTiles = {};\n    this.granularity = 1000000;  // size in bases of tile to fetch\n\n    if (this.type == 'bigbed') {\n        this.chainFetcher = new BBIChainFetcher(this.uri, this.credentials);\n    } else if (this.type == 'alias') {\n        this.chainFetcher = new AliasChainFetcher(conf);\n    } else {\n        this.chainFetcher = new DASChainFetcher(this.uri, this.srcTag, this.destTag);\n    }\n};\n\nChainset.prototype.exportConfig = function() {\n    return {\n        uri: this.uri,\n        srcTag: this.srcTag,\n        destTag: this.destTag,\n        coords: this.coords,\n        type: this.type,\n        credentials: this.credentials\n    };\n}\n\nChainset.prototype.mapPoint = function(chr, pos) {\n    var chains = this.chainsBySrc[chr] || [];\n    for (var ci = 0; ci < chains.length; ++ci) {\n        var c = chains[ci];\n        if (pos >= c.srcMin && pos <= c.srcMax) {\n            var cpos;\n            if (c.srcOri == '-') {\n                cpos = c.srcMax - pos;\n            } else {\n                cpos = pos - c.srcMin;\n            }\n            var blocks = c.blocks;\n            for (var bi = 0; bi < blocks.length; ++bi) {\n                var b = blocks[bi];\n                var bSrc = b[0];\n                var bDest = b[1];\n                var bSize = b[2];\n                if (cpos >= bSrc && cpos <= (bSrc + bSize)) {\n                    var apos = cpos - bSrc;\n\n                    var dpos;\n                    if (c.destOri == '-') {\n                        dpos = c.destMax - bDest - apos;\n                    } else {\n                        dpos = apos + bDest + c.destMin;\n                    }\n                    return {seq: c.destChr, pos: dpos, flipped: (c.srcOri != c.destOri)}\n                }\n            }\n        }\n    }\n    return null;\n}\n\nChainset.prototype.mapSegment = function(chr, min, max) {\n    var chains = this.chainsBySrc[chr] || [];\n    var mappings = [];\n    for (var ci = 0; ci < chains.length; ++ci) {\n        var c = chains[ci];\n        if (max >= c.srcMin && min <= c.srcMax) {\n            var cmin, cmax;\n            if (c.srcOri == '-') {\n                cmin = c.srcMax - max;\n                cmax = c.srcMax - min;\n            } else {\n                cmin = min - c.srcMin;\n                cmax = max - c.srcMin;\n            }\n            var blocks = c.blocks;\n            for (var bi = 0; bi < blocks.length; ++bi) {\n                var b = blocks[bi];\n                var bSrc = b[0];\n                var bDest = b[1];\n                var bSize = b[2];\n                if (cmax >= bSrc && cmin <= (bSrc + bSize)) {\n                    var m = {\n                        segment: c.destChr,\n                        flipped: (c.srcOri == '-') ^ (c.destOri == '-')};\n\n                    if (c.destOri == '-') {\n                        if (cmin >= bSrc) {\n                            m.max = c.destMax - bDest - cmin + bSrc;\n                        } else {\n                            m.max = c.destMax - bDest;\n                            m.partialMax = bSrc - cmin;\n                        }\n                        if (cmax <= (bSrc + bSize)) {\n                            m.min = c.destMax - bDest - cmax + bSrc;\n                        } else {\n                            m.min = c.destMax - bDest - bSize;\n                            m.partialMin = cmax - bSrc - bSize;\n                        }\n                    } else {\n                        if (cmin >= bSrc) {\n                            m.min = c.destMin + bDest + cmin - bSrc;\n                        } else {\n                            m.min = c.destMin + bDest;\n                            m.partialMin = bSrc - cmin;\n                        }\n                        if (cmax <= (bSrc + bSize)) {\n                            m.max = c.destMin + bDest + cmax - bSrc;\n                        } else {\n                            m.max = c.destMin + bDest + bSize;\n                            m.partialMax = cmax - bSrc - bSize;\n                        }\n                    }\n                    mappings.push(m);\n                }\n            }\n        }\n    }\n    return mappings;\n}\n\nChainset.prototype.unmapPoint = function(chr, pos) {\n    var chains = this.chainsByDest[chr] || [];\n    for (var ci = 0; ci < chains.length; ++ci) {\n        var c = chains[ci];\n        if (pos >= c.destMin && pos <= c.destMax) {\n            var cpos;\n            if (c.srcOri == '-') {\n                cpos = c.destMax - pos;\n            } else {\n                cpos = pos - c.destMin;\n            }    \n            \n            var blocks = c.blocks;\n            for (var bi = 0; bi < blocks.length; ++bi) {\n                var b = blocks[bi];\n                var bSrc = b[0];\n                var bDest = b[1];\n                var bSize = b[2];\n\n                if (cpos >= bDest && cpos <= (bDest + bSize)) {\n                    var apos = cpos - bDest;\n\n                    var dpos = apos + bSrc + c.srcMin;\n                    var dpos;\n                    if (c.destOri == '-') {\n                        dpos = c.srcMax - bSrc - apos;\n                    } else {\n                        dpos = apos + bSrc + c.srcMin;\n                    }\n                    return {seq: c.srcChr, pos: dpos, flipped: (c.srcOri != c.destOri)}\n                }\n            }\n            // return null;\n        }\n    }\n    return null;\n}\n\nChainset.prototype.sourceBlocksForRange = function(chr, min, max, callback) {\n    var STATE_PENDING = 1;\n    var STATE_FETCHED = 2;\n\n    var thisCS = this;\n    var minTile = (min/this.granularity)|0;\n    var maxTile = (max/this.granularity)|0;\n\n    var needsNewOrPending = false;\n    var needsNewFetch = false;\n    for (var t = minTile; t <= maxTile; ++t) {\n        var tn = chr + '_' + t;\n        if (this.fetchedTiles[tn] != STATE_FETCHED) {\n            needsNewOrPending = true;\n            if (this.fetchedTiles[tn] != STATE_PENDING) {\n                this.fetchedTiles[tn] = STATE_PENDING;\n                needsNewFetch = true;\n            }\n        }\n    }\n\n    if (needsNewOrPending) {\n        if (!this.postFetchQueues[chr]) {\n            this.chainFetcher.fetchChains(\n                chr, \n                minTile * this.granularity, \n                (maxTile+1) * this.granularity - 1)\n              .then(function(chains) {\n                if (!thisCS.chainsByDest)\n                    thisCS.chainsByDest[chr] = [];\n                for (var ci = 0; ci < chains.length; ++ci) {\n                    var chain = chains[ci];\n\n                    {\n                        var cbs = thisCS.chainsBySrc[chain.srcChr];\n                        if (!cbs) {\n                            thisCS.chainsBySrc[chain.srcChr] = [chain];\n                        } else {\n                            var present = false;\n                            for (var oci = 0; oci < cbs.length; ++oci) {\n                                var oc = cbs[oci];\n                                if (oc.srcMin == chain.srcMin && oc.srcMax == chain.srcMax) {\n                                    present = true;\n                                    break;\n                                }\n                            }\n                            if (!present)\n                                cbs.push(chain);\n                        }\n                    }\n\n                    {\n                        var cbd = thisCS.chainsByDest[chain.destChr];\n                        if (!cbd) {\n                            thisCS.chainsByDest[chain.destChr] = [chain];\n                        } else {\n                            var present = false;\n                            for (var oci = 0; oci < cbd.length; ++oci) {\n                                var oc = cbd[oci];\n                                if (oc.destMin == chain.destMin && oc.destMax == chain.destMax) {\n                                    present = true;\n                                    break;\n                                }\n                            }\n                            if (!present)\n                                cbd.push(chain);\n                        }\n                    }\n                }\n                for (var t = minTile; t <= maxTile; ++t) {\n                    var tn = chr + '_' + t;\n                    thisCS.fetchedTiles[tn] = STATE_FETCHED;\n                }\n                if (thisCS.postFetchQueues[chr]) {\n                    var pfq = thisCS.postFetchQueues[chr];\n                    for (var i = 0; i < pfq.length; ++i) {\n                        pfq[i]();\n                    }\n                    thisCS.postFetchQueues[chr] = null;\n                }\n              }).catch(function (err) {\n                console.log(err);\n              });   \n        }\n\n        pusho(this.postFetchQueues, chr, function() {\n            // Will either succeed if the tiles that are needed have already been fetched,\n            // or queue up a new fetch.\n\n            thisCS.sourceBlocksForRange(chr, min, max, callback);\n        });\n    } else {\n        var srcBlocks = [];\n        var chains = this.chainsByDest[chr] || [];\n        for (var ci = 0; ci < chains.length; ++ci) {\n            var c = chains[ci];\n            if (min <= c.destMax && max >= c.destMin) {\n                var cmin, cmax;\n                if (c.srcOri == '-') {\n                    cmin = c.destMax - max;\n                    cmax = c.destMax - min;\n                } else {\n                    cmin = min - c.destMin;\n                    cmax = max - c.destMin;\n                }\n\n                var blocks = c.blocks;\n                for (var bi = 0; bi < blocks.length; ++bi) {\n                    var b = blocks[bi];\n                    var bSrc = b[0];\n                    var bDest = b[1];\n                    var bSize = b[2];\n\n                    if (cmax >= bDest && cmin <= (bDest + bSize)) {\n                        var amin = Math.max(cmin, bDest) - bDest;\n                        var amax = Math.min(cmax, bDest + bSize) - bDest;\n\n                        if (c.destOri == '-') {\n                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMax - bSrc - amax, c.srcMax - bSrc - amin));\n                        } else {\n                            srcBlocks.push(new DASSegment(c.srcChr, c.srcMin + amin + bSrc, c.srcMin + amax + bSrc));\n                        }\n                    }\n                }\n            }\n        }\n        callback(srcBlocks);\n    }\n}\n\nfunction DASChainFetcher(uri, srcTag, destTag) {\n    this.source = new DASSource(uri);\n    this.srcTag = srcTag;\n    this.destTag =destTag;\n}\n\nDASChainFetcher.prototype.fetchChains = function(chr, _min, _max) {\n    var thisCS = this;\n\n    return new Promise(function(resolve, reject) {\n        thisCS.source.alignments(chr, {}, function(aligns) {\n            var chains = [];\n\n            for (var ai = 0; ai < aligns.length; ++ai) {\n                var aln = aligns[ai];\n                for (var bi = 0; bi < aln.blocks.length; ++bi) {\n                    var block = aln.blocks[bi];\n                    var srcSeg, destSeg;\n                    for (var si = 0; si < block.segments.length; ++si) {\n                        var seg = block.segments[si];\n                        var obj = aln.objects[seg.object];\n                        if (obj.dbSource === thisCS.srcTag) {\n                            srcSeg = seg;\n                        } else if (obj.dbSource === thisCS.destTag) {\n                            destSeg = seg;\n                        }\n                    }\n                    if (srcSeg && destSeg) {\n                        var chain = {\n                            srcChr:     aln.objects[srcSeg.object].accession,\n                            srcMin:     srcSeg.min|0,\n                            srcMax:     srcSeg.max|0,\n                            srcOri:     srcSeg.strand,\n                            destChr:    aln.objects[destSeg.object].accession,\n                            destMin:    destSeg.min|0,\n                            destMax:    destSeg.max|0,\n                            destOri:    destSeg.strand,\n                            blocks:     []\n                        }\n\n                        var srcops = parseCigar(srcSeg.cigar), destops = parseCigar(destSeg.cigar);\n\n                        var srcOffset = 0, destOffset = 0;\n                        var srci = 0, desti = 0;\n                        while (srci < srcops.length && desti < destops.length) {\n                            if (srcops[srci].op == 'M' && destops[desti].op == 'M') {\n                                var blockLen = Math.min(srcops[srci].cnt, destops[desti].cnt);\n                                chain.blocks.push([srcOffset, destOffset, blockLen]);\n                                if (srcops[srci].cnt == blockLen) {\n                                    ++srci;\n                                } else {\n                                    srcops[srci].cnt -= blockLen;\n                                }\n                                if (destops[desti].cnt == blockLen) {\n                                    ++desti;\n                                } else {\n                                    destops[desti] -= blockLen;\n                                }\n                                srcOffset += blockLen;\n                                destOffset += blockLen;\n                            } else if (srcops[srci].op == 'I') {\n                                destOffset += srcops[srci++].cnt;\n                            } else if (destops[desti].op == 'I') {\n                                srcOffset += destops[desti++].cnt;\n                            }\n                        }\n\n                        chains.push(chain);\n                    }\n                }\n            }\n            resolve(chains);\n        });\n    });\n}\n\nfunction BBIChainFetcher(uri, credentials) {\n    var self = this;\n    this.uri = uri;\n    this.credentials = credentials;\n\n    this.bwg = new Promise(function(resolve, reject) {\n        makeBwg(new URLFetchable(self.uri, {credentials: self.credentials, \n                                            resolver: self.resolver}), \n          function(bwg, err) {\n            if (bwg) {\n                resolve(bwg);\n            } else {\n                reject(err);\n            }\n          });\n    });\n\n    this.bwg.then(function(bwg, err) {\n        if (err)\n            console.log(err);\n    });\n}\n\nfunction pi(x) {\n    return parseInt(x);\n}\n\nfunction cleanChr(c) {\n    if (c.indexOf('chr') == 0)\n        return c.substr(3);\n    else\n        return c;\n}\n\nfunction bbiFeatureToChain(feature) {\n    var chain = {\n        srcChr:     cleanChr(feature.srcChrom),\n        srcMin:     parseInt(feature.srcStart),\n        srcMax:     parseInt(feature.srcEnd),\n        srcOri:     feature.srcOri,\n        destChr:    cleanChr(feature.segment),\n        destMin:    feature.min - 1,     // Convert back from bigbed parser\n        destMax:    feature.max,\n        destOri:    feature.ori,\n        blocks:     []\n    };\n    var srcStarts = feature.srcStarts.split(',').map(pi);\n    var destStarts = feature.destStarts.split(',').map(pi);\n    var blockLengths = feature.blockLens.split(',').map(pi);\n    for (var bi = 0; bi < srcStarts.length; ++bi) {\n        chain.blocks.push([srcStarts[bi], destStarts[bi], blockLengths[bi]]);\n    }\n\n    return chain;\n}\n\nBBIChainFetcher.prototype.fetchChains = function(chr, min, max) {\n    return this.bwg.then(function(bwg, err) {\n        if (!bwg)\n            throw Error(\"No BWG\");\n\n        return new Promise(function(resolve, reject) {\n            bwg.getUnzoomedView().readWigData(chr, min, max, function(feats) {\n                resolve(feats.map(bbiFeatureToChain));\n            });\n        });\n    });\n};\n\nfunction AliasChainFetcher(conf) {\n    this.conf = conf;\n    this.forwardAliases = {};\n    var sa = conf.sequenceAliases || [];\n    for (var ai = 0; ai < sa.length; ++ai) {\n        var al = sa[ai];\n        if (al.length < 2)\n            continue;\n\n        var fa = [];\n        for (var i = 0; i < al.length - 1; ++i)\n            fa.push(al[i]);\n        this.forwardAliases[al[al.length - 1]] = fa;\n    }\n}\n\nAliasChainFetcher.prototype.fetchChains = function(chr, min, max) {\n    var resp = [];\n    var fa = this.forwardAliases[chr] || [];\n    for (var i = 0; i < fa.length; ++i) {\n        resp.push(\n            {\n                srcChr:         fa[i],\n                srcMin:         1,\n                srcMax:         1000000000,\n                srcOri:         '+',\n                destChr:        chr,\n                destMin:        1,\n                destMax:        1000000000,\n                destOri:        '+',\n                blocks: [[1, 1, 1000000000]]\n            });\n    }\n\n    return Promise.resolve(resp);\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        Chainset: Chainset\n    };\n}\n","\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// chainset.js: liftover support\n//\n\nvar CIGAR_REGEXP = new RegExp('([0-9]*)([MIDS])', 'g');\n\nfunction parseCigar(cigar)\n{\n    var cigops = [];\n    var match;\n    while ((match = CIGAR_REGEXP.exec(cigar)) != null) {\n        var count = match[1];\n        if (count.length == 0) {\n            count = 1;\n        }\n        cigops.push({cnt: count|0, op: match[2]});\n    }\n    return cigops;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        parseCigar: parseCigar\n    };\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// color.js\n//\n\n\"use strict\";\n\nfunction DColour(red, green, blue, name) {\n    this.red = red|0;\n    this.green = green|0;\n    this.blue = blue|0;\n    if (name) {\n        this.name = name;\n    }\n}\n\nDColour.prototype.toSvgString = function() {\n    if (!this.name) {\n        this.name = \"rgb(\" + this.red + \",\" + this.green + \",\" + this.blue + \")\";\n    }\n\n    return this.name;\n}\n\nfunction hex2(x) {\n    var y = '00' + x.toString(16);\n    return y.substring(y.length - 2);\n}\n\nDColour.prototype.toHexString = function() {\n    return '#' + hex2(this.red) + hex2(this.green) + hex2(this.blue);\n}\n\nvar palette = {\n    red: new DColour(255, 0, 0, 'red'),\n    green: new DColour(0, 255, 0, 'green'),\n    blue: new DColour(0, 0, 255, 'blue'),\n    yellow: new DColour(255, 255, 0, 'yellow'),\n    white: new DColour(255, 255, 255, 'white'),\n    black: new DColour(0, 0, 0, 'black'),\n    gray: new DColour(180, 180, 180, 'gray'),\n    grey: new DColour(180, 180, 180, 'grey'),\n    lightskyblue: new DColour(135, 206, 250, 'lightskyblue'),\n    lightsalmon: new DColour(255, 160, 122, 'lightsalmon'),\n    hotpink: new DColour(255, 105, 180, 'hotpink')\n};\n\nvar COLOR_RE = new RegExp('^#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})$');\nvar CSS_COLOR_RE = /rgb\\(([0-9]+),([0-9]+),([0-9]+)\\)/\n\nfunction dasColourForName(name) {\n    var c = palette[name];\n    if (!c) {\n        var match = COLOR_RE.exec(name);\n        if (match) {\n            c = new DColour(('0x' + match[1])|0, ('0x' + match[2])|0, ('0x' + match[3])|0, name);\n            palette[name] = c;\n        } else {\n    \t    match = CSS_COLOR_RE.exec(name);\n    \t    if (match) {\n        \t\tc = new DColour(match[1]|0, match[2]|0, match[3]|0, name);\n        \t\tpalette[name] = c;\n\t       } else {\n\t\t      console.log(\"couldn't handle color: \" + name);\n\t\t      c = palette.black;\n\t\t      palette[name] = c;\n\t       }\n        }\n    }\n    return c;\n}\n\nfunction makeColourSteps(steps, stops, colours) {\n    var dcolours = [];\n    for (var ci = 0; ci < colours.length; ++ci) {\n        dcolours.push(dasColourForName(colours[ci]));\n    }\n\n    var grad = [];\n  STEP_LOOP:\n    for (var si = 0; si < steps; ++si) {\n        var rs = (1.0 * si) / (steps-1);\n        var score = stops[0] + (stops[stops.length -1] - stops[0]) * rs;\n        for (var i = 0; i < stops.length - 1; ++i) {\n            if (score >= stops[i] && score <= stops[i+1]) {\n                var frac = (score - stops[i]) / (stops[i+1] - stops[i]);\n                var ca = dcolours[i];\n                var cb = dcolours[i+1];\n\n                var fill = new DColour(\n                    ((ca.red * (1.0 - frac)) + (cb.red * frac))|0,\n                    ((ca.green * (1.0 - frac)) + (cb.green * frac))|0,\n                    ((ca.blue * (1.0 - frac)) + (cb.blue * frac))|0\n                ).toSvgString();\n                grad.push(fill);\n\n                continue STEP_LOOP;\n            }\n        }\n        throw 'Bad step';\n    }\n\n    return grad;\n}\n\nfunction makeGradient(steps, color1, color2, color3) {\n    if (color3) {\n        return makeColourSteps(steps, [0, 0.5, 1], [color1, color2, color3]);\n    } else {\n        return makeColourSteps(steps, [0, 1], [color1, color2]);\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeColourSteps: makeColourSteps,\n        makeGradient: makeGradient,\n        dasColourForName: dasColourForName\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// das.js: queries and low-level data model.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n    var pusho = utils.pusho;\n\n    var color = require('./color');\n    var makeColourSteps = color.makeColourSteps;\n}\n\nvar dasLibErrorHandler = function(errMsg) {\n    alert(errMsg);\n}\nvar dasLibRequestQueue = new Array();\n\nfunction DASSegment(name, start, end, description) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.description = description;\n}\nDASSegment.prototype.toString = function() {\n    return this.name + ':' + this.start + '..' + this.end;\n};\nDASSegment.prototype.isBounded = function() {\n    return this.start && this.end;\n}\nDASSegment.prototype.toDASQuery = function() {\n    var q = 'segment=' + this.name;\n    if (this.start && this.end) {\n        q += (':' + this.start + ',' + this.end);\n    }\n    return q;\n}\n\n\nfunction DASSource(a1, a2) {\n    var options;\n    if (typeof a1 == 'string') {\n        this.uri = a1;\n        options = a2 || {};\n    } else {\n        options = a1 || {};\n    }\n    for (var k in options) {\n        this[k] = options[k];\n    }\n\n    if (!this.coords) {\n        this.coords = [];\n    }\n    if (!this.props) {\n        this.props = {};\n    }\n\n    this.dasBaseURI = this.uri;\n    if (this.dasBaseURI && this.dasBaseURI.substr(this.uri.length - 1) != '/') {\n        this.dasBaseURI = this.dasBaseURI + '/';\n    }\n}\n\nDASSource.prototype.getURI = function(uri) {\n    if (this.resolver) {\n        return this.resolver(uri).then(function (urlOrObj) {\n            if (typeof urlOrObj === 'string') {\n                return urlOrObj;\n            } else {\n                return urlOrObj.url;\n            }\n        });\n    } else {\n        return Promise.resolve(uri);\n    }\n}\n\nfunction DASCoords() {\n}\n\nfunction coordsMatch(c1, c2) {\n    return c1.taxon == c2.taxon && c1.auth == c2.auth && c1.version == c2.version;\n}\n\n//\n// DAS 1.6 entry_points command\n//\n\nDASSource.prototype.entryPoints = function(callback) {\n    var dasURI = this.dasBaseURI + 'entry_points';\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n            if (!responseXML) {\n                return callback([]);\n            }\n\n                var entryPoints = new Array();\n                \n                var segs = responseXML.getElementsByTagName('SEGMENT');\n                for (var i = 0; i < segs.length; ++i) {\n                    var seg = segs[i];\n                    var segId = seg.getAttribute('id');\n                    \n                    var segSize = seg.getAttribute('size');\n                    var segMin, segMax;\n                    if (segSize) {\n                        segMin = 1; segMax = segSize|0;\n                    } else {\n                        segMin = seg.getAttribute('start');\n                        if (segMin) {\n                            segMin |= 0;\n                        }\n                        segMax = seg.getAttribute('stop');\n                        if (segMax) {\n                            segMax |= 0;\n                        }\n                    }\n                    var segDesc = null;\n                    if (seg.firstChild) {\n                        segDesc = seg.firstChild.nodeValue;\n                    }\n                    entryPoints.push(new DASSegment(segId, segMin, segMax, segDesc));\n                }          \n               callback(entryPoints);\n    });         \n}\n\n//\n// DAS 1.6 sequence command\n// Do we need an option to fall back to the dna command?\n//\n\nfunction DASSequence(name, start, end, alpha, seq) {\n    this.name = name;\n    this.start = start;\n    this.end = end;\n    this.alphabet = alpha;\n    this.seq = seq;\n}\n\nDASSource.prototype.sequence = function(segment, callback) {\n    var dasURI = this.dasBaseURI + 'sequence?' + segment.toDASQuery();\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n        if (!responseXML) {\n            callback([]);\n            return;\n        } else {\n                var seqs = new Array();\n                \n                var segs = responseXML.getElementsByTagName('SEQUENCE');\n                for (var i = 0; i < segs.length; ++i) {\n                    var seg = segs[i];\n                    var segId = seg.getAttribute('id');\n                    var segMin = seg.getAttribute('start');\n                    var segMax = seg.getAttribute('stop');\n                    var segAlpha = 'DNA';\n                    var segSeq = null;\n                    if (seg.firstChild) {\n                        var rawSeq = seg.firstChild.nodeValue;\n                        segSeq = '';\n                        var idx = 0;\n                        while (true) {\n                            var space = rawSeq.indexOf('\\n', idx);\n                            if (space >= 0) {\n                                segSeq += rawSeq.substring(idx, space).toUpperCase();\n                                idx = space + 1;\n                            } else {\n                                segSeq += rawSeq.substring(idx).toUpperCase();\n                                break;\n                            }\n                        }\n                    }\n                    seqs.push(new DASSequence(segId, segMin, segMax, segAlpha, segSeq));\n                }\n                \n                callback(seqs);\n        }\n    });\n}\n\n//\n// DAS 1.6 features command\n//\n\nfunction DASFeature() {\n}\n\nfunction DASGroup(id) {\n    if (id)\n        this.id = id;\n}\n\nfunction DASLink(desc, uri) {\n    this.desc = desc;\n    this.uri = uri;\n}\n\nDASSource.prototype.features = function(segment, options, callback) {\n    options = options || {};\n    var thisB = this;\n\n    var dasURI;\n    if (this.features_uri) {\n        dasURI = this.features_uri;\n    } else {\n        var filters = [];\n\n        if (segment) {\n            filters.push(segment.toDASQuery());\n        } else if (options.group) {\n            var g = options.group;\n            if (typeof g == 'string') {\n                filters.push('group_id=' + g);\n            } else {\n                for (var gi = 0; gi < g.length; ++gi) {\n                    filters.push('group_id=' + g[gi]);\n                }\n            }\n        }\n\n        if (options.adjacent) {\n            var adj = options.adjacent;\n            if (typeof adj == 'string') {\n                adj = [adj];\n            }\n            for (var ai = 0; ai < adj.length; ++ai) {\n                filters.push('adjacent=' + adj[ai]);\n            }\n        }\n\n        if (options.type) {\n            if (typeof options.type == 'string') {\n                filters.push('type=' + options.type);\n            } else {\n                for (var ti = 0; ti < options.type.length; ++ti) {\n                    filters.push('type=' + options.type[ti]);\n                }\n            }\n        }\n        \n        if (options.maxbins) {\n            filters.push('maxbins=' + options.maxbins);\n        }\n        \n        if (filters.length > 0) {\n            dasURI = this.dasBaseURI + 'features?' + filters.join(';');\n        } else {\n            callback([], 'No filters specified');\n        }\n    } \n   \n\n    this.doCrossDomainRequest(dasURI, function(responseXML, req) {\n        if (!responseXML) {\n            var msg;\n            if (req.status == 0) {\n                msg = 'server may not support CORS';\n            } else {\n                msg = 'status=' + req.status;\n            }\n            callback([], 'Failed request: ' + msg);\n            return;\n        }\n/*      if (req) {\n            var caps = req.getResponseHeader('X-DAS-Capabilties');\n            if (caps) {\n                alert(caps);\n            }\n        } */\n\n        var features = new Array();\n        var segmentMap = {};\n\n        var segs = responseXML.getElementsByTagName('SEGMENT');\n        for (var si = 0; si < segs.length; ++si) {\n            var segmentXML = segs[si];\n            var segmentID = segmentXML.getAttribute('id');\n            segmentMap[segmentID] = {\n                min: segmentXML.getAttribute('start'),\n                max: segmentXML.getAttribute('stop')\n            };\n            \n            var featureXMLs = segmentXML.getElementsByTagName('FEATURE');\n            for (var i = 0; i < featureXMLs.length; ++i) {\n                var feature = featureXMLs[i];\n                var dasFeature = new DASFeature();\n                \n                dasFeature.segment = segmentID;\n                dasFeature.id = feature.getAttribute('id');\n                dasFeature.label = feature.getAttribute('label');\n\n\n/*\n                var childNodes = feature.childNodes;\n                for (var c = 0; c < childNodes.length; ++c) {\n                    var cn = childNodes[c];\n                    if (cn.nodeType == Node.ELEMENT_NODE) {\n                        var key = cn.tagName;\n                        //var val = null;\n                        //if (cn.firstChild) {\n                        //   val = cn.firstChild.nodeValue;\n                        //}\n                        dasFeature[key] = 'x';\n                    }\n                } */\n\n\n                var spos = elementValue(feature, \"START\");\n                var epos = elementValue(feature, \"END\");\n                if ((spos|0) > (epos|0)) {\n                    dasFeature.min = epos|0;\n                    dasFeature.max = spos|0;\n                } else {\n                    dasFeature.min = spos|0;\n                    dasFeature.max = epos|0;\n                }\n                {\n                    var tec = feature.getElementsByTagName('TYPE');\n                    if (tec.length > 0) {\n                        var te = tec[0];\n                        if (te.firstChild) {\n                            dasFeature.type = te.firstChild.nodeValue;\n                        }\n                        dasFeature.typeId = te.getAttribute('id');\n                        dasFeature.typeCv = te.getAttribute('cvId');\n                    }\n                }\n                dasFeature.type = elementValue(feature, \"TYPE\");\n                if (!dasFeature.type && dasFeature.typeId) {\n                    dasFeature.type = dasFeature.typeId; // FIXME?\n                }\n                \n                dasFeature.method = elementValue(feature, \"METHOD\");\n                {\n                    var ori = elementValue(feature, \"ORIENTATION\");\n                    if (!ori) {\n                        ori = '0';\n                    }\n                    dasFeature.orientation = ori;\n                }\n                dasFeature.score = elementValue(feature, \"SCORE\");\n                dasFeature.links = dasLinksOf(feature);\n                dasFeature.notes = dasNotesOf(feature);\n                \n                var groups = feature.getElementsByTagName(\"GROUP\");\n                for (var gi  = 0; gi < groups.length; ++gi) {\n                    var groupXML = groups[gi];\n                    var dasGroup = new DASGroup();\n                    dasGroup.type = groupXML.getAttribute('type');\n                    dasGroup.id = groupXML.getAttribute('id');\n                    dasGroup.links = dasLinksOf(groupXML);\n                    dasGroup.notes = dasNotesOf(groupXML);\n                    if (!dasFeature.groups) {\n                        dasFeature.groups = new Array(dasGroup);\n                    } else {\n                        dasFeature.groups.push(dasGroup);\n                    }\n                }\n\n                // Magic notes.  Check with TAD before changing this.\n                if (dasFeature.notes) {\n                    for (var ni = 0; ni < dasFeature.notes.length; ++ni) {\n                        var n = dasFeature.notes[ni];\n                        if (n.indexOf('Genename=') == 0) {\n                            var gg = new DASGroup();\n                            gg.type='gene';\n                            gg.id = n.substring(9);\n                            if (!dasFeature.groups) {\n                                dasFeature.groups = new Array(gg);\n                            } else {\n                                dasFeature.groups.push(gg);\n                            }\n                        }\n                    }\n                }\n                \n                {\n                    var pec = feature.getElementsByTagName('PART');\n                    if (pec.length > 0) {\n                        var parts = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parts.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parts = parts;\n                    }\n                }\n                {\n                    var pec = feature.getElementsByTagName('PARENT');\n                    if (pec.length > 0) {\n                        var parents = [];\n                        for (var pi = 0; pi < pec.length; ++pi) {\n                            parents.push(pec[pi].getAttribute('id'));\n                        }\n                        dasFeature.parents = parents;\n                    }\n                }\n                \n                features.push(dasFeature);\n            }\n        }\n                \n        callback(features, undefined, segmentMap);\n    },\n    function (err) {\n        callback([], err);\n    });\n}\n\nfunction DASAlignment(type) {\n    this.type = type;\n    this.objects = {};\n    this.blocks = [];\n}\n\nDASSource.prototype.alignments = function(segment, options, callback) {\n    var dasURI = this.dasBaseURI + 'alignment?query=' + segment;\n    this.doCrossDomainRequest(dasURI, function(responseXML) {\n        if (!responseXML) {\n            callback([], 'Failed request ' + dasURI);\n            return;\n        }\n\n        var alignments = [];\n        var aliXMLs = responseXML.getElementsByTagName('alignment');\n        for (var ai = 0; ai < aliXMLs.length; ++ai) {\n            var aliXML = aliXMLs[ai];\n            var ali = new DASAlignment(aliXML.getAttribute('alignType'));\n            var objXMLs = aliXML.getElementsByTagName('alignObject');\n            for (var oi = 0; oi < objXMLs.length; ++oi) {\n                var objXML = objXMLs[oi];\n                var obj = {\n                    id:          objXML.getAttribute('intObjectId'),\n                    accession:   objXML.getAttribute('dbAccessionId'),\n                    version:     objXML.getAttribute('objectVersion'),\n                    dbSource:    objXML.getAttribute('dbSource'),\n                    dbVersion:   objXML.getAttribute('dbVersion')\n                };\n                ali.objects[obj.id] = obj;\n            }\n            \n            var blockXMLs = aliXML.getElementsByTagName('block');\n            for (var bi = 0; bi < blockXMLs.length; ++bi) {\n                var blockXML = blockXMLs[bi];\n                var block = {\n                    order:      blockXML.getAttribute('blockOrder'),\n                    segments:   []\n                };\n                var segXMLs = blockXML.getElementsByTagName('segment');\n                for (var si = 0; si < segXMLs.length; ++si) {\n                    var segXML = segXMLs[si];\n                    var seg = {\n                        object:      segXML.getAttribute('intObjectId'),\n                        min:         segXML.getAttribute('start'),\n                        max:         segXML.getAttribute('end'),\n                        strand:      segXML.getAttribute('strand'),\n                        cigar:       elementValue(segXML, 'cigar')\n                    };\n                    block.segments.push(seg);\n                }\n                ali.blocks.push(block);\n            }       \n                    \n            alignments.push(ali);\n        }\n        callback(alignments);\n    });\n}\n\n\nfunction DASStylesheet() {\n    this.styles = [];\n}\n\nDASStylesheet.prototype.pushStyle = function(filters, zoom, style) {\n    if (!filters) {\n        filters = {type: 'default'};\n    }\n    var styleHolder = shallowCopy(filters);\n    if (zoom) {\n        styleHolder.zoom = zoom;\n    }\n    styleHolder.style = style;\n    this.styles.push(styleHolder);\n}\n\nfunction DASStyle() {\n}\n\nfunction parseGradient(grad) {\n    var steps = grad.getAttribute('steps');\n    if (steps) {\n        steps = steps|0;\n    } else {\n        steps = 50;\n    }\n\n    var stops = [];\n    var colors = [];\n    var se = grad.getElementsByTagName('STOP');\n    for (var si = 0; si < se.length; ++si) {\n        var stop = se[si];\n        stops.push(1.0 * stop.getAttribute('score'));\n        colors.push(stop.firstChild.nodeValue);\n    }\n\n    return makeColourSteps(steps, stops, colors);\n}\n\nDASSource.prototype.stylesheet = function(successCB, failureCB) {\n    var dasURI, creds = this.credentials;\n    if (this.stylesheet_uri) {\n        dasURI = this.stylesheet_uri;\n        creds = false;\n    } else {\n        dasURI = this.dasBaseURI + 'stylesheet';\n    }\n\n    this.getURI(dasURI).then(function(dasURI) {\n        doCrossDomainRequest(dasURI, function(responseXML) {\n            if (!responseXML) {\n                if (failureCB) {\n                    failureCB();\n                } \n                return;\n            }\n            var stylesheet = new DASStylesheet();\n            var typeXMLs = responseXML.getElementsByTagName('TYPE');\n            for (var i = 0; i < typeXMLs.length; ++i) {\n                var typeStyle = typeXMLs[i];\n            \n                var filter = {};\n                filter.type = typeStyle.getAttribute('id'); // Am I right in thinking that this makes DASSTYLE XML invalid?  Ugh.\n                filter.label = typeStyle.getAttribute('label');\n                filter.method = typeStyle.getAttribute('method');\n                var glyphXMLs = typeStyle.getElementsByTagName('GLYPH');\n                for (var gi = 0; gi < glyphXMLs.length; ++gi) {\n                    var glyphXML = glyphXMLs[gi];\n                    var zoom = glyphXML.getAttribute('zoom');\n                    var glyph = childElementOf(glyphXML);\n                    var style = new DASStyle();\n                    style.glyph = glyph.localName;\n                    var child = glyph.firstChild;\n                    \n                    while (child) {\n                        if (child.nodeType == Node.ELEMENT_NODE) {\n                            if (child.localName == 'BGGRAD') {\n                                style[child.localName] = parseGradient(child);\n                            } else {      \n                                style[child.localName] = child.firstChild.nodeValue;\n                            }\n                        }\n                        child = child.nextSibling;\n                    }\n                    stylesheet.pushStyle(filter, zoom, style);\n                }\n            }\n            successCB(stylesheet);\n        }, creds);\n    }).catch(function(err) {\n        console.log(err);\n        failureCB();\n    });\n}\n\n//\n// sources command\n// \n\nfunction DASRegistry(uri, opts)\n{\n    opts = opts || {};\n    this.uri = uri;\n    this.opts = opts;   \n}\n\nDASRegistry.prototype.sources = function(callback, failure, opts)\n{\n    if (!opts) {\n        opts = {};\n    }\n\n    var filters = [];\n    if (opts.taxon) {\n        filters.push('organism=' + opts.taxon);\n    }\n    if (opts.auth) {\n        filters.push('authority=' + opts.auth);\n    }\n    if (opts.version) {\n        filters.push('version=' + opts.version);\n    }\n    var quri = this.uri;\n    if (filters.length > 0) {\n        quri = quri + '?' + filters.join('&');   // '&' as a separator to hack around dasregistry.org bug.\n    }\n\n    doCrossDomainRequest(quri, function(responseXML) {\n        if (!responseXML && failure) {\n            failure();\n            return;\n        }\n\n        var sources = [];       \n        var sourceXMLs = responseXML.getElementsByTagName('SOURCE');\n        for (var si = 0; si < sourceXMLs.length; ++si) {\n            var sourceXML = sourceXMLs[si];\n            var versionXMLs = sourceXML.getElementsByTagName('VERSION');\n            if (versionXMLs.length < 1) {\n                continue;\n            }\n            var versionXML = versionXMLs[0];\n\n            var coordXMLs = versionXML.getElementsByTagName('COORDINATES');\n            var coords = [];\n            for (var ci = 0; ci < coordXMLs.length; ++ci) {\n                var coordXML = coordXMLs[ci];\n                var coord = new DASCoords();\n                coord.auth = coordXML.getAttribute('authority');\n                coord.taxon = coordXML.getAttribute('taxid');\n                coord.version = coordXML.getAttribute('version');\n                coords.push(coord);\n            }\n            \n            var caps = [];\n            var capXMLs = versionXML.getElementsByTagName('CAPABILITY');\n            var uri;\n            for (var ci = 0; ci < capXMLs.length; ++ci) {\n                var capXML = capXMLs[ci];\n                \n                caps.push(capXML.getAttribute('type'));\n\n                if (capXML.getAttribute('type') == 'das1:features') {\n                    var fep = capXML.getAttribute('query_uri');\n                    uri = fep.substring(0, fep.length - ('features'.length));\n                }\n            }\n\n            var props = {};\n            var propXMLs = versionXML.getElementsByTagName('PROP');\n            for (var pi = 0; pi < propXMLs.length; ++pi) {\n                pusho(props, propXMLs[pi].getAttribute('name'), propXMLs[pi].getAttribute('value'));\n            }\n            \n            if (uri) {\n                var source = new DASSource(uri, {\n                    source_uri: sourceXML.getAttribute('uri'),\n                    name:  sourceXML.getAttribute('title'),\n                    desc:  sourceXML.getAttribute('description'),\n                    coords: coords,\n                    props: props,\n                    capabilities: caps\n                });\n                sources.push(source);\n            }\n        }\n        \n        callback(sources);\n    });\n}\n\n\n//\n// Utility functions\n//\n\nfunction elementValue(element, tag)\n{\n    var children = element.getElementsByTagName(tag);\n    if (children.length > 0 && children[0].firstChild) {\n        var c = children[0];\n        if (c.childNodes.length == 1) {\n            return c.firstChild.nodeValue;\n        } else {\n            var s = '';\n            for (var ni = 0; ni < c.childNodes.length; ++ni) {\n                s += c.childNodes[ni].nodeValue;\n            }\n            return s;\n        }\n\n    } else {\n        return null;\n    }\n}\n\nfunction childElementOf(element)\n{\n    if (element.hasChildNodes()) {\n        var child = element.firstChild;\n        do {\n            if (child.nodeType == Node.ELEMENT_NODE) {\n                return child;\n            } \n            child = child.nextSibling;\n        } while (child != null);\n    }\n    return null;\n}\n\n\nfunction dasLinksOf(element)\n{\n    var links = new Array();\n    var maybeLinkChilden = element.getElementsByTagName('LINK');\n    for (var ci = 0; ci < maybeLinkChilden.length; ++ci) {\n        var linkXML = maybeLinkChilden[ci];\n        if (linkXML.parentNode == element) {\n            links.push(new DASLink(linkXML.firstChild ? linkXML.firstChild.nodeValue : 'Unknown', linkXML.getAttribute('href')));\n        }\n    }\n    \n    return links;\n}\n\nfunction dasNotesOf(element)\n{\n    var notes = [];\n    var maybeNotes = element.getElementsByTagName('NOTE');\n    for (var ni = 0; ni < maybeNotes.length; ++ni) {\n        if (maybeNotes[ni].firstChild) {\n            notes.push(maybeNotes[ni].firstChild.nodeValue);\n        }\n    }\n    return notes;\n}\n\nfunction doCrossDomainRequest(url, handler, credentials, custAuth) {\n    // TODO: explicit error handlers?\n\n    if (window.XDomainRequest) {\n        var req = new XDomainRequest();\n        req.onload = function() {\n            var dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n            dom.async = false;\n            dom.loadXML(req.responseText);\n            handler(dom);\n        }\n        req.open(\"get\", url);\n        req.send('');\n    } else {\n        try {\n            var req = new XMLHttpRequest();\n            var timeout = setTimeout(\n                function() {\n                    console.log('timing out '  + url);\n                    req.abort();\n                    handler(null, req);\n                },\n                5000\n            );\n\n            req.ontimeout = function() {\n                console.log('timeout on ' + url);\n            };\n\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    clearTimeout(timeout);\n                    if (req.status >= 200 || req.status == 0) {\n                        handler(req.responseXML, req);\n                    }\n                }\n            };\n            req.open(\"get\", url, true);\n            // IE10/11 fix: The timeout property may be set only in the time interval between a call to the open method\n            //              and the first call to the send method.\n            req.timeout = 5000;\n            if (credentials) {\n                req.withCredentials = true;\n            }\n            if (custAuth) {\n                req.setRequestHeader('X-DAS-Authorisation', custAuth);\n            }\n            req.overrideMimeType('text/xml');\n            req.setRequestHeader('Accept', 'application/xml,*/*');\n            req.send('');\n        } catch (e) {\n            handler(null, req, e);\n        }\n    }\n}\n\nDASSource.prototype.doCrossDomainRequest = function(url, handler, errHandler) {\n    var custAuth;\n    if (this.xUser) {\n        custAuth = 'Basic ' + btoa(this.xUser + ':' + this.xPass);\n    }\n\n    try {\n        return doCrossDomainRequest(url, handler, this.credentials, custAuth);\n    } catch (err) {\n        if (errHandler) {\n            errHandler(err);\n        } else {\n            throw err;\n        }\n    }\n}\n\nfunction isDasBooleanTrue(s) {\n    s = ('' + s).toLowerCase();\n    return s==='yes' || s==='true';\n}\n\nfunction isDasBooleanNotFalse(s) {\n    if (!s)\n        return false;\n\n    s = ('' + s).toLowerCase();\n    return s!=='no' || s!=='false';\n}\n\nfunction copyStylesheet(ss) {\n    var nss = shallowCopy(ss);\n    nss.styles = [];\n    for (var si = 0; si < ss.styles.length; ++si) {\n        var sh = nss.styles[si] = shallowCopy(ss.styles[si]);\n        sh._methodRE = sh._labelRE = sh._typeRE = undefined;\n        sh.style = shallowCopy(sh.style);\n        sh.style.id = undefined;\n        sh.style._gradient = undefined;\n    }\n    return nss;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        DASGroup: DASGroup,\n        DASFeature: DASFeature,\n        DASStylesheet: DASStylesheet,\n        DASStyle: DASStyle,\n        DASSource: DASSource,\n        DASSegment: DASSegment,\n        DASRegistry: DASRegistry,\n        DASSequence: DASSequence,\n        DASLink: DASLink,\n\n        isDasBooleanTrue: isDasBooleanTrue,\n        isDasBooleanNotFalse: isDasBooleanNotFalse,\n        copyStylesheet: copyStylesheet,\n        coordsMatch: coordsMatch\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// domui.js: SVG UI components\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n}\n\nBrowser.prototype.removeAllPopups = function() {\n    removeChildren(this.hPopupHolder);\n    removeChildren(this.popupHolder);\n}\n\nBrowser.prototype.makeTooltip = function(ele, text)\n{\n    var isin = false;\n    var thisB = this;\n    var timer = null;\n    var outlistener;\n    outlistener = function(ev) {\n        isin = false;\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n        ele.removeEventListener('mouseout', outlistener, false);\n    };\n\n    var setup = function(ev) {\n        var mx = ev.clientX + window.scrollX, my = ev.clientY + window.scrollY;\n        if (!timer) {\n            timer = setTimeout(function() {\n                var ttt;\n                if (typeof(text) === 'function') {\n                    ttt = text();\n                } else {\n                    ttt = text;\n                }\n\n                var popup = makeElement('div',\n                    [makeElement('div', null, {className: 'tooltip-arrow'}),\n                     makeElement('div', ttt, {className: 'tooltip-inner'})], \n                    {className: 'tooltip bottom in'}, {\n                    display: 'block',\n                    top: '' + (my + 20) + 'px',\n                    left: '' + Math.max(mx - 30, 20) + 'px'\n                });\n                thisB.hPopupHolder.appendChild(popup);\n                var moveHandler;\n                moveHandler = function(ev) {\n                    try {\n                        thisB.hPopupHolder.removeChild(popup);\n                    } catch (e) {\n                        // May have been removed by other code which clears the popup layer.\n                    }\n                    window.removeEventListener('mousemove', moveHandler, false);\n                    if (isin) {\n                        if (ele.offsetParent == null) {\n                        } else {\n                            setup(ev);\n                        }\n                    }\n                }\n                window.addEventListener('mousemove', moveHandler, false);\n                timer = null;\n            }, 1000);\n        }\n    };\n\n    ele.addEventListener('mouseover', function(ev) {\n        isin = true\n        ele.addEventListener('mouseout', outlistener, false);\n        setup(ev);\n    }, false);\n    ele.addEventListener('DOMNodeRemovedFromDocument', function(ev) {\n        isin = false;\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }, false);\n}\n\nBrowser.prototype.popit = function(ev, name, ele, opts)\n{\n    var thisB = this;\n    if (!opts) \n        opts = {};\n    if (!ev) \n        ev = {};\n\n    var width = opts.width || 200;\n\n    var mx, my;\n\n    if (ev.clientX) {\n        var mx =  ev.clientX, my = ev.clientY;\n    } else {\n        mx = 500; my= 50;\n    }\n    mx +=  document.documentElement.scrollLeft || document.body.scrollLeft;\n    my +=  document.documentElement.scrollTop || document.body.scrollTop;\n    var winWidth = window.innerWidth;\n\n    var top = my;\n    var left = Math.min(mx - (width/2) - 4, (winWidth - width - 30));\n\n    var popup = makeElement('div');\n    popup.className = 'popover fade ' + (ev.clientX ? 'bottom ' : '') + 'in';\n    popup.style.display = 'block';\n    popup.style.position = 'absolute';\n    popup.style.top = '' + top + 'px';\n    popup.style.left = '' + left + 'px';\n    popup.style.width = width + 'px';\n    if (width > 276) {\n        // HACK Bootstrappification...\n        popup.style.maxWidth = width + 'px';\n    }\n\n    popup.appendChild(makeElement('div', null, {className: 'arrow'}));\n\n    if (name) {\n        var closeButton = makeElement('button', '', {className: 'close'});\n        closeButton.innerHTML = '&times;'\n\n        closeButton.addEventListener('mouseover', function(ev) {\n            closeButton.style.color = 'red';\n        }, false);\n        closeButton.addEventListener('mouseout', function(ev) {\n            closeButton.style.color = 'black';\n        }, false);\n        closeButton.addEventListener('click', function(ev) {\n            ev.preventDefault(); ev.stopPropagation();\n            thisB.removeAllPopups();\n        }, false);\n        var tbar = makeElement('h4', [makeElement('span', name, null, {maxWidth: '200px'}), closeButton], {/*className: 'popover-title' */}, {paddingLeft: '10px', paddingRight: '10px'});\n\n        var dragOX, dragOY;\n        var moveHandler, upHandler;\n        moveHandler = function(ev) {\n            ev.stopPropagation(); ev.preventDefault();\n            left = left + (ev.clientX - dragOX);\n            if (left < 8) {\n                left = 8;\n            } if (left > (winWidth - width - 32)) {\n                left = (winWidth - width - 26);\n            }\n            top = top + (ev.clientY - dragOY);\n            top = Math.max(10, top);\n            popup.style.top = '' + top + 'px';\n            popup.style.left = '' + Math.min(left, (winWidth - width - 10)) + 'px';\n            dragOX = ev.clientX; dragOY = ev.clientY;\n        }\n        upHandler = function(ev) {\n            ev.stopPropagation(); ev.preventDefault();\n            window.removeEventListener('mousemove', moveHandler, false);\n            window.removeEventListener('mouseup', upHandler, false);\n        }\n        tbar.addEventListener('mousedown', function(ev) {\n            ev.preventDefault(); ev.stopPropagation();\n            dragOX = ev.clientX; dragOY = ev.clientY;\n            window.addEventListener('mousemove', moveHandler, false);\n            window.addEventListener('mouseup', upHandler, false);\n        }, false);\n                              \n\n        popup.appendChild(tbar);\n    }\n\n    popup.appendChild(makeElement('div', ele, {className: 'popover-content'}, {\n        padding: '0px'\n    }));\n    this.hPopupHolder.appendChild(popup);\n\n    var popupHandle = {\n        node: popup,\n        displayed: true\n    };\n    popup.addEventListener('DOMNodeRemoved', function(ev) {\n        if (ev.target == popup) {\n            popupHandle.displayed = false;\n        }\n    }, false);\n    return popupHandle;\n}\n\nfunction makeTreeTableSection(title, content, visible) {\n    var ttButton = makeElement('i');\n    function update() {\n        if (visible) {\n            ttButton.className = 'fa fa-caret-down';\n            content.style.display = 'table';\n        } else {\n            ttButton.className = 'fa fa-caret-right';\n            content.style.display = 'none';\n        }\n    }\n    update();\n\n    ttButton.addEventListener('click', function(ev) {\n        ev.preventDefault(); ev.stopPropagation();\n        visible = !visible;\n        update();\n    }, false);\n\n    var heading = makeElement('h6', [ttButton, ' ', title], {}, {display: 'block', background: 'gray', color: 'white', width: '100%', padding: '5px 2px', margin: '0px'});\n    return makeElement('div', [heading, content], {});\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeTreeTableSection: makeTreeTableSection\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// encode.js: interface for ENCODE DCC services\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var Promise = require('es6-promise').Promise;\n}\n\nfunction lookupEncodeURI(uri, json) {\n    if (uri.indexOf('?') < 0)\n        uri = uri + '?soft=true';\n\n    return new Promise(function(accept, reject) {\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status >= 300) {\n                    reject('Error code ' + req.status);\n                } else {\n                    var resp = JSON.parse(req.response);\n                    accept(json ? resp : resp.location);\n                }\n            }\n        };\n    \n        req.open('GET', uri, true);\n        req.setRequestHeader('Accept', 'application/json');\n        req.responseType = 'text';\n        req.send('');\n    });\n}\n\nfunction EncodeURLHolder(url) {\n    this.rawurl = url;\n}\n\nEncodeURLHolder.prototype.getURLPromise = function() {\n    if (this.urlPromise && this.urlPromiseValidity > Date.now()) {\n        return this.urlPromise;\n    } else {\n        this.urlPromise = lookupEncodeURI(this.rawurl, true).then(function(resp) {\n            return resp.location;\n        });\n        this.urlPromiseValidity = Date.now() + (12 * 3600 * 1000);\n        return this.urlPromise;\n    }\n}\n\nfunction EncodeFetchable(url, start, end, opts) {\n    if (!opts) {\n        if (typeof start === 'object') {\n            opts = start;\n            start = undefined;\n        } else {\n            opts = {};\n        }\n    }\n\n    this.url = (typeof url === 'string' ? new EncodeURLHolder(url) : url);\n    this.start = start || 0;\n    if (end) {\n        this.end = end;\n    }\n    this.opts = opts;\n}\n\n\n\nEncodeFetchable.prototype.slice = function(s, l) {\n    if (s < 0) {\n        throw 'Bad slice ' + s;\n    }\n\n    var ns = this.start, ne = this.end;\n    if (ns && s) {\n        ns = ns + s;\n    } else {\n        ns = s || ns;\n    }\n    if (l && ns) {\n        ne = ns + l - 1;\n    } else {\n        ne = ne || l - 1;\n    }\n    return new EncodeFetchable(this.url, ns, ne, this.opts);\n}\n\nEncodeFetchable.prototype.fetchAsText = function(callback) {\n    var self = this;\n    var req = new XMLHttpRequest();\n    var length;\n    self.url.getURLPromise().then(function(url) {\n        req.open('GET', url, true);\n\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    return callback(req.responseText);\n                } else {\n                    return callback(null);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send('');\n    }).catch(function(err) {\n        console.log(err);\n        return callback(null);\n    });\n}\n\nEncodeFetchable.prototype.salted = function() {\n    return this;\n}\n\nEncodeFetchable.prototype.fetch = function(callback, attempt, truncatedLength) {\n    var self = this;\n\n    attempt = attempt || 1;\n    if (attempt > 3) {\n        return callback(null);\n    }\n\n    self.url.getURLPromise().then(function (url) {\n        var req = new XMLHttpRequest();\n        var length;\n        req.open('GET', url, true);\n        req.overrideMimeType('text/plain; charset=x-user-defined');\n        if (self.end) {\n            if (self.end - self.start > 100000000) {\n                throw 'Monster fetch!';\n            }\n            req.setRequestHeader('Range', 'bytes=' + self.start + '-' + self.end);\n            length = self.end - self.start + 1;\n        }\n        req.responseType = 'arraybuffer';\n        req.onreadystatechange = function() {\n            if (req.readyState == 4) {\n                if (req.status == 200 || req.status == 206) {\n                    if (req.response) {\n                        var bl = req.response.byteLength;\n                        if (length && length != bl && (!truncatedLength || bl != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, bl);\n                        } else {\n                            return callback(req.response);\n                        }\n                    } else if (req.mozResponseArrayBuffer) {\n                        return callback(req.mozResponseArrayBuffer);\n                    } else {\n                        var r = req.responseText;\n                        if (length && length != r.length && (!truncatedLength || r.length != truncatedLength)) {\n                            return self.fetch(callback, attempt + 1, r.length);\n                        } else {\n                            return callback(bstringToBuffer(req.responseText));\n                        }\n                    }\n                } else {\n                    return self.fetch(callback, attempt + 1);\n                }\n            }\n        };\n        if (self.opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send('');\n    }).catch(function(err) {\n        console.log(err);\n    });\n}\n\nfunction bstringToBuffer(result) {\n    if (!result) {\n        return null;\n    }\n\n    var ba = new Uint8Array(result.length);\n    for (var i = 0; i < ba.length; ++i) {\n        ba[i] = result.charCodeAt(i);\n    }\n    return ba.buffer;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        lookupEncodeURI: lookupEncodeURI,\n        EncodeFetchable: EncodeFetchable\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// ensembljson.js -- query the Ensembl REST API.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sa = require('./sourceadapters');\n    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;\n    var FeatureSourceBase = sa.FeatureSourceBase;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n}\n\n\n\nfunction EnsemblFeatureSource(source) {\n    FeatureSourceBase.call(this);\n    this.source = source;\n    this.base = source.uri || '//rest.ensembl.org';\n    if (this.base.indexOf('//') === 0) {\n        var proto = window.location.protocol;\n        if (proto == 'http:' || proto == 'https:') {\n            // Protocol-relative URLs okay.\n        } else {\n            this.base = 'http:' + this.base;\n        }\n    }\n    this.species = source.species || 'human';\n\n    if (typeof source.type === 'string') {\n        this.type = [source.type];\n    } else {\n        this.type = source.type || ['regulatory'];\n    }\n}\n\nEnsemblFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\nEnsemblFeatureSource.prototype.constructor = EnsemblFeatureSource;\n\nEnsemblFeatureSource.prototype.getStyleSheet = function(callback) {\n    var stylesheet = new DASStylesheet();\n\n    var tsStyle = new DASStyle();\n    tsStyle.glyph = '__NONE';\n    if (this.type.indexOf('exon') >= 0)\n        stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n    if (this.type.indexOf('exon') >= 0 || this.type.indexOf('transcript') >= 0)\n        stylesheet.pushStyle({type: 'gene'}, null, tsStyle);\n\n    var cdsStyle = new DASStyle();\n    cdsStyle.glyph = 'BOX';\n    cdsStyle.FGCOLOR = 'black';\n    cdsStyle.BGCOLOR = 'red'\n    cdsStyle.HEIGHT = 8;\n    cdsStyle.BUMP = true;\n    cdsStyle.LABEL = true;\n    cdsStyle.ZINDEX = 10;\n    stylesheet.pushStyle({type: 'cds'}, null, cdsStyle);\n\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'SQUARE';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        // varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'blue';\n        stylesheet.pushStyle({type: 'variation', method: '.+_UTR_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'TRIANGLE';\n        varStyle.DIRECTION = 'S';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        // varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'blue';\n        stylesheet.pushStyle({type: 'variation', method: 'missense_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'TRIANGLE';\n        varStyle.DIRECTION = 'N';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        // varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'blue';\n        stylesheet.pushStyle({type: 'variation', method: 'splice_.+_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'STAR';\n        varStyle.POINTS = 6;\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        // varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'blue';\n        stylesheet.pushStyle({type: 'variation', method: 'regulatory_region_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'PLIMSOLL';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        // varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'rgb(50,80,255)';\n        varStyle.STROKECOLOR = 'black';\n        stylesheet.pushStyle({type: 'variation'}, null, varStyle);\n    }\n        {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'SQUARE';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'red';\n        stylesheet.pushStyle({type: 'indel', method: '.+_UTR_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'TRIANGLE';\n        varStyle.DIRECTION = 'S';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'red';\n        stylesheet.pushStyle({type: 'indel', method: 'missense_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'TRIANGLE';\n        varStyle.DIRECTION = 'N';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'red';\n        stylesheet.pushStyle({type: 'indel', method: 'splice_.+_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'STAR';\n        varStyle.POINTS = 6;\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'red';\n        stylesheet.pushStyle({type: 'indel', method: 'regulatory_region_variant'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'PLIMSOLL';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.FGCOLOR = 'red';\n        varStyle.STROKECOLOR = 'black';\n        stylesheet.pushStyle({type: 'indel'}, null, varStyle);\n    }\n\n    var wigStyle = new DASStyle();\n    wigStyle.glyph = 'BOX';\n    wigStyle.FGCOLOR = 'black';\n    wigStyle.BGCOLOR = 'orange'\n    wigStyle.HEIGHT = 8;\n    wigStyle.BUMP = true;\n    wigStyle.LABEL = true;\n    wigStyle.ZINDEX = 20;\n    stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n    return callback(stylesheet);\n}\n\n\nEnsemblFeatureSource.prototype.getScales = function() {\n    return [];\n}\n\nEnsemblFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var thisB = this;\n    var url = this.base + '/overlap/region/' + this.species + '/' + chr + ':' + min + '-' + max;\n\n    var filters = [];\n    for (var ti = 0; ti < this.type.length; ++ti) {\n        filters.push('feature=' + this.type[ti]);\n    }\n    filters.push('content-type=application/json');\n    url = url + '?' + filters.join(';');\n\n    var req = new XMLHttpRequest();\n    req.onreadystatechange = function() {\n    \tif (req.readyState == 4) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n    \t    if (req.status >= 300) {\n                var err = 'Error code ' + req.status;\n                try {\n                    var jr = JSON.parse(req.response);\n                    if (jr.error) {\n                        err = jr.error;\n                    }\n                } catch (ex) {};\n\n    \t\t    callback(err, null);\n    \t    } else {\n        \t\tvar jf = JSON.parse(req.response);\n        \t\tvar features = [];\n        \t\tfor (var fi = 0; fi < jf.length; ++fi) {\n        \t\t    var j = jf[fi];\n\n        \t\t    var notes = [];\n        \t\t    var f = new DASFeature();\n        \t\t    f.segment = chr;\n        \t\t    f.min = j['start'] | 0;\n        \t\t    f.max = j['end'] | 0;\n        \t\t    f.type = j.feature_type || 'unknown';\n        \t\t    f.id = j.ID;\n\n                    if (j.Parent) {\n                        var grp = new DASGroup();\n                        grp.id = j.Parent;\n                        f.groups = [grp];\n                    }\n\n                    if (j.strand) {\n                        if (j.strand < 0) \n                            f.orientation = '-';\n                        else if (j.strand > 0) \n                            f.orientation = '+';\n                    }\n\n                    if (j.consequence_type)\n                        f.method = j.consequence_type;\n\n                    if (j.alt_alleles) {\n                        notes.push('Alleles=' + j.alt_alleles.join('/'));\n                        if (j.alt_alleles.length > 1) {\n                            if (j.alt_alleles[1].length != j.alt_alleles[0].length || j.alt_alleles[1] == '-') {\n                                f.type = 'indel';\n                            }\n                        }\n                    }\n        \t\t    \n                    if (notes.length > 0) {\n                        f.notes = notes;\n                    }\n        \t\t    features.push(f);\n        \t\t}\n        \t\tcallback(null, features);\n    \t    }\n    \t}\n\t\n    };\n    \n    thisB.busy++;\n    thisB.notifyActivity();\n\n    req.open('GET', url, true);\n    req.responseType = 'text';\n    req.send('');\n}\n\ndalliance_registerSourceAdapterFactory('ensembl', function(source) {\n    return {features: new EnsemblFeatureSource(source)};\n});\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// export-config.js\n//\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var sha1 = require('./sha1');\n    var hex_sha1 = sha1.hex_sha1;\n\n    var das = require('./das');\n    var copyStylesheet = das.copyStylesheet;\n}\n\nBrowser.prototype.exportFullConfig = function(opts) {\n    opts = opts || {};\n\n    var config = {\n        chr: this.chr,\n        viewStart: this.viewStart|0,\n        viewEnd: this.viewEnd|0,\n        cookieKey: 'dalliance_' + hex_sha1(Date.now()),\n\n        coordSystem: this.coordSystem,\n\n        sources: this.exportSourceConfig(),\n\n        chains: this.exportChains()\n    };\n\n    if (this.prefix)\n        config.prefix = this.prefix;\n\n    return config;\n}\n\nBrowser.prototype.exportChains = function() {\n    var cc = {};\n    var cs = this.chains || {};\n    for (var k in cs) {\n        cc[k] = cs[k].exportConfig();\n    }\n    return cc;\n}\n\nBrowser.prototype.exportSourceConfig = function(opts) {\n    opts = opts || {};\n\n    var sourceConfig = [];\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var tier = this.tiers[ti];\n        var source = shallowCopy(tier.dasSource);\n\n        if (source.noPersist)\n            continue;\n\n        source.coords = undefined;\n        source.props = undefined;\n        if (!source.disabled)\n            source.disabled = undefined;\n\n        if (tier.config.stylesheet) {\n            source.style = copyStylesheet(tier.config.stylesheet).styles;\n            source.stylesheet_uri = undefined;\n        } else if (source.style) {\n            source.style = copyStylesheet({styles: source.style}).styles;\n        }\n\n        if (typeof(tier.config.name) === 'string') {\n            source.name = tier.config.name;\n        }\n\n        if (tier.config.height !== undefined) {\n            source.forceHeight = tier.config.height;\n        }\n        if (tier.config.forceMin !== undefined) {\n            source.forceMin = tier.config.forceMin;\n        }\n        if (tier.config.forceMinDynamic)\n            source.forceMinDynamic = tier.config.forceMinDynamic;\n        if (tier.config.forceMax !== undefined) {\n            source.forceMax = tier.config.forceMax;\n        }\n        if (tier.config.bumped !== undefined) {\n            source.bumped = tier.config.bumped;\n        }\n        if (tier.config.forceMaxDynamic)\n            source.forceMaxDynamic = tier.config.forceMaxDynamic;\n\n        sourceConfig.push(source);\n    }\n\n    return sourceConfig;\n}\n\nBrowser.prototype.exportPageTemplate = function(opts) {\n    opts = opts || {};\n    var template = '<html>\\n' +\n                   '  <head>\\n' +\n                   '    <script language=\"javascript\" src=\"' + this.resolveURL('$$dalliance-compiled.js') + '\"></script>\\n' +\n                   '    <script language=\"javascript\">\\n' +\n                   '      var dalliance_browser = new Browser(' + JSON.stringify(this.exportFullConfig(opts), null, 2) + ');\\n' +\n                   '    </script>\\n' +  \n                   '  </head>\\n' +\n                   '  <body>\\n' +\n                   '    <div id=\"svgHolder\">Dalliance goes here</div>\\n' +\n                   '  </body>\\n' +\n                   '<html>\\n';\n\n    return template;\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// export-image.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var g = require('./glyphs');\n    var OverlayLabelCanvas = g.OverlayLabelCanvas;\n\n    var nf = require('./numformats');\n    var formatQuantLabel = nf.formatQuantLabel;\n\n    var drawSeqTierGC = require('./sequence-draw').drawSeqTierGC;\n}\n\nfunction fillTextRightJustified(g, text, x, y) {\n    g.fillText(text, x - g.measureText(text).width, y);\n}\n\nBrowser.prototype.exportImage = function(opts) {\n    opts = opts || {};\n\n    var fpw = this.featurePanelWidth;\n    var padding = 3;\n    var totHeight = 0;\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        if (ti > 0)\n            totHeight += padding;\n        var tier = this.tiers[ti];\n        if (tier.layoutHeight !== undefined)\n            totHeight += tier.layoutHeight;\n    }\n    var mult = opts.resolutionMultiplier || 1.0;\n    var margin = 200;\n\n\n    var cw = ((fpw + margin) * mult)|0;\n    var ch = (totHeight * mult)|0;\n    var c = makeElement('canvas', null, {width: cw, height: ch});\n    var g = c.getContext('2d');\n    g.fillStyle = 'white';\n    g.fillRect(0, 0, cw, ch);\n\n    g.scale(mult, mult);\n    \n    var ypos = 0;\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        var tier = this.tiers[ti];\n        var offset = ((tier.glyphCacheOrigin - this.viewStart)*this.scale);\n\n        var oc = new OverlayLabelCanvas();\n        g.save();       // 1\n        g.translate(0, ypos);\n\n        g.save();       // 2\n        g.beginPath();\n        g.moveTo(margin, 0);\n        g.lineTo(margin + fpw, 0);\n        g.lineTo(margin + fpw, tier.layoutHeight);\n        g.lineTo(margin, tier.layoutHeight);\n        g.closePath();\n        g.clip();\n        g.translate(margin, 0);\n\n        g.save();      // 3\n        g.translate(offset, 0);\n        if (tier.subtiers) {\n            tier.paintToContext(g, oc, offset + 1000);\n        } else {\n            drawSeqTierGC(tier, tier.currentSequence, g);\n        }\n        g.restore();   // 2\n        \n        g.save()       // 3\n        g.translate(offset, 0);\n        oc.draw(g, -offset, fpw - offset);\n        g.restore();   // 2\n        g.restore();   // 1\n\n        var hasQuant = false;\n        var pos = 0;\n        var subtiers = tier.subtiers || [];\n        for (var sti = 0; sti < subtiers.length; ++sti) {\n            var subtier = subtiers[sti];\n                    \n            if (subtier.quant) {\n                hasQuant = true;\n                var q = subtier.quant;\n                var h = subtier.height;\n\n                var numTics = 2;\n                if (h > 40) {\n                    numTics = 1 + ((h/20) | 0);\n                }\n                var ticSpacing = h / (numTics - 1);\n                var ticInterval = (q.max - q.min) / (numTics - 1);\n\n                g.beginPath();\n                g.moveTo(margin + 5, pos);\n                g.lineTo(margin, pos);\n                g.lineTo(margin, pos + subtier.height);\n                g.lineTo(margin + 5, pos + subtier.height);\n                for (var t = 1; t < numTics-1; ++t) {\n                    var ty = t*ticSpacing;\n                    g.moveTo(margin, pos + ty);\n                    g.lineTo(margin+3, pos + ty);\n                }\n                g.strokeStyle = 'black';\n                g.strokeWidth = 2;\n                g.stroke();\n\n                g.fillStyle = 'black';\n                fillTextRightJustified(g, formatQuantLabel(q.max), margin - 3, pos + 7);\n                fillTextRightJustified(g, formatQuantLabel(q.min), margin - 3, pos + subtier.height);\n                for (var t = 1; t < numTics-1; ++t) {\n                    var ty = t*ticSpacing;\n                    fillTextRightJustified(g, formatQuantLabel((1.0*q.max) - (t*ticInterval)), margin - 3, pos + ty + 3);\n                }\n            }\n\n            pos += subtier.height + padding;\n        }\n\n        var labelName;\n        if (typeof tier.config.name === 'string')\n            labelName = tier.config.name;\n        else\n            labelName = tier.dasSource.name;\n        var labelWidth = g.measureText(labelName).width;\n        g.fillStyle = 'black';\n        g.fillText(labelName, margin - (hasQuant ? 22 : 12) - labelWidth, (tier.layoutHeight + 6) / 2);\n\n        g.restore(); // 0\n\n        ypos += tier.layoutHeight + padding;\n    }\n\n    if (opts.highlights) {\n        g.save();\n\n        g.beginPath();\n        g.moveTo(margin, 0);\n        g.lineTo(margin + fpw, 0);\n        g.lineTo(margin + fpw, ypos);\n        g.lineTo(margin, ypos);\n        g.closePath();\n        g.clip();\n\n        g.translate(margin + offset, 0);\n        var origin = this.viewStart;\n        var visStart = this.viewStart;\n        var visEnd = this.viewEnd;\n\n        for (var hi = 0; hi < this.highlights.length; ++hi) {\n            var h = this.highlights[hi];\n            if (((h.chr === this.chr) || (h.chr === ('chr' + this.chr))) && h.min < visEnd && h.max > visStart) {\n                g.globalAlpha = this.defaultHighlightAlpha;\n                g.fillStyle = this.defaultHighlightFill;\n                g.fillRect((h.min - origin) * this.scale,\n                           0,\n                           (h.max - h.min) * this.scale,\n                           ypos);\n            }\n        } \n        g.restore();\n    }\n\n    var rulerPos = -1; \n    if (opts.ruler == 'center') {\n        rulerPos = margin + ((this.viewEnd - this.viewStart + 1)*this.scale) / 2;\n    } else if (opts.ruler == 'left') {\n        rulerPos = margin;\n    } else if (opts.ruler == 'right') {\n        rulerPos = margin + ((this.viewEnd - this.viewStart + 1)*this.scale);\n    }\n    if (rulerPos >= 0) {\n        g.strokeStyle = 'blue';\n        g.beginPath();\n        g.moveTo(rulerPos, 0);\n        g.lineTo(rulerPos, ypos);\n        g.stroke();\n    }\n\n    return c.toDataURL('image/png');\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// export-ui.js\n//\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n}\n\nBrowser.prototype.openExportPanel = function() {\n    var b = this;\n    if (this.uiMode === 'export') {\n        this.hideToolPanel();\n        this.setUiMode('none');\n    } else {\n        var exportForm = makeElement('div', null, {className: 'export-form'});\n        var exportSelect = makeElement('select');\n        exportSelect.appendChild(makeElement('option', 'SVG', {value: 'svg'}));\n        exportSelect.appendChild(makeElement('option', 'Image', {value: 'png'}));\n        exportSelect.appendChild(makeElement('option', 'Dalliance config', {value: 'config'}));\n        exportSelect.appendChild(makeElement('option', 'Dalliance sources', {value: 'sources'}));\n        exportSelect.appendChild(makeElement('option', 'Dalliance page', {value: 'page'}));\n        exportSelect.value = 'svg';\n\n        exportSelect.addEventListener('change', function(ev) {\n            removeChildren(exportContent);\n            setupEOT();\n        }, false);\n        exportForm.appendChild(makeElement('p', ['Export as: ', exportSelect]));\n\n        var exportHighlightsToggle = makeElement('input', null, {type: 'checkbox', checked: this.exportHighlights});\n        exportHighlightsToggle.addEventListener('change', function(ev) {\n            b.exportHighlights = exportHighlightsToggle.checked;\n            b.storeStatus();\n        }, false);\n        var exportRulerToggle = makeElement('input', null, {type: 'checkbox', checked: this.exportRuler});\n        exportRulerToggle.addEventListener('change', function(ev) {\n            b.exportRuler = exportRulerToggle.checked;\n            b.storeStatus();\n        }, false);\n        var exportScale = makeElement('input', null, {type: 'text', value: '1.0'});\n\n        var exportButton = makeElement('button', 'Export', {className: 'btn btn-primary'});\n        exportButton.addEventListener('click', function(ev) {\n            removeChildren(exportContent);\n\n            var blobURL;\n            var note, type, name;\n            if (exportSelect.value === 'svg') {\n                blobURL = URL.createObjectURL(b.makeSVG({highlights: exportHighlightsToggle.checked,\n                                                         ruler: exportRulerToggle.checked ? b.rulerLocation : 'none'}));\n                note = 'SVG';\n                type = 'image/svg';\n                name = 'dalliance-view.svg';\n            } else if (exportSelect.value === 'png') {\n                var mult = parseFloat(exportScale.value);\n                if (mult < 0.1 || mult > 10) {\n                    alert('bad scale ' + mult);\n                    return;\n                }\n\n                blobURL = b.exportImage({highlights: exportHighlightsToggle.checked,\n                                         ruler: exportRulerToggle.checked ? b.rulerLocation : 'none',\n                                         resolutionMultiplier: mult});\n                note = 'Image';\n                type = 'image/png';\n                name = 'dalliance-view.png';\n            } else if (exportSelect.value === 'config') {\n                var config = JSON.stringify(b.exportFullConfig(), null, 2);\n                var blob = new Blob([config], {type: 'text/plain'});\n                blobURL = URL.createObjectURL(blob);\n                note = 'Configuration';\n                type = 'text/plain';\n                name = 'dalliance-config.json';\n            } else if (exportSelect.value === 'sources') {\n                var config = JSON.stringify(b.exportSourceConfig(), null, 2);\n                var blob = new Blob([config], {type: 'text/plain'});\n                blobURL = URL.createObjectURL(blob);\n                note = 'Source array';\n                type = 'text/plain';\n                name = 'dalliance-sources.json';\n            } else if (exportSelect.value === 'page') {\n                var page = b.exportPageTemplate();\n                var type = 'text/html';\n                var blob = new Blob([page], {type: type});\n                blobURL = URL.createObjectURL(blob);\n                note = 'Page template';\n                name = 'dalliance-view.html';\n            }\n\n            if (blobURL) {\n                var downloadLink = makeElement('a', '[Download]', {\n                    href: blobURL,\n                    download: name,\n                    type: type\n                });\n\n                var previewLink = makeElement('a', '[Preview in browser]', {\n                    href: blobURL,\n                    type: type,\n                    target: '_new'\n                });\n\n                exportContent.appendChild(makeElement('p', ['' + note + ' created: ', downloadLink, previewLink]));\n            }\n        }, false);\n\n        b.addViewListener(function() {\n            removeChildren(exportContent);\n        });\n        b.addTierListener(function() {\n            removeChildren(exportContent);\n        });\n\n        var exportContent = makeElement('p', '');\n\n        var eotHighlights = makeElement('tr',\n                [makeElement('th', 'Include highlights', {}, {width: '200px', textAlign: 'right'}),\n                 makeElement('td', exportHighlightsToggle)]);\n        var eotGuideline = makeElement('tr',\n                [makeElement('th', 'Include vertical guideline'),\n                 makeElement('td', exportRulerToggle)]);\n        var eotScale = makeElement('tr',\n            [makeElement('th', 'Scale multiplier'),\n             makeElement('td', exportScale)]);\n\n        var exportOptsTable = makeElement('table',\n            [eotHighlights,\n             eotGuideline,\n             eotScale]);\n        var setupEOT = function() {\n            var es = exportSelect.value;\n            eotHighlights.style.display = (es == 'svg' || es == 'png') ? 'table-row' : 'none';\n            eotGuideline.style.display = (es == 'svg' || es == 'png') ? 'table-row' : 'none';\n            eotScale.style.display = (es == 'png') ? 'table-row' : 'none';\n        }\n        setupEOT();\n\n        exportForm.appendChild(exportOptsTable);\n        exportForm.appendChild(exportButton);\n        exportForm.appendChild(exportContent);\n\n        if (this.uiMode !== 'none')\n            this.hideToolPanel();\n        this.browserHolder.insertBefore(exportForm, this.svgHolder);\n        this.activeToolPanel = exportForm;\n\n        this.setUiMode('export');\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// exports.js: shim to export symbols into global namespace for ease of embedding\n//\n\nvar browser = require('./cbrowser');\nvar chainset = require('./chainset');\nvar sa = require('./sourceadapters');\nvar utils = require('./utils');\nvar das = require('./das');\nvar sc = require('./sourcecompare');\n\nwindow.Browser = browser.Browser;\nwindow.sourcesAreEqual = sc.sourcesAreEqual;\nwindow.Chainset = chainset.Chainset;    // Pre-0.12 configurations need this.\n\n// Useful for info plugins.  Should be reconsidered in the future.\nwindow.makeElement = utils.makeElement;\n\n// Allow source plugins to be loaded separately.\nwindow.dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;\nwindow.dalliance_registerParserFactory = sa.registerParserFactory;\nwindow.dalliance_makeParser = sa.makeParser;\n\n// DAS* objects for some plugins -- remove when plugin API changes...\n\nwindow.DASSequence = das.DASSequence;\nwindow.DASFeature = das.DASFeature;\nwindow.DASGroup = das.DASGroup;\nwindow.DASStylesheet = das.DASStylesheet;\nwindow.DASStyle = das.DASStyle;\nwindow.DASSource = das.DASSource;    // Pre-0.8 configurations used this.  Still some around...\n","// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// feature-draw.js: new feature-tier renderer\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n    var pusho = utils.pusho;\n\n    var tier = require('./tier');\n    var DasTier = tier.DasTier;\n\n    var g = require('./glyphs');\n    var BoxGlyph = g.BoxGlyph;\n    var GroupGlyph = g.GroupGlyph;\n    var LineGraphGlyph = g.LineGraphGlyph;\n    var LabelledGlyph = g.LabelledGlyph;\n    var CrossGlyph = g.CrossGlyph;\n    var ExGlyph = g.ExGlyph;\n    var TriangleGlyph = g.TriangleGlyph;\n    var DotGlyph = g.DotGlyph;\n    var PaddedGlyph = g.PaddedGlyph;\n    var AArrowGlyph = g.AArrowGlyph;\n    var SpanGlyph = g.SpanGlyph;\n    var LineGlyph = g.LineGlyph;\n    var PrimersGlyph = g.PrimersGlyph;\n    var ArrowGlyph = g.ArrowGlyph;\n    var TooManyGlyph = g.TooManyGlyph;\n    var TextGlyph = g.TextGlyph;\n    var SequenceGlyph = g.SequenceGlyph;\n    var AminoAcidGlyph = g.AminoAcidGlyph;\n    var TranslatedGlyph = g.TranslatedGlyph;\n    var PointGlyph = g.PointGlyph;\n    var GridGlyph = g.GridGlyph;\n    var StarGlyph = g.StarGlyph;\n    var PlimsollGlyph = g.PlimsollGlyph;\n    var OverlayLabelCanvas = g.OverlayLabelCanvas;\n\n    var color = require('./color');\n    var makeGradient = color.makeGradient;\n\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n\n    var das = require('./das');\n    var DASFeature = das.DASFeature;\n    var isDasBooleanTrue = das.isDasBooleanTrue;\n    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;\n\n    var parseCigar = require('./cigar').parseCigar;\n\n    var nf = require('./numformats');\n    var formatQuantLabel = nf.formatQuantLabel;\n}\n\nvar MIN_PADDING = 3;\n\nfunction SubTier() {\n    this.glyphs = [];\n    this.height = 0;\n    this.quant = null;\n}\n\nSubTier.prototype.indexFor = function(glyph) {\n    var gmin = glyph.min();\n    var lb = 0, ub = this.glyphs.length;\n    while (ub > lb) {\n        var mid = ((lb + ub)/2)|0;\n        if (mid >= this.glyphs.length)\n            return this.glyphs.length;\n        var mg = this.glyphs[mid];\n        if (gmin < mg.min()) {\n            ub = mid;\n        } else {\n            lb = mid + 1;\n        }\n    }\n    return ub;\n}\n\nSubTier.prototype.add = function(glyph) {\n    var ind = this.indexFor(glyph);\n    this.glyphs.splice(ind, 0, glyph);\n    this.height = Math.max(this.height, glyph.height());\n    if (glyph.quant && this.quant == null) {\n        this.quant = glyph.quant;\n    }\n}\n\nSubTier.prototype.hasSpaceFor = function(glyph) {\n    var ind = this.indexFor(glyph);\n    if (ind > 0 && this.glyphs[ind-1].max() >= glyph.min())\n        return false;\n    if (ind < this.glyphs.length && this.glyphs[ind].min() <= glyph.max())\n        return false;\n\n    return true;\n}\n\nvar GLOBAL_GC;\n\nfunction drawFeatureTier(tier)\n{\n    var start = Date.now()|0;\n    GLOBAL_GC = tier.viewport.getContext('2d'); // Should only be used for metrics.\n    if (typeof(tier.dasSource.padding) === 'number')\n        tier.padding = tier.dasSource.padding;\n    else\n        tier.padding = MIN_PADDING;\n    \n    if (typeof(tier.dasSource.scaleVertical) === 'boolean')\n        tier.scaleVertical = tier.dasSource.scaleVertical;\n    else\n        tier.scaleVertical = false;\n\n    var glyphs = [];\n    var specials = false;\n\n    // group by style\n    var gbsFeatures = {};\n    var gbsStyles = {};\n\n    for (var uft in tier.ungroupedFeatures) {\n        var ufl = tier.ungroupedFeatures[uft];\n        \n        for (var pgid = 0; pgid < ufl.length; ++pgid) {\n            var f = ufl[pgid];\n            if (f.parts) {  // FIXME shouldn't really be needed\n                continue;\n            }\n\n            var style = tier.styleForFeature(f);\n            if (!style)\n                continue;\n\n            if (style.glyph == 'LINEPLOT') {\n                pusho(gbsFeatures, style.id, f);\n                gbsStyles[style.id] = style;\n            } else {\n                var g = glyphForFeature(f, 0, style, tier);\n                if (g)\n                    glyphs.push(g);\n            }\n        }\n    }\n\n    for (var gbs in gbsFeatures) {\n        var gf = gbsFeatures[gbs];\n        var style = gbsStyles[gbs];\n        if (style.glyph == 'LINEPLOT') {\n            glyphs.push(makeLineGlyph(gf, style, tier));\n            specials = true;\n        }\n    }\n\n    // Merge supergroups    \n\n    if (tier.dasSource.collapseSuperGroups && !tier.bumped) {\n        for (var sg in tier.superGroups) {\n            var sgg = tier.superGroups[sg];\n            tier.groups[sg] = shallowCopy(tier.groups[sg]);\n            tier.groups[sg].isSuperGroup = true;\n            var featsByType = {};\n\n            var sgMin = 10000000000, sgMax = -10000000000;\n            var sgSeg = null;\n            for (var g = 0; g < sgg.length; ++g) {\n                var gf = tier.groupedFeatures[sgg[g]];\n                if (!gf)\n                    continue;\n\n                for (var fi = 0; fi < gf.length; ++fi) {\n                    var f = gf[fi];\n                    pusho(featsByType, f.type, f);\n                    sgMin = Math.min(f.min, sgMin);\n                    sgMax = Math.max(f.max, sgMax);\n                    if (f.segment && !sgSeg)\n                        sgSeg = f.segment;\n                }\n\n                if (tier.groups[sg] && !tier.groups[sg].links || tier.groups[sg].links.length == 0) {\n                   tier.groups[sg].links = tier.groups[sgg[0]].links;\n                }\n\n                delete tier.groupedFeatures[sgg[g]];  // 'cos we don't want to render the unmerged version.\n            }\n\n            tier.groups[sg].max = sgMax;\n            tier.groups[sg].min = sgMin;\n            tier.groups[sg].segment = sgSeg;\n\n            for (var t in featsByType) {\n                var feats = featsByType[t];\n                var template = feats[0];\n                var loc = null;\n                for (var fi = 0; fi < feats.length; ++fi) {\n                    var f = feats[fi];\n                    var fl = new Range(f.min, f.max);\n                    if (!loc) {\n                        loc = fl;\n                    } else {\n                        loc = union(loc, fl);\n                    }\n                }\n                var mergedRanges = loc.ranges();\n                for (var si = 0; si < mergedRanges.length; ++si) {\n                    var r = mergedRanges[si];\n\n                    // begin coverage-counting\n                    var posCoverage = ((r.max()|0) - (r.min()|0) + 1) * sgg.length;\n                    var actCoverage = 0;\n                    for (var fi = 0; fi < feats.length; ++fi) {\n                        var f = feats[fi];\n                        if ((f.min|0) <= r.max() && (f.max|0) >= r.min()) {\n                            var umin = Math.max(f.min|0, r.min());\n                            var umax = Math.min(f.max|0, r.max());\n                            actCoverage += (umax - umin + 1);\n                        }\n                    }\n                    var visualWeight = ((1.0 * actCoverage) / posCoverage);\n                    // end coverage-counting\n\n                    var newf = new DASFeature();\n                    for (var k in template) {\n                        newf[k] = template[k];\n                    }\n                    newf.min = r.min();\n                    newf.max = r.max();\n                    if (newf.label && sgg.length > 1) {\n                        newf.label += ' (' + sgg.length + ' vars)';\n                    }\n                    newf.visualWeight = ((1.0 * actCoverage) / posCoverage);\n                    pusho(tier.groupedFeatures, sg, newf);\n                    // supergroups are already in tier.groups.\n                }\n            }\n\n            delete tier.superGroups[sg]; // Do we want this?\n        }       \n    }\n\n    // Glyphify groups.\n\n    var gl = new Array();\n    for (var gid in tier.groupedFeatures) {\n        gl.push(gid);\n    }\n    gl.sort(function(g1, g2) {\n        var d = tier.groupedFeatures[g1][0].score - tier.groupedFeatures[g2][0].score;\n        if (d > 0) {\n            return -1;\n        } else if (d == 0) {\n            return 0;\n        } else {\n            return 1;\n        }\n    });\n\n    var groupGlyphs = {};\n    for (var gx = 0; gx < gl.length; ++gx) {\n        var gid = gl[gx];\n        var g = glyphsForGroup(tier.groupedFeatures[gid], 0, tier.groups[gid], tier,\n                               (tier.dasSource.collapseSuperGroups && !tier.bumped) ? 'collapsed_gene' : 'tent');\n        if (g) {\n            g.group = tier.groups[gid];\n            groupGlyphs[gid] = g;\n        }\n    }\n\n    for (var sg in tier.superGroups) {\n        var sgg = tier.superGroups[sg];\n        var sgGlyphs = [];\n        var sgMin = 10000000000;\n        var sgMax = -10000000000;\n        for (var sgi = 0; sgi < sgg.length; ++sgi) {\n            var gg = groupGlyphs[sgg[sgi]];\n            groupGlyphs[sgg[sgi]] = null;\n            if (gg) {\n                sgGlyphs.push(gg);\n                sgMin = Math.min(sgMin, gg.min());\n                sgMax = Math.max(sgMax, gg.max());\n            }\n        }\n        for (var sgi = 0; sgi < sgGlyphs.length; ++sgi) {\n            var gg = sgGlyphs[sgi];\n            glyphs.push(new PaddedGlyph(gg, sgMin, sgMax));\n        }\n    }\n    for (var g in groupGlyphs) {\n        var gg = groupGlyphs[g];\n        if (gg) {\n            glyphs.push(gg);\n        }\n    }\n\n    // Bumping\n\n    var unbumpedST = new SubTier();\n    var bumpedSTs = [];\n    var hasBumpedFeatures = false;\n    var subtierMax = tier.subtierMax || tier.dasSource.subtierMax || tier.browser.defaultSubtierMax;\n    var subtiersExceeded = false;\n\n  GLYPH_LOOP:\n    for (var i = 0; i < glyphs.length; ++i) {\n        var g = glyphs[i];\n        if (g.bump) {\n            hasBumpedFeatures = true;\n        }\n        if (g.bump && (tier.bumped || tier.dasSource.collapseSuperGroups)) {       // kind-of nasty.  supergroup collapsing is different from \"normal\" unbumping\n            for (var sti = 0; sti < bumpedSTs.length;  ++sti) {\n                var st = bumpedSTs[sti];\n                if (st.hasSpaceFor(g)) {\n                    st.add(g);\n                    continue GLYPH_LOOP;\n                }\n            }\n            if (bumpedSTs.length >= subtierMax) {\n                subtiersExceeded = true;\n            } else {\n                var st = new SubTier();\n                st.add(g);\n                bumpedSTs.push(st);\n            }\n        } else {\n            unbumpedST.add(g);\n        }\n    }\n\n    if (unbumpedST.glyphs.length > 0) {\n        bumpedSTs = [unbumpedST].concat(bumpedSTs);\n    }\n\n    for (var sti = 0; sti < bumpedSTs.length; ++sti) {\n        var st = bumpedSTs[sti];\n        if (st.quant) {\n            st.glyphs.unshift(new GridGlyph(st.height));\n        }\n    }\n\n    for (var sti = 0; sti < bumpedSTs.length; ++sti) {\n        var st = bumpedSTs[sti];\n        st.glyphs.sort(function (g1, g2) {\n            var z1 = g1.zindex || 0;\n            var z2 = g2.zindex || 0;\n            return z1 - z2;\n        });\n    }\n\n    tier.subtiers = bumpedSTs;\n    tier.glyphCacheOrigin = tier.browser.viewStart;\n\n    if (subtiersExceeded)\n        tier.updateStatus('Bumping limit exceeded, use the track editor to see more features');\n    else\n        tier.updateStatus();\n}\n\nDasTier.prototype.paint = function() {\n    var retina = this.browser.retina && window.devicePixelRatio > 1;\n\n    var subtiers = this.subtiers;\n    if (!subtiers) {\n\t   return;\n    }\n\n    var desiredWidth = this.browser.featurePanelWidth + 2000;\n    if (retina) {\n        desiredWidth *= 2;\n    }\n    var fpw = this.viewport.width|0;\n    if (fpw < desiredWidth - 50) {\n        this.viewport.width = fpw = desiredWidth;\n    }\n\n    var lh = this.padding;\n    for (var s = 0; s < subtiers.length; ++s) {\n        lh = lh + subtiers[s].height + this.padding;\n    }\n    lh += 6\n    lh = Math.max(lh, this.browser.minTierHeight);\n\n    var canvasHeight = lh;\n    if (retina) {\n        canvasHeight *= 2;\n    }\n\n    if (canvasHeight != this.viewport.height) {\n        this.viewport.height = canvasHeight;\n    }\n    \n    var tierHeight = Math.max(lh, this.browser.minTierHeight);\n    this.viewportHolder.style.left = '-1000px';\n    this.viewport.style.width = retina ? ('' + (fpw/2) + 'px') : ('' + fpw + 'px');\n    this.viewport.style.height = '' + lh + 'px';\n    this.layoutHeight =  Math.max(lh, this.browser.minTierHeight);\n\n    this.updateHeight();\n    this.norigin = this.browser.viewStart;\n\n    var gc = this.viewport.getContext('2d');\n    gc.clearRect(0, 0, fpw, canvasHeight);\n\n    gc.save();\n    if (retina) {\n        gc.scale(2, 2);\n    }\n\n    /*\n    if (this.background) {\n        gc.fillStyle = this.background;\n\n        if (this.knownCoverage) {\n            var knownRanges = this.knownCoverage.ranges();\n            for (var ri = 0; ri < knownRanges.length; ++ri) {\n                var r = knownRanges[ri];\n                var knownMin = (r.min() - this.browser.viewStart) * this.browser.scale + 1000;\n                var knownMax = (r.max() - this.browser.viewStart) * this.browser.scale + 1000;\n                gc.fillRect(knownMin, 0, knownMax - knownMin, lh);\n            }\n        }\n    }*/\n\n    var drawStart =  this.browser.viewStart - 1000.0/this.browser.scale;\n    var drawEnd = this.browser.viewEnd + 1000.0/this.browser.scale;\n    var unmappedBlocks = [];\n    if (this.knownCoverage) {\n        var knownRanges = this.knownCoverage.ranges();\n        for (var ri = 0; ri < knownRanges.length; ++ri) {\n            var r = knownRanges[ri];\n            if (ri == 0) {\n                if (r.min() > drawStart) \n                   unmappedBlocks.push({min: drawStart, max: r.min() - 1});\n            } else {\n                unmappedBlocks.push({min: knownRanges[ri-1].max() + 1, max: r.min() - 1});\n            }\n\n            if (ri == knownRanges.length - 1 && r.max() < drawEnd) {\n                unmappedBlocks.push({min: r.max() + 1, max: drawEnd});\n            } \n        }\n    }\n    if (unmappedBlocks.length > 0) {\n        gc.fillStyle = 'gray';\n        for (var i = 0; i < unmappedBlocks.length; ++i) {\n            var b = unmappedBlocks[i];\n            var min = (b.min - this.browser.viewStart) * this.browser.scale + 1000;\n            var max = (b.max - this.browser.viewStart) * this.browser.scale + 1000;\n            gc.fillRect(min, 0, max - min, lh);\n        }\n    }\n\n    var oc = new OverlayLabelCanvas();\n    var offset = ((this.glyphCacheOrigin - this.browser.viewStart)*this.browser.scale)+1000;\n    gc.translate(offset, this.padding);\n    oc.translate(0, this.padding);\n\n    this.paintToContext(gc, oc, offset);\n\n    if (oc.glyphs.length > 0)\n        this.overlayLabelCanvas = oc;\n    else\n        this.overlayLabelCanvas = null;\n\n    gc.restore();\n    this.drawOverlay();\n    this.paintQuant();\n}\n\nDasTier.prototype.paintToContext = function(gc, oc, offset) {\n    var subtiers = this.subtiers;\n    var fpw = this.viewport.width|0;\n\n    gc.save();\n    for (var s = 0; s < subtiers.length; ++s) {\n        var quant = null;\n        var glyphs = subtiers[s].glyphs;\n        for (var i = 0; i < glyphs.length; ++i) {\n            var glyph = glyphs[i];\n            if (glyph.min() < fpw-offset && glyph.max() > -offset) { \n                var glyph = glyphs[i];\n                glyph.draw(gc, oc);\n                if (glyph.quant) {\n                    quant = glyph.quant;\n                }\n            }\n        }\n        if (this.scaleVertical) {\n            var scale = this.browser.scale;\n            gc.translate(0, scale + this.padding);\n            oc.translate(0, scale + this.padding);\n        } else {\n            gc.translate(0, subtiers[s].height + this.padding);\n            oc.translate(0, subtiers[s].height + this.padding);\n        }\n    }\n    gc.restore();\n\n    if (quant && this.quantLeapThreshold && this.featureSource && this.browser.sourceAdapterIsCapable(this.featureSource, 'quantLeap')) {\n        var ry = subtiers[0].height * (1.0 - ((this.quantLeapThreshold - quant.min) / (quant.max - quant.min)));\n\n        gc.save();\n        gc.strokeStyle = 'red';\n        gc.lineWidth = 0.3;\n        gc.beginPath();\n        gc.moveTo(-1000, ry);\n        gc.lineTo(fpw + 1000, ry);\n        gc.stroke();\n        gc.restore();\n    }    \n}\n\nDasTier.prototype.paintQuant = function() {\n    if (!this.quantOverlay)\n        return;\n\n    var retina = this.browser.retina && window.devicePixelRatio > 1;\n\n    var quant;\n    if (this.subtiers && this.subtiers.length > 0)\n        quant = this.subtiers[0].quant;\n\n    if (quant) {\n        var h = this.subtiers[0].height;\n        var w = 50;\n        this.quantOverlay.height = this.viewport.height;\n        this.quantOverlay.width = retina ? w*2 : w;\n        this.quantOverlay.style.height = '' + (retina ? this.quantOverlay.height/2 : this.quantOverlay.height) + 'px';\n        this.quantOverlay.style.width = '' + w + 'px';\n        this.quantOverlay.style.display = 'block';\n        var ctx = this.quantOverlay.getContext('2d');\n        if (retina)\n            ctx.scale(2, 2);\n\n        var numTics = 2;\n        if (h > 40) {\n            numTics = 1 + ((h/20) | 0);\n        }\n        var ticSpacing = (h + this.padding*2) / (numTics - 1);\n        var ticInterval = (quant.max - quant.min) / (numTics - 1);\n\n        ctx.fillStyle = 'white'\n        ctx.globalAlpha = 0.6;\n        if (this.browser.rulerLocation == 'right') {\n            ctx.fillRect(w-30, 0, 30, h + this.padding*2);\n        } else {\n            ctx.fillRect(0, 0, 30, h + this.padding*2);\n        }\n        ctx.globalAlpha = 1.0;\n\n        ctx.strokeStyle = 'black';\n        ctx.lineWidth = 1;\n        ctx.beginPath();\n\n        if (this.browser.rulerLocation == 'right') {\n            ctx.moveTo(w - 8, this.padding);\n            ctx.lineTo(w, this.padding);\n            ctx.lineTo(w, h + this.padding);\n            ctx.lineTo(w - 8, h + this.padding);\n            for (var t = 1; t < numTics-1; ++t) {\n                var ty = t*ticSpacing;\n                ctx.moveTo(w, ty);\n                ctx.lineTo(w - 5, ty);\n            }\n        } else {\n            ctx.moveTo(8, this.padding);\n            ctx.lineTo(0, this.padding);\n            ctx.lineTo(0, h + this.padding);\n            ctx.lineTo(8, h + this.padding);\n            for (var t = 1; t < numTics-1; ++t) {\n                var ty = t*ticSpacing;\n                ctx.moveTo(0, ty);\n                ctx.lineTo(5, ty);\n            }\n        }\n        ctx.stroke();\n\n        ctx.fillStyle = 'black';\n\n        if (this.browser.rulerLocation == 'right') {\n            ctx.textAlign = 'right';\n            ctx.fillText(formatQuantLabel(quant.max), w-9, 8);\n            ctx.fillText(formatQuantLabel(quant.min), w-9, h + this.padding);\n            for (var t = 1; t < numTics-1; ++t) {\n                var ty = t*ticSpacing;\n                ctx.fillText(formatQuantLabel((1.0*quant.max) - (t*ticInterval)), w - 9, ty + 3);\n            }\n        } else {\n            ctx.textAlign = 'left';\n            ctx.fillText(formatQuantLabel(quant.max), 9, 8);\n            ctx.fillText(formatQuantLabel(quant.min), 9, h + this.padding);\n            for (var t = 1; t < numTics-1; ++t) {\n                var ty = t*ticSpacing;\n                ctx.fillText(formatQuantLabel((1.0*quant.max) - (t*ticInterval)), 9, ty + 3);\n            }\n        }\n    } else {\n        this.quantOverlay.style.display = 'none';\n    }\n}\n\nfunction glyphsForGroup(features, y, groupElement, tier, connectorType) {\n    var gstyle = tier.styleForFeature(groupElement);\n    var label;\n    var labelWanted = false;\n\n    var glyphs = [];\n    var strand = null;\n    for (var i = 0; i < features.length; ++i) {\n        var f = features[i];\n        if (f.orientation && strand==null) {\n            strand = f.orientation;\n        }\n         if (!label && f.label) {\n            label = f.label;\n        }\n\n        var style = tier.styleForFeature(f);\n        if (!style) {\n            continue;\n        }\n        if (f.parts) {  // FIXME shouldn't really be needed\n            continue;\n        }\n        if (isDasBooleanTrue(style.LABEL))\n            labelWanted = true;\n\n        var g = glyphForFeature(f, 0, style, tier, null, true);\n        if (g) {\n            glyphs.push(g);\n        }\n    }\n\n    if (glyphs.length == 0)\n        return null;\n    \n    var connector = 'flat';\n    if (gstyle && gstyle.glyph === 'LINE') {\n        // Stick with flat...\n    } else {\n        if (tier.dasSource.collapseSuperGroups && !tier.bumped) {\n            if (strand === '+') {\n                connector = 'collapsed+';\n            } else if (strand === '-') {\n                connector = 'collapsed-';\n            }\n        } else {\n            if (strand === '+') {\n                connector = 'hat+';\n            } else if (strand === '-') {\n                connector = 'hat-';\n            }\n        }\n    }   \n\n    var labelText = null;\n    if ((label && labelWanted) || (gstyle && (isDasBooleanTrue(gstyle.LABEL) || isDasBooleanTrue(gstyle.LABELS)))) {  // HACK, LABELS should work.\n        labelText = groupElement.label || label;\n    }\n\n    var gg = new GroupGlyph(glyphs, connector);\n    if (labelText) {\n        if (strand === '+') {\n            labelText = '>' + labelText;\n        } else if (strand === '-') {\n            labelText = '<' + labelText;\n        }\n        gg = new LabelledGlyph(GLOBAL_GC, gg, labelText, false);\n    }\n    gg.bump = true;\n    return gg;\n}\n\nfunction glyphForFeature(feature, y, style, tier, forceHeight, noLabel)\n{\n    function getRefSeq(tier, min, max) {\n        var refSeq = null;\n        if (tier.currentSequence) {\n            var csStart = tier.currentSequence.start|0;\n            var csEnd = tier.currentSequence.end|0;\n            if (csStart <= max && csEnd >= min) {\n                var sfMin = Math.max(min, csStart);\n                var sfMax = Math.min(max, csEnd);\n\n                refSeq = tier.currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1);\n                while (min < sfMin) {\n                    refSeq = 'N' + refSeq;\n                    sfMin--;\n                }\n                while (max > sfMax) {\n                    refSeq = refSeq + 'N';\n                    sfMax++;\n                }\n            }\n        }\n        return refSeq;\n    }\n\n    var scale = tier.browser.scale, origin = tier.browser.viewStart;\n    var gtype = style.glyph || 'BOX';\n    var glyph;\n\n    var min = feature.min;\n    var max = feature.max;\n    var type = feature.type;\n    var strand = feature.orientation;\n    var score = feature.score;\n    var label = feature.label || feature.id;\n\n    var minPos = (min - origin) * scale;\n    var rawMaxPos = ((max - origin + 1) * scale);\n    var maxPos = Math.max(rawMaxPos, minPos + 1);\n\n    var height = tier.forceHeight || style.HEIGHT || forceHeight || 12;\n    var requiredHeight = height = 1.0 * height;\n    var bump = style.BUMP && isDasBooleanTrue(style.BUMP);\n\n    var gg, quant;\n\n    if (gtype === 'CROSS' || gtype === 'EX' || gtype === 'TRIANGLE' || gtype === 'DOT' || gtype === 'SQUARE' || gtype === 'STAR' || gtype === 'PLIMSOLL') {\n        var stroke = style.FGCOLOR || 'black';\n        var fill = style.BGCOLOR || 'none';\n        var outline = style.STROKECOLOR;\n\n        if (style.BGITEM && feature.itemRgb) {\n            stroke = feature.itemRgb;\n        } else if (isDasBooleanTrue(style.COLOR_BY_SCORE2)) {\n            var grad = style.BGGRAD || style._gradient;\n            if (!grad) {\n                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);\n                style._gradient = grad;\n            }\n\n            var sc2 = feature.score2;\n            if (sc2 != undefined || !stroke) {\n                sc2 = sc2 || 0;\n\n                var smin2 = style.MIN2 ? (1.0 * style.MIN2) : 0.0;\n                var smax2 = style.MAX2 ? (1.0 * style.MAX2) : 1.0;\n                var relScore2 = ((1.0 * sc2) - smin2) / (smax2-smin2);\n\n                var step = (relScore2*grad.length)|0;\n                if (step < 0) step = 0;\n                if (step >= grad.length) step = grad.length - 1;\n                stroke = grad[step];\n            }\n        }\n\n\n\n        var height = tier.forceHeight || style.HEIGHT || forceHeight || 12;\n        requiredHeight = height = 1.0 * height;\n\n        var size = style.SIZE || height;\n        if (style.RSIZE) {\n            size = (1.0 * style.RSIZE) * height;\n        }\n\n        if (style.STROKETHRESHOLD) {\n            if (size < (1.0 * style.STROKETHRESHOLD))\n                outline = null;\n        }\n        \n        size = 1.0 * size;\n\n        var mid = (minPos + maxPos)/2;\n        var hh = size/2;\n\n        var mark;\n        var bMinPos = minPos, bMaxPos = maxPos;\n\n        if (gtype === 'EX') {\n            gg = new ExGlyph(mid, size, stroke);\n        } else if (gtype === 'TRIANGLE') {\n            var dir = style.DIRECTION || 'N';\n            var width = style.LINEWIDTH || size;\n            gg = new TriangleGlyph(mid, size, dir, width, stroke, outline);\n        } else if (gtype === 'DOT') {\n            gg = new DotGlyph(mid, size, stroke, outline);\n        } else if (gtype === 'PLIMSOLL') {\n            gg = new PlimsollGlyph(mid, size, 0.2 * size, stroke, outline);\n        } else if (gtype === 'SQUARE') {\n            gg = new BoxGlyph(mid - hh, 0, size, size, stroke, outline);\n        } else if (gtype === 'STAR') {\n            var points = 5;\n            if (style.POINTS) \n                points = style.POINTS | 0;\n            gg = new StarGlyph(mid, hh, points, stroke, outline);\n        } else {\n            gg = new CrossGlyph(mid, size, stroke);\n        }\n\n        if (fill && fill != 'none' && (maxPos - minPos) > 5) {\n            var bgg = new BoxGlyph(minPos, 0, (maxPos - minPos), size, fill);\n            gg = new GroupGlyph([bgg, gg]);\n        }\n\n        if (isDasBooleanTrue(style.SCATTER)) {\n            var smin = tier.quantMin(style);\n            var smax = tier.quantMax(style);\n\n            if (!smax) {\n                if (smin < 0) {\n                    smax = 0;\n                } else {\n                    smax = 10;\n                }\n            }\n            if (!smin) {\n                smin = 0;\n            }\n\n            var relScore = ((1.0 * score) - smin) / (smax-smin);\n            var relOrigin = (-1.0 * smin) / (smax - smin);\n\n            if (relScore < 0.0 || relScore > 1.0) {\n                // Glyph is out of bounds.\n                // Should we allow for \"partially showing\" glyphs?\n\n                return null;\n            } else {\n                if (relScore >= relOrigin) {\n                    height = Math.max(1, (relScore - relOrigin) * requiredHeight);\n                    y = y + ((1.0 - relOrigin) * requiredHeight) - height;\n                } else {\n                    height = Math.max(1, (relScore - relOrigin) * requiredHeight);\n                    y = y + ((1.0 - relOrigin) * requiredHeight);\n                }\n                \n                quant = {min: smin, max: smax};\n\n                var heightFudge = 0;\n                var featureLabel;\n                if (typeof(feature.forceLabel) !== 'undefined')\n                    featureLabel = feature.forceLabel;\n                else\n                    featureLabel = style.LABEL;\n\n                if (isDasBooleanNotFalse(featureLabel) && label && !noLabel) {\n                    gg = new LabelledGlyph(GLOBAL_GC, gg, label, true, null, featureLabel == 'above' ? 'above' : 'below');\n                    if (featureLabel == 'above') {\n                        heightFudge = gg.textHeight + 2;\n                    }\n                    noLabel = true;\n                }\n                gg = new TranslatedGlyph(gg, 0, y - hh - heightFudge, requiredHeight);\n            }\n        }\n    } else if (gtype === 'HISTOGRAM' || gtype === 'GRADIENT' && score !== 'undefined') {\n        var smin = tier.quantMin(style);\n        var smax = tier.quantMax(style);\n\n        if (!smax) {\n            if (smin < 0) {\n                smax = 0;\n            } else {\n                smax = 10;\n            }\n        }\n        if (!smin) {\n            smin = 0;\n        }\n\n        if ((1.0 * score) < (1.0 *smin)) {\n            score = smin;\n        }\n        if ((1.0 * score) > (1.0 * smax)) {\n            score = smax;\n        }\n        var relScore = ((1.0 * score) - smin) / (smax-smin);\n        var relOrigin = (-1.0 * smin) / (smax - smin);\n\n        if (gtype === 'HISTOGRAM') {\n            if (relScore >= relOrigin) {\n                height = (relScore - Math.max(0, relOrigin)) * requiredHeight;\n                y = y + ((1.0 - Math.max(0, relOrigin)) * requiredHeight) - height;\n            } else {\n                height = (Math.max(0, relOrigin) - relScore) * requiredHeight;\n                y = y + ((1.0 - Math.max(0, relOrigin)) * requiredHeight);\n            }\n            quant = {min: smin, max: smax};\n        }\n\n        var stroke = style.FGCOLOR || null;\n        var fill = style.BGCOLOR || style.COLOR1 || 'green';\n        if (style.BGITEM && feature.itemRgb)\n            fill = feature.itemRgb;\n        var alpha = style.ALPHA ? (1.0 * style.ALPHA) : null;\n\n        if (style.BGGRAD) {\n            var grad = style.BGGRAD;\n            var step = (relScore*grad.length)|0;\n            if (step < 0) step = 0;\n            if (step >= grad.length) step = grad.length - 1;\n            fill = grad[step];\n        }\n        if (style.COLOR2) {\n            var grad = style._gradient;\n            if (!grad) {\n                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);\n                style._gradient = grad;\n            }\n\n            var step = (relScore*grad.length)|0;\n            if (step < 0) step = 0;\n            if (step >= grad.length) step = grad.length - 1;\n            fill = grad[step];\n        }\n\n        gg = new BoxGlyph(minPos, y, (maxPos - minPos), height, fill, stroke, alpha);\n        gg = new TranslatedGlyph(gg, 0, 0, requiredHeight);\n    } else if (gtype === 'HIDDEN') {\n        gg = new PaddedGlyph(null, minPos, maxPos);\n        noLabel = true;\n    } else if (gtype === 'ARROW') {\n        var color = style.FGCOLOR || 'purple';\n        var parallel = isDasBooleanTrue(style.PARALLEL);\n        var sw = isDasBooleanTrue(style.SOUTHWEST);\n        var ne = isDasBooleanTrue(style.NORTHEAST);\n        gg = new ArrowGlyph(minPos, maxPos, height, color, parallel, sw, ne);\n    } else if (gtype === 'ANCHORED_ARROW') {\n        var stroke = style.FGCOLOR || 'none';\n        var fill = style.BGCOLOR || 'green';\n        gg = new AArrowGlyph(minPos, maxPos, height, fill, stroke, strand);\n        gg.bump = true;\n    } else if (gtype === 'SPAN') {\n        var stroke = style.FGCOLOR || 'black';\n        gg = new SpanGlyph(minPos, maxPos, height, stroke);\n    } else if (gtype === 'LINE') {\n        var stroke = style.FGCOLOR || 'black';\n        var lineStyle = style.STYLE || 'solid';\n        gg = new LineGlyph(minPos, maxPos, height, lineStyle, strand, stroke);\n    } else if (gtype === 'PRIMERS') {\n        var stroke = style.FGCOLOR || 'black';\n        var fill = style.BGCOLOR || 'red';\n        gg = new PrimersGlyph(minPos, maxPos, height, fill, stroke);\n    } else if (gtype === 'TEXT') {\n        var string = style.STRING || 'text';\n        var fill = style.FGCOLOR || 'black';\n        gg = new TextGlyph(GLOBAL_GC, minPos, maxPos, height, fill, string);\n    } else if (gtype === 'TOOMANY') {\n        var stroke = style.FGCOLOR || 'gray';\n        var fill = style.BGCOLOR || 'orange';\n        gg = new TooManyGlyph(minPos, maxPos, height, fill, stroke);\n    } else if (gtype === 'POINT') {\n        var height = tier.forceHeight || style.HEIGHT || 30;\n        var smin = tier.quantMin(style);\n        var smax = tier.quantMax(style);\n        var yscale = ((1.0 * height) / (smax - smin));\n        var relScore = ((1.0 * score) - smin) / (smax-smin);\n        var sc = ((score - (1.0*smin)) * yscale)|0;\n        quant = {min: smin, max: smax};\n\n        var fill = style.FGCOLOR || style.COLOR1 || 'black';\n        if (style.COLOR2) {\n            var grad = style._gradient;\n            if (!grad) {\n                grad = makeGradient(50, style.COLOR1, style.COLOR2, style.COLOR3);\n                style._gradient = grad;\n            }\n\n            var step = (relScore*grad.length)|0;\n            if (step < 0) step = 0;\n            if (step >= grad.length) step = grad.length - 1;\n            fill = grad[step];\n        } \n\n        gg = new PointGlyph((minPos + maxPos)/2, height-sc, height, fill);\n    } else if (gtype === '__SEQUENCE') {\n        var rawseq = feature.seq;\n        var seq = rawseq;\n        var rawquals = feature.quals;\n        var quals = rawquals;\n        var insertionLabels = isDasBooleanTrue(style.__INSERTIONS);\n\n        var indels = [];\n        if (feature.cigar) {\n            var ops = parseCigar(feature.cigar);\n            seq = ''\n            quals = '';\n            var cursor = 0;\n            for (var ci = 0; ci < ops.length; ++ci) {\n                var co = ops[ci];\n                if (co.op == 'M') {\n                    seq += rawseq.substr(cursor, co.cnt);\n                    quals += rawquals.substr(cursor, co.cnt);\n                    cursor += co.cnt;\n                } else if (co.op == 'D') {\n                    for (var oi = 0; oi < co.cnt; ++oi) {\n                        seq += '-';\n                        quals += 'Z';\n                    }\n                } else if (co.op == 'I') {\n                    var inseq =  rawseq.substr(cursor, co.cnt);\n                    var ig = new TriangleGlyph(minPos + (seq.length*scale), 5, 'S', 5, tier.browser.baseColors['I']);\n                    if (insertionLabels)\n                        ig = new LabelledGlyph(GLOBAL_GC, ig, inseq, false, 'center', 'above', '7px sans-serif');\n                    ig.feature = {label: 'Insertion: ' + inseq, type: 'insertion', method: 'insertion'};\n                    indels.push(ig);\n\n                    cursor += co.cnt;\n                } else if (co.op == 'S') {\n                    cursor += co.cnt;\n                } else {\n                    console.log('unknown cigop' + co.op);\n                }\n            }\n        }\n\n        var refSeq = getRefSeq(tier, min, max);\n        if (seq && refSeq && (style.__SEQCOLOR === 'mismatch' || style.__SEQCOLOR === 'mismatch-all')) {\n            var mismatchSeq = [];\n            var match = feature.orientation === '-' ? ',' : '.';\n            for (var i = 0; i < seq.length; ++i)\n                mismatchSeq.push(seq[i] == refSeq[i] ? match : seq[i]);\n            seq = mismatchSeq.join('');\n        }\n\n        var strandColor;\n        if (feature.orientation === '-')\n            strandColor = style._minusColor || 'lightskyblue';\n        else\n            strandColor = style._plusColor || 'lightsalmon';\n\n        if (style.__disableQuals)\n            quals = false;\n        \n        gg = new SequenceGlyph(\n            tier.browser.baseColors, \n            strandColor, \n            minPos, \n            maxPos, \n            height, \n            seq, \n            refSeq, \n            style.__SEQCOLOR, \n            quals,\n            !isDasBooleanTrue(style.__CLEARBG),\n            tier.scaleVertical\n        );\n        if (insertionLabels)\n            gg = new TranslatedGlyph(gg, 0, 7);\n        if (indels.length > 0) {\n            indels.splice(0, 0, gg);\n            gg = new GroupGlyph(indels);\n        }\n    } else if (gtype === '__INSERTION') {\n        var ig = new TriangleGlyph(minPos, 5, 'S', 5, tier.browser.baseColors['I']);\n        gg = new LabelledGlyph(GLOBAL_GC, ig, feature.insertion || feature.altAlleles[0], false, 'center', 'above', '7px sans-serif');\n        if ((maxPos - minPos) > 1) {\n            var fill = style.BGCOLOR || style.COLOR1 || 'green';\n            var bg = new BoxGlyph(minPos, 5, (maxPos - minPos), height, fill, stroke);\n            gg = new GroupGlyph([bg, gg]);\n        }\n    } else if (gtype === '__NONE') {\n        return null;\n    } else /* default to BOX */ {\n        var stroke = style.FGCOLOR || null;\n        var fill = style.BGCOLOR || style.COLOR1 || 'green';\n        if (style.BGITEM && feature.itemRgb)\n            fill = feature.itemRgb;\n        var scale = (maxPos - minPos) / (max - min);\n        if (feature.type == 'translation' &&\n            (feature.method == 'protein_coding' || feature.readframeExplicit) &&\n            (!feature.tags || feature.tags.indexOf('cds_start_NF') < 0 || feature.readframeExplicit) &&\n            (!tier.dasSource.collapseSuperGroups || tier.bumped)\n            && scale >= 0.5) {\n            var refSeq = getRefSeq(tier, min, max);\n            gg = new AminoAcidGlyph(minPos, maxPos, height, fill, refSeq, feature.orientation, feature.readframe);    \n        } else {\n            gg = new BoxGlyph(minPos, 0, (maxPos - minPos), height, fill, stroke);\n        }\n        // gg.bump = true;\n    }\n\n    if ((isDasBooleanTrue(style.LABEL) || feature.forceLabel) && label && !noLabel) {\n        gg = new LabelledGlyph(GLOBAL_GC, gg, label, false);\n    }\n\n    if (bump) {\n        gg.bump = true;\n    }\n\n    gg.feature = feature;\n    if (quant) {\n        gg.quant = quant;\n    }\n\n    if (style.ZINDEX) {\n        gg.zindex = style.ZINDEX | 0;\n    }\n\n    return gg;\n}\n\nDasTier.prototype.styleForFeature = function(f) {\n    var ssScale = this.browser.zoomForCurrentScale();\n\n    if (!this.stylesheet) {\n        return null;\n    }\n\n    var maybe = null;\n    var ss = this.stylesheet.styles;\n    for (var si = 0; si < ss.length; ++si) {\n        var sh = ss[si];\n        if (sh.zoom && sh.zoom != ssScale) {\n            continue;\n        }\n\n        if (sh.orientation) {\n            if (sh.orientation != f.orientation) {\n                continue;\n            }\n        }\n\n        var labelRE = sh._labelRE;\n        if (!labelRE || !labelRE.test) {\n            labelRE = new RegExp('^' + sh.label + '$');\n            sh._labelRE = labelRE;\n        }\n        if (sh.label && !(labelRE.test(f.label))) {\n            continue;\n        }\n        var methodRE = sh._methodRE;\n        if (!methodRE || !methodRE.test) {\n            methodRE = new RegExp('^' + sh.method + '$');\n            sh._methodRE = methodRE;\n        }\n        if (sh.method && !(methodRE.test(f.method))) {\n            continue;\n        }\n        if (sh.type) {\n            if (sh.type == 'default') {\n                if (!maybe) {\n                    maybe = sh.style;\n                }\n                continue;\n            } else {\n                var typeRE = sh._typeRE;\n                if (!typeRE || !typeRE.test) {\n                    typeRE = new RegExp('^' + sh.type + '$');\n                    sh._typeRE = typeRE;\n                }\n                if (!typeRE.test(f.type)) \n                    continue;\n            }\n        }\n        return sh.style;\n    }\n    return maybe;\n}\n\nfunction makeLineGlyph(features, style, tier) {\n    var origin = tier.browser.viewStart, scale = tier.browser.scale;\n    var height = tier.forceHeight || style.HEIGHT || 30;\n    var min = tier.quantMin(style);\n    var max = tier.quantMax(style);\n    var yscale = ((1.0 * height) / (max - min));\n    var width = style.LINEWIDTH || 1;\n    var color = style.FGCOLOR || style.COLOR1 || 'black';\n\n    var points = [];\n    for (var fi = 0; fi < features.length; ++fi) {\n        var f = features[fi];\n\n        var px = ((((f.min|0) + (f.max|0)) / 2) - origin) * scale;\n        var sc = ((f.score - (1.0*min)) * yscale)|0;\n        var py = (height - sc);  // FIXME y???\n        points.push(px);\n        points.push(py);\n    }\n    var lgg = new LineGraphGlyph(points, color, height);\n    lgg.quant = {min: min, max: max};\n\n    if (style.ZINDEX) \n        lgg.zindex = style.ZINDEX|0;\n\n    return lgg;\n}\n\nDasTier.prototype.quantMin = function(style) {\n    if (this.forceMinDynamic) {\n        return this.currentFeaturesMinScore || 0;\n    } else if (typeof(this.forceMin) === 'number') {\n        return this.forceMin;\n    } else {\n        return style.MIN || this.currentFeaturesMinScore || 0;\n    }\n}\n\nDasTier.prototype.quantMax = function(style) {\n    if (this.forceMaxDynamic) {\n        return this.currentFeaturesMaxScore || 0;\n    } else if (typeof(this.forceMax) === 'number') {\n        return this.forceMax;\n    } else {\n        return style.MAX || this.currentFeaturesMaxScore || 0;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        drawFeatureTier: drawFeatureTier\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// feature-popup.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var pick = utils.pick;\n    var pushnew = utils.pushnew;\n    var makeElement = utils.makeElement;\n}\n\n\nvar TAGVAL_NOTE_RE = new RegExp('^([A-Za-z_-]+)=(.+)');\n\nBrowser.prototype.addFeatureInfoPlugin = function(handler) {\n    if (!this.featureInfoPlugins) {\n        this.featureInfoPlugins = [];\n    }\n    this.featureInfoPlugins.push(handler);\n}\n\nfunction FeatureInfo(hit, feature, group) {\n    var name = pick(group.type, feature.type);\n    var fid = pick(group.label, feature.label, group.id, feature.id);\n    if (fid && fid.indexOf('__dazzle') != 0) {\n        name = name + ': ' + fid;\n    }\n\n    this.hit = hit;\n    this.feature = feature;\n    this.group = group;\n    this.title = name;\n    this.sections = [];\n}\n\nFeatureInfo.prototype.setTitle = function(t) {\n    this.title = t;\n}\n\nFeatureInfo.prototype.add = function(label, info) {\n    if (typeof info === 'string') {\n        info = makeElement('span', info);\n    }\n    this.sections.push({label: label, info: info});\n}\n\nBrowser.prototype.featurePopup = function(ev, __ignored_feature, hit, tier) {\n    var hi = hit.length;\n    var feature = --hi >= 0 ? hit[hi] : {};\n    var group = --hi >= 0 ? hit[hi] : {};\n\n    var featureInfo = new FeatureInfo(hit, feature, group);\n    featureInfo.tier = tier;\n    var fips = this.featureInfoPlugins || [];\n    for (var fipi = 0; fipi < fips.length; ++fipi) {\n        try {\n            fips[fipi](feature, featureInfo);\n        } catch (e) {\n            console.log(e.stack || e);\n        }\n    }\n    fips = tier.featureInfoPlugins || [];\n    for (fipi = 0; fipi < fips.length; ++fipi) {\n        try {\n            fips[fipi](feature, featureInfo);\n        } catch (e) {\n            console.log(e.stack || e);\n        }\n    }\n\n    this.removeAllPopups();\n\n    var table = makeElement('table', null, {className: 'table table-striped table-condensed'});\n    table.style.width = '100%';\n    table.style.margin = '0px';\n\n    var idx = 0;\n    if (feature.method) {\n        var row = makeElement('tr', [\n            makeElement('th', 'Method'),\n            makeElement('td', feature.method)\n        ]);\n        table.appendChild(row);\n        ++idx;\n    }\n    {\n        var loc;\n        if (group.segment) {\n            loc = group;\n        } else {\n            loc = feature;\n        }\n        var row = makeElement('tr', [\n            makeElement('th', 'Location'),\n            makeElement('td', loc.segment + ':' + loc.min + '-' + loc.max, {}, {minWidth: '200px'})\n        ]);\n        table.appendChild(row);\n        ++idx;\n    }\n    if (feature.score !== undefined && feature.score !== null && feature.score != '-'\n        && !feature.suppressScore) {\n        var row = makeElement('tr', [\n            makeElement('th', 'Score'),\n            makeElement('td', '' + feature.score)\n        ]);\n        table.appendChild(row);\n        ++idx;\n    }\n    {\n        var links = maybeConcat(group.links, feature.links);\n        if (links && links.length > 0) {\n            var row = makeElement('tr', [\n                makeElement('th', 'Links'),\n                makeElement('td', links.map(function(l) {\n                    return makeElement('div', makeElement('a', l.desc, {href: l.uri, target: '_new'}));\n                }))\n            ]);\n            table.appendChild(row);\n            ++idx;\n        }\n    }\n    {\n        var notes = maybeConcat(group.notes, feature.notes);\n        for (var ni = 0; ni < notes.length; ++ni) {\n            var k = 'Note';\n            var v = notes[ni];\n            var m = v.match(TAGVAL_NOTE_RE);\n            if (m) {\n                k = m[1];\n                v = m[2];\n            }\n\n            var row = makeElement('tr', [\n                makeElement('th', k),\n                makeElement('td', v)\n            ]);\n            table.appendChild(row);\n            ++idx;\n        }\n    }\n\n    for (var fisi = 0; fisi < featureInfo.sections.length; ++fisi) {\n        var section = featureInfo.sections[fisi];\n        table.appendChild(makeElement('tr', [\n            makeElement('th', section.label),\n            makeElement('td', section.info)]));\n    }        \n\n    this.popit(ev, featureInfo.title || 'Feature', table, {width: 450});\n}\n\nfunction maybeConcat(a, b) {\n    var l = [];\n    if (a) {\n        for (var i = 0; i < a.length; ++i) {\n            pushnew(l, a[i]);\n        }\n    }\n    if (b) {\n        for (var i = 0; i < b.length; ++i) {\n            pushnew(l, b[i]);\n        }\n    }\n    return l;\n}\n","\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var pusho = utils.pusho;\n    var pushnewo = utils.pushnewo;\n}\n\nfunction sortFeatures(tier)\n{\n    var dmin = tier.browser.drawnStart, dmax = tier.browser.drawnEnd;\n    var ungroupedFeatures = {};\n    var groupedFeatures = {};\n    var drawnGroupedFeatures = {};\n    var groupMins = {}, groupMaxes = {};\n    var groups = {};\n    var superGroups = {};\n    var groupsToSupers = {};\n    var nonPositional = [];\n    var minScore, maxScore;\n    var fbid;\n\n    var init_fbid = function() {\n        fbid = {};\n        for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {\n            var f = tier.currentFeatures[fi];\n            if (f.id) {\n                fbid[f.id] = f;\n            }\n        }\n    };\n    \n    var superParentsOf = function(f) {\n        // FIXME: should recur.\n        var spids = [];\n        if (f.parents) {\n            for (var pi = 0; pi < f.parents.length; ++pi) {\n                var pid = f.parents[pi];\n                var p = fbid[pid];\n                if (!p) {\n                    continue;\n                }\n                // alert(p.type + ':' + p.typeCv);\n                if (p.typeCv == 'SO:0000704') {\n                    pushnew(spids, pid);\n                }\n            }\n        }\n        return spids;\n    }\n\n    for (var fi = 0; fi < tier.currentFeatures.length; ++fi) {\n        var f = tier.currentFeatures[fi];\n        if (f.parts) {\n            continue;\n        }\n\n        var drawn = f.min <= dmax && f.max >= dmin;\n\n        if (!f.min || !f.max) {\n            nonPositional.push(f);\n            continue;\n        }\n\n        if (f.score && f.score != '.' && f.score != '-') {\n            var sc = 1.0 * f.score;\n            if (!minScore || sc < minScore) {\n                minScore = sc;\n            }\n            if (!maxScore || sc > maxScore) {\n                maxScore = sc;\n            }\n        }\n\n        var fGroups = [];\n        var fSuperGroup = null;\n        if (f.groups) {\n            for (var gi = 0; gi < f.groups.length; ++gi) {\n                var g = f.groups[gi];\n                var gid = g.id;\n                if (g.type == 'gene') {\n                    // Like a super-grouper...\n                    fSuperGroup = gid; \n                    groups[gid] = g;\n                } else if (g.type == 'translation') {\n                    // have to ignore this to get sensible results from bj-e :-(.\n                } else {\n                    pusho(groupedFeatures, gid, f);\n                    groups[gid] = g;\n                    fGroups.push(gid);\n\n                    var ogm = groupMins[gid];\n                    if (!ogm || f.min < ogm)\n                        groupMins[gid] = f.min;\n\n                    ogm = groupMaxes[gid];\n                    if (!ogm || f.max > ogm)\n                        groupMaxes[gid] = f.max;\n                }\n            }\n        }\n\n        if (f.parents) {\n            if (!fbid) {\n                init_fbid();\n            }\n            for (var pi = 0; pi < f.parents.length; ++pi) {\n                var pid = f.parents[pi];\n                var p = fbid[pid];\n                if (!p) {\n                    // alert(\"couldn't find \" + pid);\n                    continue;\n                }\n                if (!p.parts) {\n                    p.parts = [f];\n                }\n                pushnewo(groupedFeatures, pid, p);\n                pusho(groupedFeatures, pid, f);\n                \n                if (!groups[pid]) {\n                    groups[pid] = {\n                        type: p.type,\n                        id: p.id,\n                        label: p.label || p.id\n                    };\n                }\n                fGroups.push(pid);\n\n                var ogm = groupMins[pid];\n                if (!ogm || f.min < ogm)\n                    groupMins[pid] = f.min;\n\n                ogm = groupMaxes[pid];\n                if (!ogm || f.max > ogm)\n                    groupMaxes[pid] = f.max;\n\n                var sgs = superParentsOf(p);\n                if (sgs.length > 0) {\n                    fSuperGroup = sgs[0];\n                    var sp = fbid[sgs[0]];\n                    groups[sgs[0]] = {\n                        type: sp.type,\n                        id: sp.id,\n                        label: sp.label || sp.id\n                    };\n                    if (!tier.dasSource.collapseSuperGroups) {\n                        tier.dasSource.collapseSuperGroups = true;\n                    }\n                }\n            }   \n        }\n\n        if (fGroups.length == 0) {\n            if (drawn)\n                pusho(ungroupedFeatures, f.type, f);\n        } else if (fSuperGroup) {\n            for (var g = 0; g < fGroups.length; ++g) {\n                var gid = fGroups[g];\n                pushnewo(superGroups, fSuperGroup, gid);\n                groupsToSupers[gid] = fSuperGroup;\n            } \n        }       \n    }\n\n    for (var gid in groupedFeatures) {\n        var group = groups[gid];\n        if (typeof(group.min) !== 'number') \n            group.min = groupMins[gid];\n        if (typeof(group.max) !== 'number') \n            group.max = groupMaxes[gid];\n\n        if (groupMaxes[gid] >= dmin && groupMins[gid] <= dmax)\n            drawnGroupedFeatures[gid] = groupedFeatures[gid];\n    }\n\n    tier.ungroupedFeatures = ungroupedFeatures;\n    tier.groupedFeatures = drawnGroupedFeatures;\n    tier.groups = groups;\n    tier.superGroups = superGroups;\n    tier.groupsToSupers = groupsToSupers;\n\n    if (minScore) {\n        if (minScore > 0) {\n            minScore = 0;\n        } else if (maxScore < 0) {\n            maxScore = 0;\n        }\n        tier.currentFeaturesMinScore = minScore;\n        tier.currentFeaturesMaxScore = maxScore;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        sortFeatures: sortFeatures\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// glyphs.js: components which know how to draw themselves\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var union = spans.union;\n    var Range = spans.Range;\n\n    var utils = require('./utils');\n    var makeElementNS = utils.makeElementNS;\n    var AMINO_ACID_TRANSLATION = utils.AMINO_ACID_TRANSLATION;\n\n    var svgu = require('./svg-utils');\n    var NS_SVG = svgu.NS_SVG;\n    var NS_XLINK = svgu.NS_XLINK;\n    var SVGPath = svgu.SVGPath;\n}\n\nfunction PathGlyphBase(stroke, fill) {\n    this._stroke = stroke;\n    this._fill = fill;\n}\n\nPathGlyphBase.prototype.draw = function(g) {\n    g.beginPath();\n    this.drawPath(g);\n\n    if (this._fill) {\n        g.fillStyle = this._fill;\n        g.fill();\n    }\n    if (this._stroke) {\n        g.strokeStyle = this._stroke;\n        g.stroke();\n    }\n}\n\nPathGlyphBase.prototype.toSVG = function() {\n    var g = new SVGPath();\n    this.drawPath(g);\n    \n    return makeElementNS(\n        NS_SVG, 'path',\n        null,\n        {d: g.toPathData(),\n         fill: this._fill || 'none',\n         stroke: this._stroke || 'none'});\n}\n\nPathGlyphBase.prototype.drawPath = function(g) {\n    throw 'drawPath method on PathGlyphBase must be overridden';\n}\n\nfunction BoxGlyph(x, y, width, height, fill, stroke, alpha, radius) {\n    this.x = x;\n    this.y = y;\n    this._width = width;\n    this._height = height;\n    this.fill = fill;\n    this.stroke = stroke;\n    this._alpha = alpha;\n    this._radius = radius || 0;\n}\n\nBoxGlyph.prototype.draw = function(g) {\n    var r = this._radius;\n\n    if (r > 0) {\n        g.beginPath();\n        g.moveTo(this.x + r, this.y);\n        g.lineTo(this.x + this._width - r, this.y);\n        g.arcTo(this.x + this._width, this.y, this.x + this._width, this.y + r, r);\n        g.lineTo(this.x + this._width, this.y + this._height - r);\n        g.arcTo(this.x + this._width, this.y + this._height, this.x + this._width - r, this.y + this._height, r);\n        g.lineTo(this.x + r, this.y + this._height);\n        g.arcTo(this.x, this.y + this._height, this.x, this.y + this._height - r, r);\n        g.lineTo(this.x, this.y + r);\n        g.arcTo(this.x, this.y, this.x + r, this.y, r);\n        g.closePath();\n\n        if (this._alpha != null) {\n            g.save();\n            g.globalAlpha = this._alpha;\n        }\n        \n        if (this.fill) {\n            g.fillStyle = this.fill;\n            g.fill();\n        }\n        if (this.stroke) {\n            g.strokeStyle = this.stroke;\n            g.lineWidth = 0.5;\n            g.stroke();\n        }\n\n        if (this._alpha != null) {\n            g.restore();\n        }\n    } else {\n        if (this._alpha != null) {\n            g.save();\n            g.globalAlpha = this._alpha;\n        }\n\n        if (this.fill) {\n            g.fillStyle = this.fill;\n            g.fillRect(this.x, this.y, this._width, this._height);\n        }\n\n        if (this.stroke) {\n            g.strokeStyle = this.stroke;\n            g.lineWidth = 0.5;\n            g.strokeRect(this.x, this.y, this._width, this._height)\n        }\n\n        if (this._alpha != null) {\n            g.restore();\n        }\n    }\n}\n\nBoxGlyph.prototype.toSVG = function() {\n    var s = makeElementNS(NS_SVG, 'rect', null,\n                         {x: this.x, \n                          y: this.y, \n                          width: this._width, \n                          height: this._height,\n                          stroke: this.stroke || 'none',\n                          strokeWidth: 0.5,\n                          fill: this.fill || 'none'});\n    if (this._alpha != null) {\n        s.setAttribute('opacity', this._alpha);\n    }\n\n    return s;\n}\n\nBoxGlyph.prototype.min = function() {\n    return this.x;\n}\n\nBoxGlyph.prototype.max = function() {\n    return this.x + this._width;\n}\n\nBoxGlyph.prototype.height = function() {\n    return this.y + this._height;\n}\n\n\nfunction GroupGlyph(glyphs, connector) {\n    this.glyphs = glyphs;\n    this.connector = connector;\n    this.h = glyphs[0].height();\n\n    var covList = [];\n    for (var g = 0; g < glyphs.length; ++g) {\n        var gg = glyphs[g];\n        covList.push(new Range(gg.min(), gg.max()));\n        this.h = Math.max(this.h, gg.height());\n    }\n    this.coverage = union(covList);\n}\n\nGroupGlyph.prototype.drawConnectors = function(g) {\n    var ranges = this.coverage.ranges();\n    for (var r = 1; r < ranges.length; ++r) {\n        var gl = ranges[r];\n        var last = ranges[r - 1];\n        if (last && gl.min() > last.max()) {\n            var start = last.max();\n            var end = gl.min();\n            var mid = (start+end)/2\n            \n            if (this.connector === 'hat+') {\n                g.moveTo(start, this.h/2);\n                g.lineTo(mid, 0);\n                g.lineTo(end, this.h/2);\n            } else if (this.connector === 'hat-') {\n                g.moveTo(start, this.h/2);\n                g.lineTo(mid, this.h);\n                g.lineTo(end, this.h/2);\n            } else if (this.connector === 'collapsed+') {\n                g.moveTo(start, this.h/2);\n                g.lineTo(end, this.h/2);\n                if (end - start > 4) {\n                    g.moveTo(mid - 2, (this.h/2) - 3);\n                    g.lineTo(mid + 2, this.h/2);\n                    g.lineTo(mid - 2, (this.h/2) + 3);\n                }\n            } else if (this.connector === 'collapsed-') {\n                g.moveTo(start, this.h/2);\n                g.lineTo(end, this.h/2);\n                if (end - start > 4) {\n                    g.moveTo(mid + 2, (this.h/2) - 3);\n                    g.lineTo(mid - 2, this.h/2);\n                    g.lineTo(mid + 2, (this.h/2) + 3);\n                }\n            } else {\n                g.moveTo(start, this.h/2);\n                g.lineTo(end, this.h/2);\n            }\n        }\n        last = gl;\n    }\n}\n\nGroupGlyph.prototype.draw = function(g, oc) {\n    for (var i = 0; i < this.glyphs.length; ++i) {\n        var gl = this.glyphs[i];\n        gl.draw(g, oc);\n    }\n\n    g.strokeStyle = 'black';\n    g.beginPath();\n    this.drawConnectors(g);\n    g.stroke();\n}\n\nGroupGlyph.prototype.toSVG = function() {\n    var g = makeElementNS(NS_SVG, 'g');\n    for (var i = 0; i < this.glyphs.length; ++i) {\n        g.appendChild(this.glyphs[i].toSVG());\n    }\n\n    var p = new SVGPath();\n    this.drawConnectors(p);\n\n    var pathData = p.toPathData();\n    if (pathData.length > 0) {\n        var path = makeElementNS(\n            NS_SVG, 'path',\n            null,\n            {d: p.toPathData(),\n             fill: 'none',\n             stroke: 'black',\n             strokeWidth: 0.5});\n        g.appendChild(path);\n    }\n\n    return g;\n}\n\nGroupGlyph.prototype.min = function() {\n    return this.coverage.min();\n}\n\nGroupGlyph.prototype.max = function() {\n    return this.coverage.max();\n}\n\nGroupGlyph.prototype.height = function() {\n    return this.h;\n}\n\n\nfunction LineGraphGlyph(points, color, height) {\n    this.points = points;\n    this.color = color;\n    this._height = height || 50;\n}\n\nLineGraphGlyph.prototype.min = function() {\n    return this.points[0];\n};\n\nLineGraphGlyph.prototype.max = function() {\n    return this.points[this.points.length - 2];\n};\n\nLineGraphGlyph.prototype.height = function() {\n    return this._height;\n}\n\nLineGraphGlyph.prototype.draw = function(g) {\n    g.save();\n    g.strokeStyle = this.color;\n    g.lineWidth = 2;\n    g.beginPath();\n    for (var i = 0; i < this.points.length; i += 2) {\n        var x = this.points[i];\n        var y = this.points[i + 1];\n        if (i == 0) {\n            g.moveTo(x, y);\n        } else {\n            g.lineTo(x, y);\n        }\n    }\n    g.stroke();\n    g.restore();\n}\n\nLineGraphGlyph.prototype.toSVG = function() {\n    var p = new SVGPath();\n    for (var i = 0; i < this.points.length; i += 2) {\n        var x = this.points[i];\n        var y = this.points[i + 1];\n        if (i == 0) {\n            p.moveTo(x, y);\n        } else {\n            p.lineTo(x, y);\n        }\n    }\n    \n    return makeElementNS(\n        NS_SVG, 'path',\n        null,\n        {d: p.toPathData(),\n         fill: 'none',\n         stroke: this.color,\n         strokeWidth: '2px'});\n}\n\nfunction LabelledGlyph(GLOBAL_GC, glyph, text, unmeasured, anchor, align, font) {\n    this.glyph = glyph;\n    this.text = text;\n    this.anchor = anchor || 'left';\n    this.align = align || 'below';\n    if (font) {\n        this.font = font;\n    }\n    if (this.font) {\n        GLOBAL_GC.save();\n        GLOBAL_GC.font = this.font;\n    }\n    var metrics = GLOBAL_GC.measureText(text);\n    if (this.font) {\n        GLOBAL_GC.restore();\n    }\n    this.textLen = metrics.width;\n    this.textHeight = 5;\n    this.bump = glyph.bump;\n    this.measured = !unmeasured;\n}\n\nLabelledGlyph.prototype.toSVG = function() {\n    var child = this.glyph.toSVG();\n    var opts = {};\n    \n    if (this.align == 'above') {\n        child = makeElementNS(NS_SVG, 'g', child, {transform: \"translate(0, \" + (this.textHeight|0 + 2) + \")\"});\n        opts.y = this.textHeight;\n    } else {\n        opts.y = this.glyph.height() + 15;\n    }\n\n    if (this.font) {\n        opts.fontSize  = 7;\n    }\n\n    if ('center' == this.anchor) {\n        opts.x = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;\n    } else {\n        opts.x = this.glyph.min();\n    }\n\n    return makeElementNS(NS_SVG, 'g',\n        [child,\n         makeElementNS(NS_SVG, 'text', this.text, opts)]);\n}\n\nLabelledGlyph.prototype.min = function() {\n    return this.glyph.min();\n}\n\nLabelledGlyph.prototype.max = function() {\n    if (this.measured)\n        return Math.max(this.glyph.max(), (1.0*this.glyph.min()) + this.textLen + 10);\n    else\n        return this.glyph.max();\n}\n\nLabelledGlyph.prototype.height = function() {\n    var h = this.glyph.height();\n    if (this.measured) {\n        if (this.align == 'above') {\n            h += this.textHeight + 2;\n        } else {\n            h += 20;\n        }\n    }\n    return h;\n}\n\nLabelledGlyph.prototype.draw = function(g, oc) {\n    if (this.align == 'above') {\n        g.save();\n        g.translate(0, this.textHeight + 2);\n    }\n    this.glyph.draw(g);\n    if (this.align == 'above') {\n        g.restore();\n    }\n\n    oc.registerGlyph(this);\n}\n\nLabelledGlyph.prototype.drawOverlay = function(g, minVisible, maxVisible) {\n    g.fillStyle = 'black';\n    if (this.font) {\n        g.save();\n        g.font = this.font;\n    }\n    var p;\n    if ('center' == this.anchor) {\n        p = (this.glyph.min() + this.glyph.max() - this.textLen) / 2;\n    } else {\n        p = this.glyph.min();\n        if (p < minVisible) {\n            p = Math.min(minVisible, this.glyph.max() - this.textLen);\n        }\n    }\n    g.fillText(this.text, p, this.align == 'above' ? this.textHeight : this.glyph.height() + 15);\n    if (this.font) {\n        g.restore();\n    }\n}\n\n\n\nfunction CrossGlyph(x, height, stroke) {\n    this._x = x;\n    this._height = height;\n    this._stroke = stroke;\n}\n\nCrossGlyph.prototype.draw = function(g) {\n    var hh = this._height/2;\n    \n    g.beginPath();\n    g.moveTo(this._x, 0);\n    g.lineTo(this._x, this._height);\n    g.moveTo(this._x - hh, hh);\n    g.lineTo(this._x + hh, hh);\n\n    g.strokeStyle = this._stroke;\n    g.lineWidth = 1;\n\n    g.stroke();\n}\n\nCrossGlyph.prototype.toSVG = function() {\n    var hh = this._height/2;\n\n    var g = new SVGPath();\n    g.moveTo(this._x, 0);\n    g.lineTo(this._x, this._height);\n    g.moveTo(this._x - hh, hh);\n    g.lineTo(this._x + hh, hh);\n    \n    return makeElementNS(\n        NS_SVG, 'path',\n        null,\n        {d: g.toPathData(),\n         fill: 'none',\n         stroke: this._stroke,\n         strokeWidth: '1px'});\n}\n\nCrossGlyph.prototype.min = function() {\n    return this._x - this._height/2;\n}\n\nCrossGlyph.prototype.max = function() {\n    return this._x + this._height/2;\n}\n\nCrossGlyph.prototype.height = function() {\n    return this._height;\n}\n\nfunction ExGlyph(x, height, stroke) {\n    this._x = x;\n    this._height = height;\n    this._stroke = stroke;\n}\n\nExGlyph.prototype.draw = function(g) {\n    var hh = this._height/2;\n    \n    g.beginPath();\n    g.moveTo(this._x - hh, 0);\n    g.lineTo(this._x + hh, this._height);\n    g.moveTo(this._x - hh, this._height);\n    g.lineTo(this._x + hh, 0);\n\n    g.strokeStyle = this._stroke;\n    g.lineWidth = 1;\n\n    g.stroke();\n}\n\nExGlyph.prototype.toSVG = function() {\n    var hh = this._height/2;\n\n    var g = new SVGPath();\n    g.moveTo(this._x - hh, 0);\n    g.lineTo(this._x + hh, this._height);\n    g.moveTo(this._x - hh, this._height);\n    g.lineTo(this._x + hh, 0);\n    \n    return makeElementNS(\n        NS_SVG, 'path',\n        null,\n        {d: g.toPathData(),\n         fill: 'none',\n         stroke: this._stroke,\n         strokeWidth: '1px'});\n}\n\nExGlyph.prototype.min = function() {\n    return this._x - this._height/2;\n}\n\nExGlyph.prototype.max = function() {\n    return this._x + this._height/2;\n}\n\nExGlyph.prototype.height = function() {\n    return this._height;\n}\n\n\n\nfunction TriangleGlyph(x, height, dir, width, fill, stroke) {\n    PathGlyphBase.call(this, stroke, fill);\n\n    this._x = x;\n    this._height = height;\n    this._dir = dir;\n    this._width = width;\n}\n\nTriangleGlyph.prototype = Object.create(PathGlyphBase.prototype);\n\nTriangleGlyph.prototype.drawPath = function(g) {\n    var hh = this._height/2;\n    var hw = this._width/2;\n\n    if (this._dir === 'S') {\n        g.moveTo(this._x, this._height);\n        g.lineTo(this._x - hw, 0);\n        g.lineTo(this._x + hw, 0);\n    } else if (this._dir === 'W') {\n        g.moveTo(this._x + hw, hh);\n        g.lineTo(this._x - hw, 0);\n        g.lineTo(this._x - hw, this._height);\n    } else if (this._dir === 'E') {\n        g.moveTo(this._x - hw, hh);\n        g.lineTo(this._x + hw, 0);\n        g.lineTo(this._x + hw, this._height);\n    } else {\n        g.moveTo(this._x , 0);\n        g.lineTo(this._x + hw, this._height);\n        g.lineTo(this._x - hw, this._height);\n    }\n\n    g.closePath();\n}\n\nTriangleGlyph.prototype.min = function() {\n    return this._x - this._height/2;\n}\n\nTriangleGlyph.prototype.max = function() {\n    return this._x + this._height/2;\n}\n\nTriangleGlyph.prototype.height = function() {\n    return this._height;\n}\n\n\n\n\nfunction DotGlyph(x, height, fill, stroke) {\n    this._x = x;\n    this._height = height;\n    this._fill = fill;\n    this._stroke = stroke;\n}\n\nDotGlyph.prototype.draw = function(g) {\n    var hh = this._height/2;\n    g.fillStyle = this._stroke;\n    g.beginPath();\n    g.arc(this._x, hh, hh, 0, 6.29);\n\n    if (this._fill) {\n        g.fillStyle = this._fill;\n        g.fill();\n    }\n\n    if (this._stroke) {\n        g.strokeStyle = this._stroke;\n        g.stroke();\n    }\n}\n\nDotGlyph.prototype.toSVG = function() {\n    var hh = this._height/2;\n    return makeElementNS(\n        NS_SVG, 'circle',\n        null,\n        {cx: this._x, cy: hh, r: hh,\n         fill: this._fill || 'none',\n         stroke: this._stroke || 'none',\n         strokeWidth: '1px'});\n}\n\nDotGlyph.prototype.min = function() {\n    return this._x - this._height/2;\n}\n\nDotGlyph.prototype.max = function() {\n    return this._x + this._height/2;\n}\n\nDotGlyph.prototype.height = function() {\n    return this._height;\n}\n\n\nfunction PaddedGlyph(glyph, minp, maxp) {\n    this.glyph = glyph;\n    this._min = minp;\n    this._max = maxp;\n    if (glyph) {\n        this.bump = glyph.bump;\n    }\n}\n\nPaddedGlyph.prototype.draw = function(g, oc) {\n    if (this.glyph) \n        this.glyph.draw(g, oc);\n}\n\nPaddedGlyph.prototype.toSVG = function() {\n    if (this.glyph) {\n        return this.glyph.toSVG();\n    } else {\n        return makeElementNS(NS_SVG, 'g');\n    }\n}\n\nPaddedGlyph.prototype.min = function() {\n    return this._min;\n}\n\nPaddedGlyph.prototype.max = function() {\n    return this._max;\n}\n\nPaddedGlyph.prototype.height = function() {\n    if (this.glyph) {\n        return this.glyph.height();\n    } else {\n        return 1;\n    }\n}\n\n\nfunction AArrowGlyph(min, max, height, fill, stroke, ori) {\n    PathGlyphBase.call(this, stroke, fill);\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._ori = ori;\n}\n\nAArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);\n\nAArrowGlyph.prototype.min = function() {\n    return this._min;\n}\n\nAArrowGlyph.prototype.max = function() {\n    return this._max;\n}\n\nAArrowGlyph.prototype.height = function() {\n    return this._height;\n}\n\nAArrowGlyph.prototype.drawPath = function(g) {\n    var maxPos = this._max;\n    var minPos = this._min;\n    var height = this._height;\n    var lInset = 0;\n    var rInset = 0;\n    var minLength = this._height + 2;\n    var instep = 0.333333 * this._height;\n    var y = 0;\n\n    if (this._ori) {\n        if (this._ori === '+') {\n            rInset = 0.5 * this._height;\n        } else if (this._ori === '-') {\n            lInset = 0.5 * this._height;\n        }\n    }\n\n    if (maxPos - minPos < minLength) {\n        minPos = (maxPos + minPos - minLength) / 2;\n        maxPos = minPos + minLength;\n    }\n\n    g.moveTo(minPos + lInset, y+instep);\n    g.lineTo(maxPos - rInset, y+instep);\n    g.lineTo(maxPos - rInset, y);\n    g.lineTo(maxPos, y + this._height/2);\n    g.lineTo(maxPos - rInset, y+height);\n    g.lineTo(maxPos - rInset, y+instep+instep);\n    g.lineTo(minPos + lInset, y+instep+instep);\n    g.lineTo(minPos + lInset, y+height);\n    g.lineTo(minPos, y+height/2);\n    g.lineTo(minPos + lInset, y);\n    g.lineTo(minPos + lInset, y+instep);\n}\n\nfunction SpanGlyph(min, max, height, stroke) {\n    PathGlyphBase.call(this, stroke, null);\n    this._min = min;\n    this._max = max;\n    this._height = height;\n}\n\nSpanGlyph.prototype = Object.create(PathGlyphBase.prototype);\n\nSpanGlyph.prototype.min = function() {return this._min};\nSpanGlyph.prototype.max = function() {return this._max};\nSpanGlyph.prototype.height = function() {return this._height};\n\nSpanGlyph.prototype.drawPath = function(g) {\n    var minPos = this._min, maxPos = this._max;\n    var height = this._height, hh = height/2;\n    g.moveTo(minPos, hh);\n    g.lineTo(maxPos, hh);\n    g.moveTo(minPos, 0);\n    g.lineTo(minPos, height);\n    g.moveTo(maxPos, 0);\n    g.lineTo(maxPos, height);\n}\n\nfunction LineGlyph(min, max, height, style, strand, stroke) {\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._style = style;\n    this._strand = strand;\n    this._stroke = stroke;\n}\n\nLineGlyph.prototype.min = function() {return this._min};\nLineGlyph.prototype.max = function() {return this._max};\nLineGlyph.prototype.height = function() {return this._height};\n\nLineGlyph.prototype.drawPath = function(g) {\n    var minPos = this._min, maxPos = this._max;\n    var height = this._height, hh = height/2;\n\n    if (this._style === 'hat') {\n        g.moveTo(minPos, hh);\n        g.lineTo((minPos + maxPos)/2, this._strand === '-' ? height : 0);\n        g.lineTo(maxPos, hh);\n    } else {\n        g.moveTo(minPos, hh);\n        g.lineTo(maxPos, hh);\n    }\n}\n\n\nLineGlyph.prototype.draw = function(g) {\n    g.beginPath();\n    this.drawPath(g);\n    g.strokeStyle = this._stroke;\n    if (this._style === 'dashed' && g.setLineDash) {\n        g.save();\n        g.setLineDash([3]);\n        g.stroke();\n        g.restore();\n    } else {\n        g.stroke();\n    }\n}\n\nLineGlyph.prototype.toSVG = function() {\n    var g = new SVGPath();\n    this.drawPath(g);\n    \n    var opts = {d: g.toPathData(),\n            stroke: this._stroke || 'none'};\n    if (this._style === 'dashed') {\n        opts['strokeDasharray'] = '3';\n    }\n\n    return makeElementNS(\n        NS_SVG, 'path',\n        null, opts\n    );\n}\n\n\n\n\n\nfunction PrimersGlyph(min, max, height, fill, stroke) {\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._fill = fill;\n    this._stroke = stroke;\n}\n\nPrimersGlyph.prototype.min = function() {return this._min};\nPrimersGlyph.prototype.max = function() {return this._max};\nPrimersGlyph.prototype.height = function() {return this._height};\n\n\nPrimersGlyph.prototype.drawStemPath = function(g) {\n    var minPos = this._min, maxPos = this._max;\n    var height = this._height, hh = height/2;\n    g.moveTo(minPos, hh);\n    g.lineTo(maxPos, hh);\n}\n\nPrimersGlyph.prototype.drawTrigsPath = function(g) {\n    var minPos = this._min, maxPos = this._max;\n    var height = this._height, hh = height/2;\n    g.moveTo(minPos, 0);\n    g.lineTo(minPos + height, hh);\n    g.lineTo(minPos, height);\n    g.lineTo(minPos, 0);\n    g.moveTo(maxPos, 0);\n    g.lineTo(maxPos - height, hh);\n    g.lineTo(maxPos, height);\n    g.lineTo(maxPos, 0);\n}\n\n\nPrimersGlyph.prototype.draw = function(g) {\n    g.beginPath();\n    this.drawStemPath(g);\n    g.strokeStyle = this._stroke;\n    g.stroke();\n    g.beginPath();\n    this.drawTrigsPath(g);\n    g.fillStyle = this._fill;\n    g.fill();\n}\n\nPrimersGlyph.prototype.toSVG = function() {\n    var s = new SVGPath();\n    this.drawStemPath(s);\n    var t = new SVGPath();\n    this.drawTrigsPath(t);\n    \n    return makeElementNS(\n        NS_SVG, 'g',\n        [makeElementNS(\n            NS_SVG, 'path',\n            null,\n            {d: s.toPathData(),\n             stroke: this._stroke || 'none'}),\n         makeElementNS(\n             NS_SVG, 'path',\n             null,\n             {d: t.toPathData(),\n              fill: this._fill || 'none'})]);\n}\n\nfunction ArrowGlyph(min, max, height, color, parallel, sw, ne) {\n    PathGlyphBase.call(this, null, color);\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._color = color;\n    this._parallel = parallel;\n    this._sw = sw;\n    this._ne = ne;\n}\n\nArrowGlyph.prototype = Object.create(PathGlyphBase.prototype);\n\nArrowGlyph.prototype.min = function() {return this._min};\nArrowGlyph.prototype.max = function() {return this._max};\nArrowGlyph.prototype.height = function() {return this._height};\n\nArrowGlyph.prototype.drawPath = function(g) {\n    var min = this._min, max = this._max, height = this._height;\n    \n    if (this._parallel) {\n        var hh = height/2;\n        var instep = 0.4 * height;\n        if (this._sw) {\n            g.moveTo(min + hh, height-instep);\n            g.lineTo(min + hh, height);\n            g.lineTo(min, hh);\n            g.lineTo(min + hh, 0);\n            g.lineTo(min + hh, instep);\n        } else {\n            g.moveTo(min, height-instep);\n            g.lineTo(min, instep);\n        }\n        if (this._ne) {\n            g.lineTo(max - hh, instep);\n            g.lineTo(max - hh, 0);\n            g.lineTo(max, hh);\n            g.lineTo(max - hh, height);\n            g.lineTo(max - hh, height - instep);\n        } else {\n            g.lineTo(max, instep);\n            g.lineTo(max, height-instep);\n        }\n        g.closePath();\n    } else {\n        var mid = (min+max)/2;\n        var instep = 0.4*(max-min);\n        var th = height/3;\n\n        if (this._ne) {\n            g.moveTo(min + instep, th);\n            g.lineTo(min, th);\n            g.lineTo(mid, 0);\n            g.lineTo(max, th);\n            g.lineTo(max - instep, th);\n        } else {\n            g.moveTo(min+instep, 0);\n            g.lineTo(max-instep, 0);\n        }\n        if (this._sw) {\n            g.lineTo(max - instep, height-th);\n            g.lineTo(max, height-th);\n            g.lineTo(mid, height);\n            g.lineTo(min, height-th)\n            g.lineTo(min + instep, height-th);\n        } else {\n            g.lineTo(max - instep, height);\n            g.lineTo(min + instep, height);\n        }\n        g.closePath();\n    }\n}\n\n\nfunction TooManyGlyph(min, max, height, fill, stroke) {\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._fill = fill;\n    this._stroke = stroke;\n}\n\nTooManyGlyph.prototype.min = function() {return this._min};\nTooManyGlyph.prototype.max = function() {return this._max};\nTooManyGlyph.prototype.height = function() {return this._height};\n\nTooManyGlyph.prototype.toSVG = function() {\n    return makeElementNS(NS_SVG, 'rect', null,\n                         {x: this._min, \n                          y: 0, \n                          width: this._max - this._min, \n                          height: this._height,\n                          stroke: this._stroke || 'none',\n                          fill: this._fill || 'none'});\n}\n\nTooManyGlyph.prototype.draw = function(g) {\n    if (this._fill) {\n        g.fillStyle = this._fill;\n        g.fillRect(this._min, 0, this._max - this._min, this._height);\n    }\n    if (this._stroke) {\n        g.strokeStyle = this._stroke;\n        g.strokeRect(this._min, 0, this._max - this._min, this._height);\n        g.beginPath();\n        for (var n = 2; n < this._height; n += 3) {\n            g.moveTo(this._min, n);\n            g.lineTo(this._max, n);\n        }\n        g.stroke();\n    }\n}\n\nfunction TextGlyph(GLOBAL_GC, min, max, height, fill, string) {\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._fill = fill;\n    this._string = string;\n    this._textLen = GLOBAL_GC.measureText(string).width;\n}\n\nTextGlyph.prototype.min = function() {return this._min};\nTextGlyph.prototype.max = function() {return Math.max(this._max, this._min + this._textLen)};\nTextGlyph.prototype.height = function() {return this._height};\n\nTextGlyph.prototype.draw = function(g) {\n    g.fillStyle = this._fill;\n    g.fillText(this._string, this._min, this._height - 4);\n}\n\nTextGlyph.prototype.toSVG = function() {\n    return makeElementNS(NS_SVG, 'text', this._string, {x: this._min, y: this._height - 4});\n};\n\nfunction aminoTileColor(aa, start, color) {\n    var ALTERNATE_COLOR = {\n        'red': 'darkred',\n        'purple': 'mediumpurple',\n        'blue': 'darkblue',\n        'green': 'darkgreen'\n    };\n    var color2 = ALTERNATE_COLOR[color.toLowerCase()];\n    var tileColors;\n    if (!color2)\n        tileColors = ['rgb(73, 68, 149)', 'rgb(9, 0, 103)'];\n        // default to UCSC colors\n    else\n        tileColors = [color, color2];\n\n    if (aa == '?')\n        return 'black';\n    else if (aa == 'M')\n        return 'greenyellow';\n    else if (aa == '*')\n        return 'crimson';\n    else\n        return tileColors[start % 2];\n}\n\nfunction reverseComplement(sequence) {\n    var seq_dict = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'};\n    var rev_seq = sequence.split('').reverse().join('');\n    var rev_compl_seq = [];\n    for (var b = 0; b < rev_seq.length; ++b) {\n        var base = rev_seq.substr(b, 1).toUpperCase();\n        rev_compl_seq.push(base in seq_dict ? seq_dict[base] : 'N');\n    }\n    return rev_compl_seq.join('');\n}\n\nfunction AminoAcidGlyph(min, max, height, fill, seq, orientation, readframe) {\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._fill = fill;\n    this._seq = seq;\n    this._orientation = orientation;\n    this._readframe = readframe;\n}\n\nAminoAcidGlyph.prototype.min = function() {return this._min};\nAminoAcidGlyph.prototype.max = function() {return this._max};\nAminoAcidGlyph.prototype.height = function() {return this._height};\n\nAminoAcidGlyph.prototype.draw = function(gc) {\n    var seq = this._seq;\n    var color = this._fill;\n\n    if (!seq) return;\n\n    var scale = (this._max - this._min + 1) / seq.length;\n\n    var prevOverhang = (3 - this._readframe) % 3;\n    var nextOverhang = (seq.length - prevOverhang) % 3;\n    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;\n    \n    if (leftOverhang > 0) {\n        gc.fillStyle = color;\n        gc.fillRect(this._min, 0, scale * leftOverhang, this._height);\n    }\n\n    for (var p = leftOverhang; p < seq.length; p += 3) {\n        var codon = seq.substr(p, 3).toUpperCase();\n        if (this._orientation == '-')\n            codon = reverseComplement(codon);\n        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';\n        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;\n        gc.fillStyle = color;\n        gc.fillRect(this._min + p * scale, 0, scale * codon.length, this._height);\n\n        if (scale >= 8 && codon.length == 3) {\n            gc.fillStyle = 'white';\n            gc.fillText(aa, this._min + (p+1) * scale, this._height);\n        } \n    }\n}\n\nAminoAcidGlyph.prototype.toSVG = function() {\n    var g = makeElementNS(NS_SVG, 'g');\n    var seq = this._seq;\n    var color = this._fill;\n\n    if (!seq)\n        return g;\n\n    var scale = (this._max - this._min + 1) / seq.length;\n\n    var prevOverhang = (3 - this._readframe) % 3;\n    var nextOverhang = (seq.length - prevOverhang) % 3;\n    var leftOverhang = this._orientation == '+' ? prevOverhang : nextOverhang;\n\n    if (leftOverhang > 0) {\n        g.appendChild(\n            makeElementNS(NS_SVG, 'rect', null, {\n                x: this._min,\n                y: 0,\n                width: scale * leftOverhang,\n                height: this._height,\n                fill: color}));\n    }\n    for (var p = leftOverhang; p < seq.length; p += 3) {\n        var codon = seq.substr(p, 3).toUpperCase();\n        if (this._orientation == '-')\n            codon = reverseComplement(codon);\n        var aa = codon in AMINO_ACID_TRANSLATION ? AMINO_ACID_TRANSLATION[codon] : '?';\n        color = codon.length == 3 ? aminoTileColor(aa, p, this._fill) : this._fill;\n        g.appendChild(\n            makeElementNS(NS_SVG, 'rect', null, {\n                x: this._min + p * scale,\n                y: 0,\n                width: scale * codon.length,\n                height: this._height,\n                fill: color}));\n\n        if (scale >= 8 && codon.length == 3) {\n            g.appendChild(\n                makeElementNS(NS_SVG, 'text', aa, {\n                    x: this._min + (p+1) * scale,\n                    y: this._height,\n                    fill: 'white'}));\n        }\n    }\n    return g;\n};\n\n(function(scope) {\n\nvar isRetina = window.devicePixelRatio > 1;\nvar __dalliance_SequenceGlyphCache = {};\nvar altPattern = new RegExp('^[ACGT-]$');\nvar isCloseUp = function(scale) {\n    return scale >= 8;\n}\n\nfunction SequenceGlyph(baseColors, strandColor, min, max, height, seq, ref, scheme, quals, fillbg, scaleVertical) {\n    this.baseColors = baseColors;\n    this._strandColor = strandColor;\n    this._min = min;\n    this._max = max;\n    this._height = height;\n    this._seq = seq;\n    this._ref = ref;\n    this._scheme = scheme;\n    this._quals = quals;\n    this._fillbg = fillbg;\n    this._scaleVertical = scaleVertical;\n}\n\nSequenceGlyph.prototype.min = function() {return this._min};\nSequenceGlyph.prototype.max = function() {return this._max};\nSequenceGlyph.prototype.height = function() {return this._height};\n\n\nSequenceGlyph.prototype.alphaForQual = function(qual) {\n    return 0.1 + 0.9*Math.max(0.0, Math.min((1.0 * qual) / 30.0, 1.0));\n}\n\nSequenceGlyph.prototype.draw = function(gc) {\n    var seq = this._seq;\n    var ref = this._ref;\n    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';\n    var all = this._scheme === 'mismatch-all';\n    \n    var seqLength = seq ? seq.length : (this._max - this._min + 1);\n    var scale = (this._max - this._min + 1) / seqLength;\n\n    if (mismatch && !isCloseUp(scale)) {\n        gc.fillStyle = this._strandColor;\n        if (this._scaleVertical)\n            gc.fillRect(this._min, scale, this._max - this._min, scale);\n        else\n            gc.fillRect(this._min, this._height/4, this._max - this._min, this._height/2);\n    }\n\n    \n    for (var p = 0; p < seqLength; ++p) {\n        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';\n        \n        if (!altPattern.test(base) && !isCloseUp(scale))\n            continue;\n\n        var color = this.baseColors[base];\n\n        if (this._quals) {\n            var qc = this._quals.charCodeAt(p) - 33;\n            var oldAlpha = gc.globalAlpha;            // NB hoisted!\n            gc.globalAlpha = this.alphaForQual(qc);\n        }\n\n        if (!color) {\n            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';\n            if (base == 'N' || refBase == 'N')\n                color = 'gray';\n            else\n                color = this._strandColor;\n\n            if (all)\n                base = refBase;\n        }\n\n        gc.fillStyle = color;\n\n        var alt = altPattern.test(base);\n        if (this._fillbg || !isCloseUp(scale) || !alt) {\n            if (this._scaleVertical)\n                gc.fillRect(this._min + p*scale, scale, scale, scale);\n            else\n                gc.fillRect(this._min + p*scale, 0, scale, this._height);\n        }\n        if (isCloseUp(scale) && alt) {\n            var key = color + '_' + base\n            var img = __dalliance_SequenceGlyphCache[key];\n            if (!img) {\n                img = document.createElement('canvas');\n                if (isRetina) {\n                    img.width = 16;\n                    img.height = 20;\n                } else {\n                    img.width = 8;\n                    img.height = 10;\n                }\n                var imgGc = img.getContext('2d');\n                if (isRetina) {\n                    imgGc.scale(2, 2);\n                }\n                imgGc.fillStyle = this._fillbg ? 'black' : color;\n                var w = imgGc.measureText(base).width;\n                imgGc.fillText(base, 0.5 * (8.0 - w), 8);\n                __dalliance_SequenceGlyphCache[key] = img;\n            }\n            var dy = this._scaleVertical ? scale : 0;\n            if (isRetina)\n                gc.drawImage(img, this._min + p*scale + 0.5*(scale-8), dy, 8, 10);\n            else\n                gc.drawImage(img, this._min + p*scale + 0.5*(scale-8), dy);\n        } \n\n        if (this._quals) {\n            gc.globalAlpha = oldAlpha;\n        }\n    }\n}\n\nSequenceGlyph.prototype.toSVG = function() {\n    var seq = this._seq;\n    var ref = this._ref;\n    var mismatch = this._scheme === 'mismatch' || this._scheme === 'mismatch-all';\n    var all = this._scheme === 'mismatch-all';\n    var scale = (this._max - this._min + 1) / this._seq.length;\n    var  g = makeElementNS(NS_SVG, 'g'); \n\n    for (var p = 0; p < seq.length; ++p) {\n        var base = seq ? seq.substr(p, 1).toUpperCase() : 'N';\n        var color = this.baseColors[base];\n\n        if (!color) {\n            var refBase = ref ? ref.substr(p, 1).toUpperCase() : 'N';\n            if (base == 'N' || refBase == 'N')\n                color = 'gray';\n            else\n                color = this._strandColor;\n\n            if (all)\n                base = refBase;\n        }\n\n        var alpha = 1.0;\n        if (this._quals) {\n            var qc = this._quals.charCodeAt(p) - 33;\n            alpha = this.alphaForQual(qc);\n        }\n\n        var alt = altPattern.test(base);\n        if (this._fillbg || !isCloseUp(scale) || !alt) {\n            g.appendChild(\n                makeElementNS(NS_SVG, 'rect', null, {\n                    x:this._min + p*scale,\n                    y: 0,\n                    width: scale,\n                    height: this._height,\n                    fill: color,\n                    fillOpacity: alpha}));\n        }\n\n        if (isCloseUp(scale) && alt) {\n            g.appendChild(\n                makeElementNS(NS_SVG, 'text', base, {\n                    x: this._min + (0.5+p)*scale,\n                    y: 8,\n                    textAnchor: 'middle',\n                    fill: this._fillbg ? 'black' : color,\n                    fillOpacity: alpha}));\n        }\n    }\n\n    return g;\n}\n\nscope.SequenceGlyph = SequenceGlyph;\n\n}(this));\n\nfunction TranslatedGlyph(glyph, x, y, height) {\n    this.glyph = glyph;\n    this._height = height;\n    this._x = x;\n    this._y = y;\n}\n\nTranslatedGlyph.prototype.height = function() {\n    if (this._height) {\n        return this._height;\n    } else {\n        return this.glyph.height() + this._y;\n    }\n}\n\nTranslatedGlyph.prototype.min = function() {\n    return this.glyph.min() + this._x;\n}\n\nTranslatedGlyph.prototype.max = function() {\n    return this.glyph.max() + this._x;\n}\n\nTranslatedGlyph.prototype.minY = function() {\n    return this._y;\n}\n\nTranslatedGlyph.prototype.maxY = function() {\n    return this._y + this.glyph.height();\n}\n\nTranslatedGlyph.prototype.draw = function(g, o) {\n    g.save();\n    g.translate(this._x, this._y);\n    this.glyph.draw(g, o);\n    g.restore();\n}\n\nTranslatedGlyph.prototype.toSVG = function() {\n    var s =  this.glyph.toSVG();\n    s.setAttribute('transform', 'translate(' + this._x + ',' + this._y + ')');\n    return s;\n}\n\nfunction PointGlyph(x, y, height, fill) {\n    this._x = x;\n    this._y = y;\n    this._height = height;\n    this._fill = fill;\n}\n\nPointGlyph.prototype.min = function() {\n    return this._x - 2;\n}\n\nPointGlyph.prototype.max = function() {\n    return this._x + 2;\n}\n\nPointGlyph.prototype.height = function() {\n    return this._height;\n}\n\nPointGlyph.prototype.draw = function(g) {\n    g.save();\n    g.globalAlpha = 0.3;\n    g.fillStyle = this._fill;\n    g.beginPath();\n    g.arc(this._x, this._y, 1.5, 0, 6.29);\n    g.fill();\n    g.restore();\n}\n\nPointGlyph.prototype.toSVG = function() {\n    return makeElementNS(\n        NS_SVG, 'circle',\n        null,\n        {cx: this._x, cy: this._y, r: 2,\n         fill: this._fill,\n         stroke: 'none'});\n}\n\n\nfunction GridGlyph(height) {\n    this._height = height || 50;\n}\n\nGridGlyph.prototype.notSelectable = true;\n\nGridGlyph.prototype.min = function() {\n    return -100000;\n};\n\nGridGlyph.prototype.max = function() {\n    return 100000;\n};\n\nGridGlyph.prototype.height = function() {\n    return this._height;\n}\n\nGridGlyph.prototype.draw = function(g) {\n    g.save();\n    g.strokeStyle = 'black'\n    g.lineWidth = 0.1;\n\n    g.beginPath();\n    for (var y = 0; y <= this._height; y += 10) {\n        g.moveTo(-5000, y);\n        g.lineTo(5000, y);\n    }\n    g.stroke();\n    g.restore();\n}\n\nGridGlyph.prototype.toSVG = function() {\n    var p = new SVGPath();\n    for (var y = 0; y <= this._height; y += 10) {\n        p.moveTo(-5000, y);\n        p.lineTo(5000, y);\n    }\n    \n    return makeElementNS(\n        NS_SVG, 'path',\n        null,\n        {d: p.toPathData(),\n         fill: 'none',\n         stroke: 'black',\n         strokeWidth: '0.1px'});\n}\n\nfunction StarGlyph(x, r, points, fill, stroke) {\n    PathGlyphBase.call(this, stroke, fill);\n    this._x = x;\n    this._r = r;\n    this._points = points;\n}\n\nStarGlyph.prototype = Object.create(PathGlyphBase.prototype);\n\nStarGlyph.prototype.min = function() {\n    return this._x - this._r;\n}\n\nStarGlyph.prototype.max = function() {\n    return this._x + this._r;\n}\n\nStarGlyph.prototype.height = function() {\n    return 2 * this._r;\n}\n\nStarGlyph.prototype.drawPath = function(g) {\n    var midX = this._x, midY = this._r, r = this._r;\n    for (var p = 0; p < this._points; ++p) {\n        var theta = (p * 6.28) / this._points;\n        var px = midX + r*Math.sin(theta);\n        var py = midY - r*Math.cos(theta);\n        if (p == 0) {\n            g.moveTo(px, py);\n        } else {\n            g.lineTo(px, py);\n        }\n        theta = ((p+0.5) * 6.28) / this._points;\n        px = midX + 0.4*r*Math.sin(theta);\n        py = midY - 0.4*r*Math.cos(theta);\n        g.lineTo(px, py);\n    }\n    g.closePath();\n}\n\nfunction PlimsollGlyph(x, height, overhang, fill, stroke) {\n    this._x = x;\n    this._height = height;\n    this._overhang = overhang;\n    this._fill = fill;\n    this._stroke = stroke;\n    this._hh = height / 2;\n}\n\nPlimsollGlyph.prototype.draw = function(g) {\n    var hh = this._height/2;\n    g.fillStyle = this._stroke;\n    g.beginPath();\n    g.arc(this._x, hh, hh - this._overhang, 0, 6.29);\n    g.moveTo(this._x, 0);\n    g.lineTo(this._x, this._height);\n\n    if (this._fill) {\n        g.fillStyle = this._fill;\n        g.fill();\n    }\n\n    if (this._stroke) {\n        g.strokeStyle = this._stroke;\n        g.stroke();\n    }\n}\n\nPlimsollGlyph.prototype.toSVG = function() {\n    var hh = this._hh;\n    return makeElementNS(NS_SVG, 'g', \n        [makeElementNS(NS_SVG, 'circle', null, {cx: this._x, cy: hh, r: hh - this._overhang}),\n         makeElementNS(NS_SVG, 'line', null, {x1: this._x, y1: 0, x2: this._x, y2: this._height})],\n        {fill: this._fill || 'none',\n         stroke: this._stroke || 'none',\n         strokeWidth: '1px'});\n}\n\nPlimsollGlyph.prototype.min = function() {\n    return this._x - this._hh;\n}\n\nPlimsollGlyph.prototype.max = function() {\n    return this._x + this._hh;\n}\n\nPlimsollGlyph.prototype.height = function() {\n    return this._height;\n}\n\n\nfunction OverlayLabelCanvas() {\n    this.ox = 0;\n    this.oy = 0;\n    this.glyphs = [];\n}\n\nOverlayLabelCanvas.prototype.translate = function(x, y) {\n    this.ox += x;\n    this.oy += y;\n}\n\nOverlayLabelCanvas.prototype.registerGlyph = function(g) {\n    this.glyphs.push({\n        x: this.ox,\n        y: this.oy,\n        glyph: g\n    });\n}\n\n\nOverlayLabelCanvas.prototype.draw = function(g, minVisible, maxVisible) {\n    for (var gi = 0; gi < this.glyphs.length; ++gi) {\n        var gg = this.glyphs[gi];\n        g.save();\n        g.translate(gg.x, gg.y);\n        gg.glyph.drawOverlay(g, minVisible, maxVisible);\n        g.restore();\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        BoxGlyph: BoxGlyph,\n        GroupGlyph: GroupGlyph,\n        LineGraphGlyph: LineGraphGlyph,\n        LabelledGlyph: LabelledGlyph,\n        CrossGlyph: CrossGlyph,\n        ExGlyph: ExGlyph,\n        TriangleGlyph: TriangleGlyph,\n        DotGlyph: DotGlyph,\n        PaddedGlyph: PaddedGlyph,\n        AArrowGlyph: AArrowGlyph,\n        SpanGlyph: SpanGlyph,\n        LineGlyph: LineGlyph,\n        PrimersGlyph: PrimersGlyph,\n        ArrowGlyph: ArrowGlyph,\n        TooManyGlyph: TooManyGlyph,\n        TextGlyph: TextGlyph,\n        SequenceGlyph: this.SequenceGlyph,\n        AminoAcidGlyph: AminoAcidGlyph,\n        TranslatedGlyph: TranslatedGlyph,\n        GridGlyph: GridGlyph,\n        StarGlyph: StarGlyph,\n        PointGlyph: PointGlyph,\n        PlimsollGlyph: PlimsollGlyph,\n\n        OverlayLabelCanvas: OverlayLabelCanvas\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// jbjson.js -- query JBrowse-style REST data stores\n//\n\nif (typeof(require) !== 'undefined') {\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n}\n\nfunction JBrowseStore(base, query) {\n    this.base = base;\n    this.query = query;\n}\n\nfunction jbori(strand) {\n    if (strand > 0)\n        return '+';\n    else if (strand < 0)\n        return '-';\n}\n\nJBrowseStore.prototype.features = function(segment, opts, callback) {\n    opts = opts || {};\n\n    url = this.base + '/features/' + segment.name;\n\n    var filters = [];\n    if (this.query) {\n\t   filters.push(this.query);\n    }\n    if (segment.isBounded) {\n    \tfilters.push('start=' + segment.start);\n    \tfilters.push('end=' + segment.end);\n    }\n    if (filters.length > 0) {\n\t    url = url + '?' + filters.join('&');\n    }\n\n    var req = new XMLHttpRequest();\n    req.onreadystatechange = function() {\n\tif (req.readyState == 4) {\n\t    if (req.status >= 300) {\n\t\t    callback(null, 'Error code ' + req.status);\n\t    } else {\n\t\tvar jf = JSON.parse(req.response)['features'];\n\t\tvar features = [];\n\t\tfor (fi = 0; fi < jf.length; ++fi) {\n\t\t    var j = jf[fi];\n\t\t    \n\t\t    var f = new DASFeature();\n\t\t    f.segment = segment.name;\n\t\t    f.min = (j['start'] | 0) + 1;\n\t\t    f.max = j['end'] | 0;\n\t\t    if (j.name) {\n\t\t\tf.label = j.name;\n\t\t    }\n                    if (j.strand)\n                        f.orientation = jbori(j.strand);\n\t\t    f.type = j.type || 'unknown';\n\n                    if (j.subfeatures && j.subfeatures.length > 0) {\n                        f.id = j.uniqueID;\n\n                        var blocks = [];\n                        var cds = [];\n                        var all = [];\n\n                        for (var si = 0; si < j.subfeatures.length; ++si) {\n                            var sj = j.subfeatures[si];\n                            var sf = shallowCopy(f);\n                            sf.min = sj.start + 1;\n                            sf.max = sj.end;\n                            sf.groups = [f];\n\n                            all.push(sf);\n                            blocks.push(new Range(sf.min, sf.max));\n                            if (sj.type === 'CDS')\n                                cds.push(sf);\n                        }\n                        \n                        if (cds.length > 0) {\n                            spans = union(blocks);\n                            var txGroup = shallowCopy(f);\n                            txGroup.type = 'transcript';\n                            spans.ranges().forEach(function(exon) {\n                                features.push({\n                                    segment:     segment.name,\n                                    min:         exon.min(),\n                                    max:         exon.max(),\n                                    orientation: f.orientation,\n                                    groups:      [txGroup],\n                                    type:        'transcript'\n                                });\n                            });\n\n                            var tlGroup = shallowCopy(f);\n                            cds.forEach(function(cdsExon) {\n                                cdsExon.type = 'translation'\n                                cdsExon.groups = [tlGroup];\n                                features.push(cdsExon);\n                            });\n                        } else {\n                            all.forEach(function(f) {\n                                features.push(f);\n                            });\n                        }\n                    } else {\n\t\t        features.push(f);\n                    }\n\t\t}\n\t\tcallback(features);\n\t    }\n\t}\n\t\n    };\n    \n    req.open('GET', url, true);\n    req.responseType = 'text';\n    req.send('');\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        JBrowseStore: JBrowseStore\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// kspace.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var Awaited = utils.Awaited;\n    var pusho = utils.pusho;\n\n    var sa = require('./sourceadapters');\n    var MappedFeatureSource = sa.MappedFeatureSource;\n    var CachingFeatureSource = sa.CachingFeatureSource;\n    var BWGFeatureSource = sa.BWGFeatureSource;\n    var RemoteBWGFeatureSource = sa.RemoteBWGFeatureSource;\n    var BAMFeatureSource = sa.BAMFeatureSource;\n    var RemoteBAMFeatureSource = sa.RemoteBAMFeatureSource;\n    var DummySequenceSource = sa.DummySequenceSource;\n    var DummyFeatureSource = sa.DummyFeatureSource;\n\n    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;\n\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var sample = require('./sample');\n    var downsample = sample.downsample;\n    var getBaseCoverage = sample.getBaseCoverage;\n\n    var das = require('./das');\n    var DASSequence = das.DASSequence;\n    \n    var Promise = require('es6-promise').Promise;\n}\n\nfunction FetchPool() {\n    var self = this;\n    this.reqs = [];\n    this.awaitedFeatures = {};\n    this.requestsIssued = new Promise(function(resolve, reject) {\n        self.notifyRequestsIssued = resolve;\n    });\n}\n\nFetchPool.prototype.addRequest = function(xhr) {\n    this.reqs.push(xhr);\n}\n\nFetchPool.prototype.abortAll = function() {\n    for (var i = 0; i < this.reqs.length; ++i) {\n        this.reqs[i].abort();\n    }\n}\n\nfunction KSCacheBaton(chr, min, max, scale, features, status, coverage) {\n    this.chr = chr;\n    this.min = min;\n    this.max = max;\n    this.coverage = coverage;\n    this.scale = scale;\n    this.features = features || [];\n    this.status = status;\n}\n\nKSCacheBaton.prototype.toString = function() {\n    return this.chr + \":\" + this.min + \"..\" + this.max + \";scale=\" + this.scale;\n}\n\nfunction KnownSpace(tierMap, chr, min, max, scale, seqSource) {\n    this.tierMap = tierMap;\n    this.chr = chr;\n    this.min = min;\n    this.max = max;\n    this.scale = scale;\n    this.seqSource = seqSource || new DummySequenceSource();\n    this.viewCount = 0;\n\n    this.featureCache = {};\n    this.latestViews = {};\n}\n\nKnownSpace.prototype.cancel = function() {\n    this.cancelled = true;\n}\n\nKnownSpace.prototype.bestCacheOverlapping = function(chr, min, max) {\n    var baton = this.featureCache[this.tierMap[0]];\n    if (baton) {\n        return baton;\n    } else {\n        return null;\n    }\n}\n\nKnownSpace.prototype.retrieveFeatures = function(tiers, chr, min, max, scale, tierCallback) {\n    if (scale != scale) {\n        throw \"retrieveFeatures called with silly scale\";\n    }\n\n    if (chr != this.chr) {\n        throw \"Can't extend Known Space to a new chromosome\";\n    }\n    if (min < 1) {\n        min = 1;\n    }\n\n    this.min = min;\n    this.max = max;\n    this.scale = scale;\n\n    if (this.pool) {\n        this.pool.abortAll();\n    }\n    this.pool = new FetchPool();\n    this.awaitedSeq = new Awaited();\n    this.seqWasFetched = false;\n    this.viewCount++;\n    \n    this.startFetchesForTiers(tiers, tierCallback);\n    this.pool.notifyRequestsIssued();\n}\n    \nfunction filterFeatures(features, min, max) {\n    var ff = [];\n    var featuresByGroup = {};\n\n    for (var fi = 0; fi < features.length; ++fi) {\n        var f = features[fi];\n        if (!f.min || !f.max) {\n            ff.push(f);\n        } else if (f.groups && f.groups.length > 0) {\n            pusho(featuresByGroup, f.groups[0].id, f);\n        } else if (f.min <= max && f.max >= min) {\n            ff.push(f);\n        }\n    }\n\n    for (var gid in featuresByGroup) {\n        var gf = featuresByGroup[gid];\n        var gmin = 100000000000, gmax = -100000000000;\n        for (var fi = 0; fi < gf.length; ++fi) {\n            var f = gf[fi];\n            gmin = Math.min(gmin, f.min);\n            gmax = Math.max(gmax, f.max);\n        }\n        if (gmin <= max || gmax >= min) {\n            for (var fi = 0; fi < gf.length; ++fi) {\n                ff.push(gf[fi]);\n            }\n        }\n    }\n\n    return ff;\n}\n\nKnownSpace.prototype.invalidate = function(tier, tierCallback) {\n    if (!this.pool) {\n        return;\n    }\n\n    this.featureCache[tier] = null;\n    this.startFetchesForTiers([tier], tierCallback);\n}\n\nKnownSpace.prototype.startFetchesForTiers = function(tiers, tierCallback) {\n    var thisB = this;\n\n    var awaitedSeq = this.awaitedSeq;\n    var needSeq = false;\n\n    var gex;\n\n    for (var t = 0; t < tiers.length; ++t) {\n        try {\n            if (this.startFetchesFor(tiers[t], awaitedSeq, tierCallback)) {\n                needSeq = true;\n            }\n        } catch (ex) {\n            var tier = tiers[t];\n\n            tier.currentFeatures = [];\n            tier.currentSequence = null;\n            console.log('Error fetching tier source');\n            console.log(ex);\n            gex = ex;\n            tierCallback(ex, tier);\n        }\n    }\n\n    if (needSeq && !this.seqWasFetched) {\n        this.seqWasFetched = true;\n        var smin = this.min, smax = this.max;\n\n        if (this.cs) {\n            if (this.cs.start <= smin && this.cs.end >= smax) {\n                var cachedSeq;\n                if (this.cs.start == smin && this.cs.end == smax) {\n                    cachedSeq = this.cs;\n                } else {\n                    cachedSeq = new DASSequence(this.cs.name, smin, smax, this.cs.alphabet, \n                                                this.cs.seq.substring(smin - this.cs.start, smax + 1 - this.cs.start));\n                }\n                return awaitedSeq.provide(cachedSeq);\n            }\n        }\n        \n        this.seqSource.fetch(this.chr, smin, smax, this.pool, function(err, seq) {\n            if (seq) {\n                if (!thisB.cs || (smin <= thisB.cs.start && smax >= thisB.cs.end) || \n                    (smin >= thisB.cs.end) || (smax <= thisB.cs.start) || \n                    ((smax - smin) > (thisB.cs.end - thisB.cs.start))) \n                {\n                    thisB.cs = seq;\n                }\n                awaitedSeq.provide(seq);\n            } else {\n                console.log('Sequence loading failed', err);\n                awaitedSeq.provide(null);\n            }\n        });\n    } \n\n    if (gex)\n        throw gex;\n}\n\nKnownSpace.prototype.startFetchesFor = function(tier, awaitedSeq, tierCallback) {\n    var thisB = this;\n\n    var viewID = this.viewCount;\n    var source = tier.getSource() || new DummyFeatureSource();\n    var needsSeq = tier.needsSequence(this.scale);\n    var baton = thisB.featureCache[tier];\n    var styleFilters = tier.getActiveStyleFilters(this.scale);\n    var wantedTypes;\n    if (styleFilters)\n        wantedTypes = styleFilters.typeList();\n    var chr = this.chr, min = this.min, max = this.max;\n\n\n    if (wantedTypes === undefined) {\n        return false;\n    }\n    if (baton && baton.chr === this.chr && baton.min <= min && baton.max >= max) {\n        var cachedFeatures = baton.features;\n        if (baton.min < min || baton.max > max) {\n            cachedFeatures = filterFeatures(cachedFeatures, min, max);\n        }\n        \n        thisB.provision(tier, baton.chr, intersection(baton.coverage, new Range(min, max)), baton.scale, wantedTypes, cachedFeatures, baton.status, needsSeq ? awaitedSeq : null, tierCallback);\n\n        var availableScales = source.getScales();\n        if (baton.scale <= this.scale || !availableScales) {\n            return needsSeq;\n        } else {\n        }\n    }\n\n    if (source.instrument)\n        console.log('Starting  fetch ' + viewID + ' (' + min + ', ' + max + ')');\n    source.fetch(chr, min, max, this.scale, wantedTypes, this.pool, function(status, features, scale, coverage) {\n    \tif (source.instrument)\n    \t    console.log('Finishing fetch ' + viewID);\n\n    \tvar latestViewID = thisB.latestViews[tier] || -1;\n    \tif (thisB.cancelled || latestViewID > viewID) {\n    \t    return;\n    \t}\n\n        if (!coverage) {\n            coverage = new Range(min, max);\n        }\n\n        if (!baton || (min < baton.min) || (max > baton.max)) {         // FIXME should be merging in some cases?\n            thisB.featureCache[tier] = new KSCacheBaton(chr, min, max, scale, features, status, coverage);\n        }\n\n\t    thisB.latestViews[tier] = viewID;\n        thisB.provision(tier, chr, coverage, scale, wantedTypes, features, status, needsSeq ? awaitedSeq : null, tierCallback);\n    }, styleFilters);\n    return needsSeq;\n}\n\nKnownSpace.prototype.provision = function(tier, chr, coverage, actualScale, wantedTypes, features, status, awaitedSeq, tierCallback) {\n    if (status) {\n        tier.setFeatures(chr, coverage, actualScale, [], null);\n        tierCallback(status, tier);\n    } else {\n        var mayDownsample = false;\n        var needBaseComposition = false;\n        var src = tier.getSource();\n        while (MappedFeatureSource.prototype.isPrototypeOf(src) || CachingFeatureSource.prototype.isPrototypeOf(src) || OverlayFeatureSource.prototype.isPrototypeOf(src)) {\n\t        if (OverlayFeatureSource.prototype.isPrototypeOf(src)) {\n\t\t        src = src.sources[0];\n\t        } else {\n\t\t        src = src.source;\n\t        }\n        }\n        if (BWGFeatureSource.prototype.isPrototypeOf(src) || RemoteBWGFeatureSource.prototype.isPrototypeOf(src) || BAMFeatureSource.prototype.isPrototypeOf(src) || RemoteBAMFeatureSource.prototype.isPrototypeOf(src)) {\n            mayDownsample = true;\n        }\n\n    \tif (!src.opts || (!src.opts.forceReduction && !src.opts.noDownsample)) {\n            if (/* (actualScale < (this.scale/2) && features.length > 200)  || */\n\t\t        (mayDownsample && wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('density') >= 0))\n            {\n\t\t        features = downsample(features, this.scale);\n            }\n    \t}\n\n        if (wantedTypes && wantedTypes.length == 1 && wantedTypes.indexOf('base-coverage') >= 0)\n        {\n            // Base-composition coverage track\n            needBaseComposition = true;\n        }\n        if (awaitedSeq) {\n            awaitedSeq.await(function(seq) {\n                if (needBaseComposition) {\n                    features = getBaseCoverage(features, seq, tier.browser.baseColors);\n                }\n                tier.setFeatures(chr, coverage, actualScale, features, seq);\n                tierCallback(status, tier);\n            });\n        } else {\n            tier.setFeatures(chr, coverage, actualScale, features);\n            tierCallback(status, tier);\n        }\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        KnownSpace: KnownSpace\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// lh3utils.js: common support for lh3's file formats\n//\n\nif (typeof(require) !== 'undefined') {\n    var jszlib = require('jszlib');\n    var jszlib_inflate_buffer = jszlib.inflateBuffer;\n    var arrayCopy = jszlib.arrayCopy;\n}\n\nfunction Vob(b, o) {\n    this.block = b;\n    this.offset = o;\n}\n\nVob.prototype.toString = function() {\n    return '' + this.block + ':' + this.offset;\n}\n\nfunction readVob(ba, offset, allowZero) {\n    var block = ((ba[offset+6] & 0xff) * 0x100000000) + ((ba[offset+5] & 0xff) * 0x1000000) + ((ba[offset+4] & 0xff) * 0x10000) + ((ba[offset+3] & 0xff) * 0x100) + ((ba[offset+2] & 0xff));\n    var bint = (ba[offset+1] << 8) | (ba[offset]);\n    if (block == 0 && bint == 0 && !allowZero) {\n        return null;  // Should only happen in the linear index?\n    } else {\n        return new Vob(block, bint);\n    }\n}\n\nfunction unbgzf(data, lim) {\n    lim = Math.min(lim || 1, data.byteLength - 50);\n    var oBlockList = [];\n    var ptr = [0];\n    var totalSize = 0;\n\n    while (ptr[0] < lim) {\n        var ba = new Uint8Array(data, ptr[0], 12); // FIXME is this enough for all credible BGZF block headers?\n        var xlen = (ba[11] << 8) | (ba[10]);\n        // dlog('xlen[' + (ptr[0]) +']=' + xlen);\n        var unc = jszlib_inflate_buffer(data, 12 + xlen + ptr[0], Math.min(65536, data.byteLength - 12 - xlen - ptr[0]), ptr);\n        ptr[0] += 8;\n        totalSize += unc.byteLength;\n        oBlockList.push(unc);\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0];\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = new Uint8Array(oBlockList[i]);\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nfunction Chunk(minv, maxv) {\n    this.minv = minv; this.maxv = maxv;\n}\n\n\n//\n// Binning (transliterated from SAM1.3 spec)\n//\n\n/* calculate bin given an alignment covering [beg,end) (zero-based, half-close-half-open) */\nfunction reg2bin(beg, end)\n{\n    --end;\n    if (beg>>14 == end>>14) return ((1<<15)-1)/7 + (beg>>14);\n    if (beg>>17 == end>>17) return ((1<<12)-1)/7 + (beg>>17);\n    if (beg>>20 == end>>20) return ((1<<9)-1)/7 + (beg>>20);\n    if (beg>>23 == end>>23) return ((1<<6)-1)/7 + (beg>>23);\n    if (beg>>26 == end>>26) return ((1<<3)-1)/7 + (beg>>26);\n    return 0;\n}\n\n/* calculate the list of bins that may overlap with region [beg,end) (zero-based) */\nvar MAX_BIN = (((1<<18)-1)/7);\nfunction reg2bins(beg, end) \n{\n    var i = 0, k, list = [];\n    --end;\n    list.push(0);\n    for (k = 1 + (beg>>26); k <= 1 + (end>>26); ++k) list.push(k);\n    for (k = 9 + (beg>>23); k <= 9 + (end>>23); ++k) list.push(k);\n    for (k = 73 + (beg>>20); k <= 73 + (end>>20); ++k) list.push(k);\n    for (k = 585 + (beg>>17); k <= 585 + (end>>17); ++k) list.push(k);\n    for (k = 4681 + (beg>>14); k <= 4681 + (end>>14); ++k) list.push(k);\n    return list;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        unbgzf: unbgzf,\n        readVob: readVob,\n        reg2bin: reg2bin,\n        reg2bins: reg2bins,\n        Chunk: Chunk\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// memstore.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sa = require('./sourceadapters');\n    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;\n    var dalliance_makeParser = sa.makeParser;\n    var FeatureSourceBase = sa.FeatureSourceBase;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n\n    var utils = require('./utils');\n    var Awaited = utils.Awaited;\n    var textXHR = utils.textXHR;\n}\n\nfunction MemStore() {\n    this.featuresByChr = {};\n    this.maxLength = 1;\n    this.chrRing = null;\n}\n\nMemStore.prototype.addFeatures = function(features) {\n    var dirty = {};\n    for (var fi = 0; fi < features.length; ++fi) {\n        var f = features[fi];\n        var chr = f.segment || f.chr;\n        var fa = this.featuresByChr[chr];\n        if (!fa) {\n            fa = [];\n            this.featuresByChr[chr] = fa;\n        }\n        fa.push(f);\n        dirty[chr] = true;\n\n        var len = f.max - f.min + 1;\n        if (len > this.maxLength)\n            this.maxLength = len;\n    }\n\n    for (chr in dirty) {\n        var fa = this.featuresByChr[chr];\n        fa.sort(function(f1, f2) {\n            var d = f1.min - f2.min;\n            if (d != 0)\n                return d;\n            return f1.max - f2.max;\n        });\n    }\n    this.chrRing = null;\n}\n\nMemStore.prototype._indexFor = function(fa, p) {\n    var lb = 0, ub = fa.length;\n    while (ub > lb) {\n        var mid = ((lb + ub)/2)|0;\n        if (mid >= fa.length)\n            return fa.length;\n        var mg = fa[mid];\n        if (p < mg.min) {\n            ub = mid;\n        } else {\n            lb = mid + 1;\n        }\n    }\n    return ub;\n}\n\nMemStore.prototype.fetch = function(chr, min, max) {\n    var fa = this.featuresByChr[chr];\n    if (!fa) {\n        if (chr.indexOf('chr') == 0)\n            fa = this.featuresByChr[chr.substring(3)];\n        else\n            fa = this.featuresByChr['chr' + chr];\n    }\n    if (!fa)\n        return [];\n\n    var mini = Math.max(0, this._indexFor(fa, min - this.maxLength - 1));\n    var maxi = Math.min(fa.length - 1, this._indexFor(fa, max));\n\n    var res = [];\n    for (var fi = mini; fi <= maxi; ++fi) {\n        var f = fa[fi];\n        if (f.min <= max && f.max >= min)\n            res.push(f);\n    }\n    return res;\n}\n\nMemStore.prototype.findNextFeature = function(chr, pos, dir) {\n    if (this.chrRing == null) {\n        this.chrRing = [];\n        for (var chr in this.featuresByChr) {\n            this.chrRing.push(chr);\n        }\n        this.chrRing.sort();\n    }\n\n    var fa = this.featuresByChr[chr];\n    if (!fa) {\n        if (chr.indexOf('chr') == 0) {\n            chr = chr.substring(3);\n            fa = this.featuresByChr[chr];\n        } else {\n            chr = 'chr' + chr;\n            fa = this.featuresByChr[chr];\n        }\n    }\n    if (!fa)\n        return null;\n\n    var i = Math.max(0, Math.min(this._indexFor(fa, pos), fa.length - 1));\n    if (dir > 0) {\n        while (i < fa.length) {\n            var f = fa[i++];\n            if (f.min > pos)\n                return f;\n        }\n        var chrInd = this.chrRing.indexOf(chr) + 1;\n        if (chrInd >= this.chrRing.length)\n            chrInd = 0;\n        return this.findNextFeature(this.chrRing[chrInd], 0, dir);\n    } else {\n        while (i >= 0) {\n            var f = fa[i--];\n            if (f.max < pos)\n                return f;\n        }\n        var chrInd = this.chrRing.indexOf(chr) - 1;\n        if (chrInd < 0)\n            chrInd = this.chrRing.length - 1;\n        return this.findNextFeature(this.chrRing[chrInd], 10000000000, dir);\n    }\n}\n\nfunction MemStoreFeatureSource(source) {\n    this.source = source;\n    FeatureSourceBase.call(this);\n    this.storeHolder = new Awaited();\n    this.parser = dalliance_makeParser(source.payload);\n    if (!this.parser) {\n        throw \"Unsupported memstore payload: \" + source.payload;\n    }\n\n    var thisB = this;\n    this._load(function(resp, err) {\n        if (!resp) {\n            thisB.error = err || \"No data\"\n            thisB.storeHolder.provide(null);\n        } else {\n            var store = new MemStore();\n            var features = [];\n            var lines = resp.split('\\n');\n\n            var session = thisB.parser.createSession(function(f) {features.push(f)});\n            for (var li = 0; li < lines.length; ++li) {\n                var line = lines[li];\n                if (line.length > 0) {\n                    session.parse(line);\n                }\n            }\n            session.flush();\n\n            store.addFeatures(features);\n\n            thisB.storeHolder.provide(store);\n        }\n    });\n}\n\nMemStoreFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nMemStoreFeatureSource.prototype._load = function(callback) {\n    if (this.source.blob) {\n        var r = new FileReader();\n        r.onloadend = function() {\n            return callback(r.result, r.error);\n        }\n        r.readAsText(this.source.blob);\n    } else {\n        if (this.source.credentials)\n            var opts = {credentials : this.source.credentials};\n        textXHR(this.source.uri, callback, opts);\n    }\n}\n\nMemStoreFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {\n    var thisB = this;\n    this.storeHolder.await(function(store) {\n        if (store) {\n            var f = store.fetch(chr, min, max);\n            return cnt(null, f, 100000000);\n        } else {\n            return cnt(thisB.error)\n        }\n    });\n}\n\nMemStoreFeatureSource.prototype.getStyleSheet = function(callback) {\n    if (this.parser && this.parser.getStyleSheet)\n        this.parser.getStyleSheet(callback)\n}\n\nMemStoreFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.parser && this.parser.getDefaultFIPs)\n        this.parser.getDefaultFIPs(callback);\n}\n\nMemStoreFeatureSource.prototype.getScales = function() {\n    return 100000000;\n}\n\nMemStoreFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {\n    var thisB = this;\n    this.storeHolder.await(function(store) {\n        if (store) {\n            return callback(store.findNextFeature(chr, pos, dir));\n        } else {\n            return callback(null, thisB.error);\n        }\n    });\n}\n\n\nMemStoreFeatureSource.prototype.capabilities = function() {\n    var caps = {leap: true};\n    return caps;\n}\n\ndalliance_registerSourceAdapterFactory('memstore', function(source) {\n    return {features: new MemStoreFeatureSource(source)};\n});\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// memstore.js\n//\n\nfunction formatLongInt(n) {\n    return (n|0).toString().replace(/\\B(?=(\\d{3})+(?!\\d))/g, ',')\n}\n\nfunction formatQuantLabel(v) {\n    var t = '' + v;\n    var dot = t.indexOf('.');\n    if (dot < 0) {\n        return t;\n    } else {\n        var dotThreshold = 2;\n        if (t.substring(0, 1) == '-') {\n            ++dotThreshold;\n        }\n\n        if (dot >= dotThreshold) {\n            return t.substring(0, dot);\n        } else {\n            return t.substring(0, dot + 2);\n        }\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        formatLongInt: formatLongInt,\n        formatQuantLabel: formatQuantLabel\n    };\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// overlay.js: featuresources composed from multiple underlying sources\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n    var arrayIndexOf = utils.arrayIndexOf;\n}\n\nfunction OverlayFeatureSource(sources, opts) {\n    this.sources = sources;\n    this.opts = opts || {};\n    this.activityListeners = [];\n    this.readinessListeners = [];\n    this.changeListeners = [];\n    this.business = [];\n    this.readiness = [];\n\n    for (var i = 0; i < this.sources.length; ++i) {\n        this.initN(i);\n    }\n\n    if (typeof(opts.merge) === 'function') {\n        this.merge = opts.merge;\n    } else if (opts.merge == 'concat') {\n        this.merge = OverlayFeatureSource_merge_concat;\n    } else if (opts.merge == 'alternates') {\n        this.merge = OverlayFeatureSource_merge_concat;\n        this.filterDispatchOnMethod = true;\n    } else {\n        this.merge = OverlayFeatureSource_merge_byKey;\n    }\n}\n\nOverlayFeatureSource.prototype.initN = function(n) {\n    var s = this.sources[n];\n    var thisB = this;\n    this.business[n] = 0;\n\n    if (s.addActivityListener) {\n        s.addActivityListener(function(b) {\n            thisB.business[n] = b;\n            thisB.notifyActivity();\n        });\n    }\n    if (s.addChangeListener) {\n        s.addChangeListener(function() {\n            thisB.notifyChange();\n        });\n    }\n    if (s.addReadinessListener) {\n        s.addReadinessListener(function(r) {\n            thisB.readiness[n] = r;\n            thisB.notifyReadiness();\n        });\n    }\n}\n\nOverlayFeatureSource.prototype.addReadinessListener = function(l) {\n    this.readinessListeners.push(l);\n    this.notifyReadinessListener(l);\n}\n\nOverlayFeatureSource.prototype.removeReadinessListener = function(l) {\n    var idx = arrayIndexOf(this.readinessListeners, l);\n    if (idx >= 0) {\n        this.readinessListeners.splice(idx, 1);\n    }\n}\n\nOverlayFeatureSource.prototype.notifyReadiness = function() {\n    for (var i = 0; i < this.readinessListeners.length; ++i) {\n        this.notifyReadinessListener(this.readinessListeners[i]);\n    }\n}\n\nOverlayFeatureSource.prototype.notifyReadinessListener = function(l) {\n    var r = null;\n    for (var i = 0; i < this.readiness.length; ++i) {\n        if (this.readiness[i] != null) {\n            r = this.readiness[i]; break;\n        }\n    }\n    try {\n        l(r);\n    } catch (e) {\n        console.log(e);\n    }\n}\n\nOverlayFeatureSource.prototype.addActivityListener = function(l) {\n    this.activityListeners.push(l);\n}\n\nOverlayFeatureSource.prototype.removeActivityListener = function(l) {\n    var idx = arrayIndexOf(this.activityListeners, l);\n    if (idx >= 0) {\n        this.activityListeners.splice(idx, 1);\n    }\n}\n\nOverlayFeatureSource.prototype.notifyActivity = function() {\n    var busy = 0;\n    for (var i = 0; i < this.business.length; ++i) {\n        busy += this.business[i];\n    }\n\n    for (var li = 0; li < this.activityListeners.length; ++li) {\n        try {\n            this.activityListeners[li](busy);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nOverlayFeatureSource.prototype.addChangeListener = function(listener) {\n    this.changeListeners.push(listener);\n}\n\nOverlayFeatureSource.prototype.removeChangeListener = function(l) {\n    var idx = arrayIndexOf(this.changeListeners, l);\n    if (idx >= 0) {\n        this.changeListeners.splice(idx, 1);\n    }\n}\n\nOverlayFeatureSource.prototype.notifyChange = function() {\n    for (var li = 0; li < this.changeListeners.length; ++li) {\n        try {\n            this.changeListeners[li](this.busy);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nOverlayFeatureSource.prototype.getScales = function() {\n    return this.sources[0].getScales();\n}\n\nOverlayFeatureSource.prototype.getStyleSheet = function(callback) {\n    return this.sources[0].getStyleSheet(callback);\n}\n\nOverlayFeatureSource.prototype.capabilities = function() {\n    var caps = {};\n    var s0 = this.sources[0];\n    if (s0.capabilities) \n        caps = shallowCopy(s0.capabilities());\n\n    for (var i = 1; i < this.sources.length; ++i) {\n        var si = this.sources[i];\n        if (si.capabilities) {\n            var co = si.capabilities();\n            if (co.search) {\n                caps.search = co.search;\n            }\n        }\n    }\n\n    return caps;\n}\n\nOverlayFeatureSource.prototype.search = function(query, callback) {\n    for (var i = 0; i < this.sources.length; ++i) {\n        if (_sourceAdapterIsCapable(this.sources[i], 'search')) {\n            return this.sources[i].search(query, callback);\n        }\n    }\n}\n\nOverlayFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {\n    var sources;\n    if (this.filterDispatchOnMethod) {\n        sources = [];\n        var sfl = styleFilters.list();\n        for (var si = 0; si < this.sources.length; ++si) {\n            var source = this.sources[si];\n            for (var fi = 0; fi < sfl.length; ++fi) {\n                var filter = sfl[fi];\n                if (!filter.method || filter.method == source.name) {\n                    sources.push(source);\n                    break;\n                }\n            }\n        }\n    } else {\n        sources = this.sources;\n    }\n\n    var baton = new OverlayBaton(this, callback, sources);\n    for (var si = 0; si < sources.length; ++si) {\n\t   this.fetchN(baton, si, sources[si], chr, min, max, scale, types, pool, styleFilters);\n    }\n}\n\nOverlayFeatureSource.prototype.fetchN = function(baton, si, source, chr, min, max, scale, types, pool, styleFilters) {\n    // FIXME should we try to prune styleFilters?\n    source.fetch(chr, min, max, scale, types, pool, function(status, features, scale) {\n\t   return baton.completed(si, status, features, scale);\n    }, styleFilters);\n}\n\nOverlayFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {\n    return this.sources[0].quantFindNextFeature(chr, pos, dir, threshold, callback);\n}\n\nOverlayFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {\n    return this.sources[0].findNextFeature(chr, pos, dir, callback);\n}\n\nfunction OverlayBaton(source, callback, sources) {\n    this.source = source;\n    this.callback = callback;\n    this.sources = sources;\n    this.count = sources.length;\n\n    this.returnCount = 0;\n    this.statusCount = 0;\n    this.returns = [];\n    this.features = []\n    this.statuses = [];\n    this.scale = null;\n}\n\nOverlayBaton.prototype.completed = function(index, status, features, scale) {\n    if (this.scale == null || index == 0) \n\t   this.scale = scale;\n\n    if (this.returns[index])\n\t   throw 'Multiple returns for source ' + index;\n\n    this.returns[index] = true;\n    this.returnCount++;\n\n    this.features[index] = features;\n\n    if (status) {\n    \tthis.statuses[index] = status;\n    \tthis.statusCount++;\n    }\n\n\n    if (this.returnCount == this.count) {\n    \tif (this.statusCount > 0) {\n    \t    var message = '';\n    \t    for (var si = 0; si < this.count; ++si) {\n        \t\tvar s = this.statuses[si];\n        \t\tif (s) {\n        \t\t    if (message.length > 0) \n        \t\t\tmessage += ', ';\n        \t\t    message += s;\n        \t\t}\n    \t    }\n    \t    return this.callback(message, null, this.scale);\n    \t} else {\n    \t    this.callback(null, this.source.merge(this.features, this.sources), this.scale);\n    \t}\n    }\n}\n\nOverlayFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    for (var si = 0; si < this.sources.length; ++si) {\n        var s = this.sources[si];\n        if (s.getDefaultFIPs)\n            s.getDefaultFIPs(callback);\n    }\n}\n\nOverlayFeatureSource.prototype.keyForFeature = function(feature) {\n    return '' + feature.min + '..' + feature.max;\n}\n\nfunction OverlayFeatureSource_merge_byKey(featureSets) {\n    var omaps = [];\n\n    for (var fsi = 1; fsi < featureSets.length; ++fsi) {\n        var om = {};\n        var of = featureSets[fsi];\n        for (var fi = 0; fi < of.length; ++fi) {\n    \t   om[this.keyForFeature(of[fi])] = of[fi];\n        }\n        omaps.push(om);\n    }\n\n\n    var mf = [];\n    var fl = featureSets[0];\n    for (var fi = 0; fi < fl.length; ++fi) {\n    \tvar f = fl[fi];\n\n        for (var oi = 0; oi < omaps.length; ++oi) {\n            var om = omaps[oi];\n        \tof = om[this.keyForFeature(f)]\n        \tif (of) {\n                for (var k in of) {\n                    if (k === 'score') {\n                        f.score2 = of.score;\n                    } else if (k === 'min' || k === 'max' || k === 'segment' || k === '_cachedStyle') {\n                        // do nothing\n                    } else {\n                        f[k] = of[k];\n                    }\n                }\n        \t}\n        }\n    \tmf.push(f);\n    }\n    return mf;\n}\n\nfunction OverlayFeatureSource_merge_concat(featureSets, sources) {\n    var features = [];\n    for (var fsi = 0; fsi < featureSets.length; ++fsi) {\n        var fs = featureSets[fsi];\n        var name = sources[fsi].name;\n        for (var fi = 0; fi < fs.length; ++fi) {\n            var f = fs[fi];\n            f.method = name;\n            features.push(f);\n        }\n    }\n    return features;\n}\n\nfunction _sourceAdapterIsCapable(s, cap) {\n    if (!s.capabilities)\n        return false;\n    else \n        return s.capabilities()[cap];\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        OverlayFeatureSource: OverlayFeatureSource\n    };\n}\n\n\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// bedwig.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n    var BlobFetchable = bin.BlobFetchable;\n    var readInt = bin.readInt;\n\n    var bbi = require('./bigwig');\n    var BIG_WIG_MAGIC = bbi.BIG_WIG_MAGIC;\n    var BIG_BED_MAGIC = bbi.BIG_BED_MAGIC;\n\n    var lh3utils = require('./lh3utils');\n    var unbgzf = lh3utils.unbgzf;\n\n    var bam = require('./bam');\n    var BAM_MAGIC = bam.BAM_MAGIC;\n    var BAI_MAGIC = bam.BAI_MAGIC;\n\n    var tbi = require('./tabix');\n    var TABIX_MAGIC = tbi.TABIX_MAGIC;\n\n    var EncodeFetchable = require('./encode').EncodeFetchable;\n}\n\nfunction probeResource(source, listener, retry) {\n    var BED_REGEXP = new RegExp('^\\\\w+\\\\s[0-9]+\\\\s[0-9]+.*$');\n    var KV_REGEXP=/([^=]+)=\\\"?([^\\\"]+)\\\"?/;\n    var VCFHEAD_RE = /^##\\s*fileformat=VCFv4\\..+/;\n\n    var fetchable;\n    if (source.blob)\n        fetchable = new BlobFetchable(source.blob);\n    else if (source.transport == 'encode')\n        fetchable = new EncodeFetchable(source.uri);\n    else\n        fetchable = new URLFetchable(source.uri, {credentials: source.credentials});\n\n    fetchable.slice(0, 1<<16).salted().fetch(function(result, error) {\n        if (!result) {\n            if (!retry) {\n                source.credentials = true;\n                probeResource(source, listener, true)\n            }\n\n            return listener(source, \"Couldn't fetch data\");\n        }\n\n        var ba = new Uint8Array(result);\n        var la = new Uint32Array(result, 0, 1);\n        var magic = la[0];\n        if (magic == BIG_WIG_MAGIC || magic == BIG_BED_MAGIC) {\n            source.tier_type = 'bwg';\n            var nameExtractPattern = new RegExp('/?([^/]+?)(.bw|.bb|.bigWig|.bigBed)?$');\n            var match = nameExtractPattern.exec(source.uri || source.blob.name);\n            if (match) {\n                source.name = match[1];\n            }\n\n            return listener(source, null);\n        } else if (magic == BAI_MAGIC) {\n            source.tier_type = 'bai';\n            return listener(source, null);\n        } else if (ba[0] == 31 || ba[1] == 139) {\n            var unc = unbgzf(result);\n            var uncba = new Uint8Array(unc);\n            magic = readInt(uncba, 0);\n            if (magic == BAM_MAGIC) {\n                source.tier_type = 'bam';\n                var nameExtractPattern = new RegExp('/?([^/]+?)(.bam)?$');\n                var match = nameExtractPattern.exec(source.uri || source.blob.name);\n                if (match) {\n                    source.name = match[1];\n                }\n\n                return listener(source, null);\n            } else if (magic == TABIX_MAGIC) {\n                source.tier_type = 'tabix-index';\n                return listener(source, null);\n            } else if (magic == 0x69662323) {\n                source.tier_type = 'tabix';\n                source.payload = 'vcf';\n                var nameExtractPattern = new RegExp('/?([^/]+?)(.vcf)?(.gz)?$');\n                var match = nameExtractPattern.exec(source.uri || source.blob.name);\n                if (match) {\n                    source.name = match[1];\n                }\n\n                return listener(source, null);\n            } else {\n                console.log('magic = ' + magic.toString(16));\n               return listener(source, \"Unsupported format\");\n            }\n        } else {\n            var text = String.fromCharCode.apply(null, ba);\n            var lines = text.split(\"\\n\");\n\n            if (lines.length > 0 && VCFHEAD_RE.test(lines[0])) {\n                source.tier_type = 'memstore';\n                source.payload = 'vcf';\n                var nameExtractPattern = new RegExp('/?([^/]+?)(\\.vcf)?$');\n                var match = nameExtractPattern.exec(source.uri || source.blob.name);\n                if (match && !source.name) {\n                    source.name = match[1];\n                }\n                return listener(source, null);\n            }\n\n            for (var li = 0; li < lines.length; ++li) {\n                var line = lines[li].replace('\\r', '');\n                if (line.length == 0) continue;\n\n                if (line.indexOf('browser') == 0) continue;\n\n                if (line.indexOf('track') == 0) {\n                    var maybeType = 'bed';\n                    var toks = line.split(/\\s/);\n                    for (var ti = 1; ti < toks.length; ++ti) {\n                        var m = KV_REGEXP.exec(toks[ti]);\n                        if (m) {\n                            if (m[1] == 'type' && m[2] == 'wiggle_0') {\n                                maybeType = 'wig'\n                            } else if (m[0] == 'name') {\n                                source.name = m[2];\n                            }\n                        }\n                    }\n\n                    finishProbeBedWig(source, maybeType);\n                    return listener(source, null);\n                }\n\n                if (line.indexOf('fixedStep') == 0) {\n                    finishProbeBedWig(source, 'wig');\n                    return listener(source, null);\n                }\n\n                if (line.indexOf('variableStep') == 0) {\n                    finishProbeBedWig(source, 'wig');\n                    return listener(source, null);\n                }\n\n                if (BED_REGEXP.test(line)) {\n                    finishProbeBedWig(source, null);\n                    return listener(source, null);\n                }\n\n                break;\n            }\n\n            return listener(source, \"Unsupported format\");\n        }\n    }, {timeout: 1500});  // Timeout to catch mixed-origin case on Chromium.\n}\n\nfunction finishProbeBedWig(source, maybeType) {\n    source.tier_type = 'memstore';\n    var nameExtractPattern = new RegExp('/?([^/]+?)(.(bed|wig))?$');\n    var match = nameExtractPattern.exec(source.uri || source.blob.name);\n    if (match) {\n        if (!source.name)\n            source.name = match[1];\n        if (!maybeType && match[3]) {\n            maybeType = match[3];\n        }\n    }\n    source.payload = maybeType || 'bed';\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        probeResource: probeResource\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// sample.js: downsampling of quantitative features\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var das = require('./das');\n    var DASFeature = das.DASFeature;\n\n    var parseCigar = require('./cigar').parseCigar;\n\n    var shallowCopy = require('./utils').shallowCopy;\n}\n\nvar __DS_SCALES = [1, 2, 5];\n\nfunction ds_scale(n) {\n    return __DS_SCALES[n % __DS_SCALES.length] * Math.pow(10, (n / __DS_SCALES.length)|0);\n}\n\n\nfunction DSBin(scale, min, max) {\n    this.scale = scale;\n    this.tot = 0;\n    this.cnt = 0;\n    this.hasScore = false;\n    this.min = min; this.max = max;\n    this.features = [];\n}\n\nfunction _featureOrder(a, b) {\n    if (a.min < b.min) {\n        return -1;\n    } else if (a.min > b.min) {\n        return 1;\n    } else if (a.max < b.max) {\n        return -1;\n    } else if (b.max > a.max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nDSBin.prototype.score = function() {\n    if (this.cnt == 0) {\n        return 0;\n    } else if (this.hasScore) {\n        return this.tot / this.cnt;\n    } else {\n        var features = this.features;\n        features.sort(_featureOrder);\n\n        var maxSeen = -10000000000;\n        var cov=0, lap=0;\n\n        for (var fi = 1; fi < features.length; ++fi) {\n            var f = features[fi];\n            var lMin = Math.max(f.min, this.min);\n            var lMax = Math.min(f.max, this.max);\n            lap += (lMax - lMin + 1);\n\n            if (lMin > maxSeen) {\n                cov += lMax - lMin + 1;\n                maxSeen = lMax;\n            } else {\n                if (lMax > maxSeen) {\n                    cov += (lMax - maxSeen);\n                    maxSeen = lMax;\n                }\n            }\n        }\n\n        if (cov > 0)\n            return (1.0 * lap) / cov;\n        else\n            return 0;\n    }\n}\n\nDSBin.prototype.feature = function(f) {\n    if (f.score !== undefined) {\n        this.tot += f.score;\n        this.hasScore = true\n    }\n\n    ++this.cnt;\n    this.features.push(f);\n}\n\nfunction downsample(features, targetRez) {\n    var sn = 0;\n    while (ds_scale(sn + 1) < targetRez) {\n        ++sn;\n    }\n    var scale = ds_scale(sn);\n\n    var binTots = [];\n    var maxBin = -10000000000;\n    var minBin = 10000000000;\n    for (var fi = 0; fi < features.length; ++fi) {\n        var f = features[fi];\n        if (f.groups && f.groups.length > 0) {\n            // Don't downsample complex features (?)\n            return features;\n        }\n\n        var minLap = (f.min / scale)|0;\n        var maxLap = (f.max / scale)|0;\n        maxBin = Math.max(maxBin, maxLap);\n        minBin = Math.min(minBin, minLap);\n        for (var b = minLap; b <= maxLap; ++b) {\n            var bm = binTots[b];\n            if (!bm) {\n                bm = new DSBin(scale, b * scale, (b + 1) * scale - 1);\n                binTots[b] = bm;\n            }\n            bm.feature(f);\n        }\n    }\n\n    var sampledFeatures = [];\n    for (var b = minBin; b <= maxBin; ++b) {\n        var bm = binTots[b];\n        if (bm) {\n            var f = new DASFeature();\n            f.segment = features[0].segment;\n            f.min = (b * scale) + 1;\n            f.max = (b + 1) * scale;\n            f.score = bm.score();\n            f.type = 'density';\n            sampledFeatures.push(f);\n        }\n    }\n\n    var afterDS = Date.now();\n    return sampledFeatures;\n}\n\n/** Data structure to store information for\na base position:\n\npos: position of the base.\n*/\nfunction BaseBin(pos) {\n\n    this._pos = pos;\n    this._bases = {};\n    this._totalCount = 0;\n}\n\n/** Keep record for incidence of a base,\nwith related qual score and strand for a position.\n\nParams\n    base: base (e.g A, T, G, C, N) observed at position.\n    qual: numeric quality score.\n    strand: '+' or '-'.\n*/\nBaseBin.prototype.recordBase = function(base, qual, strand) {\n    if (!this._bases[base]) {\n        var strandComposition = {'+': 0, '-': 0};\n        strandComposition[strand]++;\n        this._bases[base] = {\n            cnt: 1,\n            totalQual: qual,\n            strandCnt: strandComposition\n        };\n    } else {\n        var baseComposition = this._bases[base];\n        baseComposition.cnt++;\n        baseComposition.totalQual += qual;\n        baseComposition.strandCnt[strand]++;\n    }\n    this._totalCount++;\n};\n\n/** Returns count of total number of bases observed at position */\nBaseBin.prototype.totalCount = function() {return this._totalCount;};\n\n/** Returns the base position */\nBaseBin.prototype.pos = function() {return this._pos;};\n\n/** Creates a list of tag, info pairs in the form\n[tag]=[info] for each base, for use in feature-popup */\nBaseBin.prototype.infoList = function() {\n    var info = [];\n    var totalCount = this._totalCount;\n    var totalCountStr = \"Depth=\" + totalCount.toString();\n    info.push(totalCountStr);\n    for (var base in this._bases) {\n        var baseComposition = this._bases[base];\n        var baseCnt = baseComposition.cnt;\n        var basePercentage = (baseCnt * 100 / totalCount); \n        var plusStrandCnt = baseComposition.strandCnt['+'];\n        var minusStrandCnt = baseComposition.strandCnt['-'];\n        var meanQual = baseComposition.totalQual/baseCnt;\n\n        var baseInfoString = [base, '=', baseCnt, ' (', basePercentage.toFixed(0), '%, ',\n                              plusStrandCnt, ' +, ', minusStrandCnt, ' -, Qual: ', meanQual.toFixed(0), ')'];\n        info.push(baseInfoString.join(''));\n    }\n    return info;\n};\n\n/** Return a list of objects for creating a\nhistogram showing composition of different bases at a\ngiven location.\n\nCurrent implementation is hacky: the logic involves\noverlaying BoxGlyphs on top of each other, thus the score\nis not meaningful, but only used to manipulate height.\n\nParams:\n  ref: reference base at position\n  threshold: value between 0 and 1 representing min allele frequency\n              below which the allele will be ignored in histogram.\n              (interpreted as noise)\n              Similar to 'allele threshold' parameter in IGV\n\nReturns a list of objects containing 2 properties\n    base: such as A, T, G, C, N, - (del)\n    score: a numeric score for determining height of histogram\nThe list is ordered such that a preceeding object always have a\nscore >= the current object, and the ref base will be the last item.\n\nExample: There are 50 T's and 40 A's (total depth = 90)\nat a base where ref=A. The function will return\n[T: 90, A: 40]. When creating a histogram with overlap,\nthis will give an appearance of 40 A's (bottom) and 50 T's (top):\n#######\n#  T  #\n#  T  #\n#  T  #\n#  T  #\n#  T  #\n#######\n#  A  #\n#  A  #\n#  A  #\n#  A  #\n#######\n*/\nBaseBin.prototype.baseScoreList = function(ref, threshold) {\n    var baseScoreList = [];\n    var totalCount = this._totalCount;\n    var minCount = threshold * totalCount;\n    for (var base in this._bases) {\n        var baseCount = this._bases[base].cnt;\n        if (baseCount < minCount || base == ref)\n            continue;\n        var baseScorePair = {base: base, score: totalCount};\n        baseScoreList.push(baseScorePair);\n        totalCount -= baseCount;\n    }\n    baseScoreList.push({base: ref, score: totalCount});\n    return baseScoreList;\n};\n\n/** Generates an aligned read from the raw sequence of a BAM record\nusing given cigar string.\n\nParams:\n  rawseq: unaligned read sequence from Bam record\n  rawquals: unaligned read quals from Bam record\n  cigar: Bam cigar string from Bam record\n\nReturns an object with 2 properties:\n  seq: string containing aligned read\n  quals: string containing printable-character representation\n         of sequencing quality score\n*/\nfunction alignSeqUsingCigar(rawseq, rawquals, cigar) {\n    var ops = parseCigar(cigar);\n    var seq = [];\n    var quals = [];\n    var cursor = 0;\n    for (var ci = 0; ci < ops.length; ++ci) {\n        var co = ops[ci];\n        if (co.op == 'M') {\n            seq.push(rawseq.substr(cursor, co.cnt));\n            quals.push(rawquals.substr(cursor, co.cnt));\n            cursor += co.cnt;\n        } else if (co.op == 'D') {\n            for (var oi = 0; oi < co.cnt; ++oi) {\n                seq.push('-');\n                quals.push('Z');\n            }\n        } else if (co.op == 'I') {\n            cursor += co.cnt;\n        } else if (co.op == 'S') {\n            cursor += co.cnt;\n        } else {\n            console.log('unknown cigop' + co.op);\n        }\n    }\n    var processedSeq = {seq: seq.join(''), quals: quals.join('')};\n    return processedSeq;\n}\n\n/** Constructs the reference sequence for a given window.\n\nParams\n    currentSequence: DasSequence object containing ref sequence\n                     in current browser view.\n    min, max: min and max position for window.\n\nReturns a string containing the refseq, padded with 'N' where sequence is not\n    available.\n*/\nfunction getRefSeq(currentSequence, min, max) {\n    var refSeq = [];\n    if (currentSequence) {\n        var csStart = currentSequence.start|0;\n        var csEnd = currentSequence.end|0;\n        if (csStart <= max && csEnd >= min) {\n            var sfMin = Math.max(min, csStart);\n            var sfMax = Math.min(max, csEnd);\n\n            for (var i = 0; i < sfMin - min; i++)\n                refSeq.push('N');\n            refSeq.push(currentSequence.seq.substr(sfMin - csStart, sfMax - sfMin + 1));\n            for (var i = 0; i < max - sfMax; i++)\n                refSeq.push('N');\n        }\n    }\n    return refSeq.join('');\n}\n\n/** Constructs features necessary for a coverage track showing\nbase composition for BAM reads\n\nParams\n    features: a list of features from BAM records.\n    currentRefSeq: a DASSequence object containing reference sequence.\n    baseColors: an object mapping base to desired colors.\n\nReturns a list of features of type base-coverage.\n*/\nfunction getBaseCoverage(features, currentRefSeq, baseColors) {\n    var minBin = null;\n    var maxBin = null;\n\n    var allBins = [];\n\n    // Populate BaseBins\n    for (var fi = 0; fi < features.length; ++fi) {\n        var f = features[fi];\n        if (f.groups && f.groups.length > 0) {\n            // Don't downsample complex features\n            return features;\n        }\n        var processedSeq = alignSeqUsingCigar(f.seq, f.quals, f.cigar);\n        var seq = processedSeq.seq;\n        var quals = processedSeq.quals;\n        var strand = f.orientation;\n        var minForFeature = f.min || 0;\n        var maxForFeature = f.max || 0;\n        var ind = 0;\n\n        for (var b = minForFeature; b <= maxForFeature; ++b) {\n            var bm = allBins[b];\n            if (!bm) {\n                bm = new BaseBin(b);\n                allBins[b] = bm;\n            }\n            var base = seq.charAt(ind);\n            var qual = quals.charCodeAt(ind) - 33; // Generate numeric qual score\n            bm.recordBase(base, qual, strand);\n            ind++;\n        }\n\n        if (!minBin)\n            minBin = minForFeature;\n        else\n            minBin = Math.min(minBin, minForFeature);\n        if (!maxBin)\n            maxBin = maxForFeature;\n        else\n            maxBin = Math.max(maxBin, maxForFeature);\n    }\n\n    // Generate coverage features\n    var refSeq = getRefSeq(currentRefSeq, minBin, maxBin);\n    var baseFeatures = [];\n    var ind = 0;\n    for (var b = minBin; b <= maxBin; ++b) {\n        var bm = allBins[b];\n        if (bm) {\n            var f = new DASFeature();\n            f.segment = features[0].segment;\n            f.min = bm.pos();\n            f.max = f.min;\n            f.notes = [];\n            f.notes = f.notes.concat(bm.infoList());\n            f.type = 'base-coverage';\n            f.suppressScore = true;\n            if (refSeq) {\n                var refBase = refSeq.charAt(ind);\n                var refString = 'Ref=' + refBase;\n                f.notes.unshift(refString);\n                var baseScoreList = bm.baseScoreList(refBase, 0.2);\n                // TODO: shift 0.2 threshold to a config parameter\n                for (var i = 0; i < baseScoreList.length; i++) {\n                    var base = baseScoreList[i].base;\n                    var score = baseScoreList[i].score;\n                    var fBase = shallowCopy(f);\n                    fBase.score = score;\n                    // Color by baseColor when mismatch occurs\n                    // otherwise, BoxGlyph to COLOR1 in style\n                    if (baseScoreList.length > 1 || base != refBase)\n                        fBase.itemRgb = baseColors[base];\n\n                    baseFeatures.push(fBase);\n                }\n            } else {\n                // No refSeq, only show coverage height.\n                baseFeatures.push(f);\n            }\n        }\n        ind ++;\n    }\n    return baseFeatures;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        downsample: downsample,\n        getBaseCoverage: getBaseCoverage\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// bin.js general binary data support\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n\n    var connectTrix = require('./trix').connectTrix;\n}\n\nvar REGION_PATTERN = /^([\\d+,\\w,\\.,\\_,\\-]+)[\\s:]+([0-9,\\.]+?)([KkMmGg])?((-|\\.\\.|\\s)+([0-9,\\.]+)([KkMmGg])?)?$/;\n\nfunction parseLocCardinal(n, m) {\n    var i = parseFloat(n.replace(/,/g, ''));\n    if (m === 'k' || m === 'K') {\n        return (i * 1000)|0;\n    } else if (m == 'm' || m === 'M') {\n        return (i * 1000000)|0;\n    } else {\n        return i|0;\n    }\n}\n\nBrowser.prototype.search = function(g, statusCallback) {\n    var thisB = this;\n    var m = REGION_PATTERN.exec(g);\n\n    if (m) {\n        var chr = m[1], start, end;\n        if (m[6]) {\n            start = parseLocCardinal(m[2],  m[3]);\n            end = parseLocCardinal(m[6], m[7]);\n        } else {\n            var width = this.viewEnd - this.viewStart + 1;\n            start = (parseLocCardinal(m[2], m[3]) - (width/2))|0;\n            end = start + width - 1;\n        }\n        this.setLocation(chr, start, end, statusCallback);\n    } else {\n        if (!g || g.length == 0) {\n            return false;\n        }\n\n        var searchCount = 0;\n        var foundLatch = false;\n\n        var searchCallback = function(found, err) {\n            --searchCount;\n            if (err) {\n                return statusCallback(err);\n            }\n\n            if (!found) found = [];\n            var min = 500000000, max = -100000000;\n            var nchr = null;\n            for (var fi = 0; fi < found.length; ++fi) {\n                var f = found[fi];\n            \n                if (nchr == null) {\n                    nchr = f.segment;\n                }\n                min = Math.min(min, f.min);\n                max = Math.max(max, f.max);\n            }\n\n            if (!nchr) {\n                if (searchCount == 0 && !foundLatch)\n                    return statusCallback(\"no match for '\" + g + \"'\");\n            } else {\n                foundLatch = true;\n                thisB.highlightRegion(nchr, min, max);\n            \n                var padding = Math.max(2500, (0.3 * (max - min + 1))|0);\n                thisB.setLocation(nchr, min - padding, max + padding, statusCallback);\n            }\n        }\n\n        var doTrixSearch = function(tier, trix) {\n            trix.lookup(g, function(result, status) {\n                if (result == null || result.length < 2) {\n                    return tier.featureSource.search(g, searchCallback);\n                } else {\n                    var hit = result[1].split(',')[0];\n                    return tier.featureSource.search(hit, searchCallback);\n                }\n            });\n        }\n\n        if (this.searchEndpoint) {\n            searchCount = 1;\n            return this.doDasSearch(thisB.searchEndpoint, g, searchCallback);\n        }\n\n        for (var ti = 0; ti < this.tiers.length; ++ti) {\n            (function(tier) {\n                if (thisB.sourceAdapterIsCapable(tier.featureSource, 'search')) {\n                    if (tier.dasSource.trixURI) {\n                        ++searchCount;\n                        if (tier.trix) {\n                            doTrixSearch(tier, tier.trix);\n                        } else {\n                            var ix = new URLFetchable(\n                                tier.dasSource.trixURI,\n                                {credentials: tier.dasSource.credentials,\n                                 resolver: tier.dasSource.resolver}\n                            );\n\n                            var ixx = new URLFetchable(\n                                tier.dasSource.trixxURI || (tier.dasSource.trixURI + 'x'),\n                                {credentials: tier.dasSource.credentials,\n                                 resolver: tier.dasSource.resolver}\n                            );\n\n                            connectTrix(ix, ixx, function(trix) {\n                                tier.trix = trix;\n                                doTrixSearch(tier, trix);\n                            });\n                        }\n                    } else {\n                        ++searchCount;\n                        tier.featureSource.search(g, searchCallback);\n                    }\n                } else if (tier.dasSource.provides_search) {\n                    ++searchCount;\n                    thisB.doDasSearch(tier.dasSource, g, searchCallback);\n                }\n            })(this.tiers[ti]);\n        }\n    }\n}\n\nBrowser.prototype.doDasSearch = function(source, g, searchCallback) {\n    var thisB = this;\n    source.features(null, {group: g, type: 'transcript'}, function(found) {\n        if (!found) found = [];\n        var min = 500000000, max = -100000000;\n        var nchr = null;\n\n        var found2 = [];\n        for (var fi = 0; fi < found.length; ++fi) {\n            var f = found[fi];\n            \n            if (f.label.toLowerCase() != g.toLowerCase()) {\n                // ...because Dazzle can return spurious overlapping features.\n                continue;\n            }\n            found2.push(f);\n        }\n\n        return searchCallback(found2);\n    }, false);\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2012\n//\n// sequence-draw.js: renderers for sequence-related data\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var formatLongInt = utils.formatLongInt;\n    var makeElementNS = utils.makeElementNS;\n\n    var svgu = require('./svg-utils');\n    var NS_SVG = svgu.NS_SVG;\n    var NS_XLINK = svgu.NS_XLINK;\n    var SVGPath = svgu.SVGPath;\n\n    var nf = require('./numformats');\n    var formatLongInt = nf.formatLongInt;\n}\n\nvar MIN_TILE = 100;\nvar rulerTileColors = ['black', 'white'];\n\nvar steps = [1,2,5];\n\n\nvar NS_SVG = 'http://www.w3.org/2000/svg';\n\n\nfunction tileSizeForScale(scale, min)\n{\n    if (!min) {\n        min = MIN_TILE;\n    }\n\n    function ts(p) {\n        return steps[p % steps.length] * Math.pow(10, (p / steps.length)|0);\n    }\n    var pow = steps.length;\n    while (scale * ts(pow) < min) {\n        ++pow;\n    }\n    return ts(pow);\n}\n\nfunction drawSeqTier(tier, seq) {\n    var gc = tier.viewport.getContext('2d');\n    var retina = tier.browser.retina && window.devicePixelRatio > 1;\n    var desiredWidth = tier.browser.featurePanelWidth + 2000;\n    if (retina) {\n        desiredWidth *= 2;\n    }\n    var fpw = tier.viewport.width|0; // this.browser.featurePanelWidth;\n    if (fpw < desiredWidth - 50) {\n        tier.viewport.width = fpw = desiredWidth;\n    }\n\n    var height = 50;\n    if (seq && seq.seq) {\n        height += 25;\n    }\n\n    var canvasHeight = height;\n    if (retina) \n        canvasHeight *= 2;\n\n    tier.viewport.height = canvasHeight;\n    tier.viewport.style.height = '' + height + 'px';\n    tier.viewport.style.width = retina ? ('' + (fpw/2) + 'px') : ('' + fpw + 'px');\n    tier.layoutHeight = height;\n    tier.updateHeight();\n\n    \n    if (tier.background) {\n        gc.fillStyle = tier.background;\n        gc.fillRect(0, 0, fpw, tier.viewport.height);\n    }\n    if (retina) {\n        gc.scale(2, 2);\n    }\n\n    gc.translate(1000,0);\n    drawSeqTierGC(tier, seq, gc);\n    tier.norigin = tier.browser.viewStart;\n    tier.viewportHolder.style.left = '-1000px';\n}\n\nfunction drawSeqTierGC(tier, seq, gc)\n{\n    var scale = tier.browser.scale, knownStart = tier.browser.viewStart - (1000/scale)|0, knownEnd = tier.browser.viewEnd + (2000/scale), currentSeqMax = tier.browser.currentSeqMax;\n\n    var seqTierMax = knownEnd;\n    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {\n        seqTierMax = currentSeqMax;\n    }\n    var tile = tileSizeForScale(scale);\n    var pos = Math.max(0, ((knownStart / tile)|0) * tile);\n    \n    var origin = tier.browser.viewStart;\n\n    while (pos <= seqTierMax) {\n\t\tgc.fillStyle = ((pos / tile) % 2 == 0) ? 'white' : 'black';\n\t\tgc.strokeStyle = 'black';\n\t\tgc.fillRect((pos - origin) * scale,\n\t\t\t    8,\n\t\t\t    tile*scale,\n\t\t\t    3);\n\t\tgc.strokeRect((pos - origin) * scale,\n\t\t\t      8,\n\t\t\t      tile*scale,\n\t\t\t      3);\n\n\t\tgc.fillStyle = 'black';\n\t\tgc.fillText(formatLongInt(pos), ((pos - origin) * scale), 22);\n\t\t\n\n\t\tpos += tile;\n    }\n\n    if (seq && seq.seq) {\n\t\tfor (var p = knownStart; p <= knownEnd; ++p) {\n\t\t    if (p >= seq.start && p <= seq.end) {\n\t\t\t\tvar base = seq.seq.substr(p - seq.start, 1).toUpperCase();\n\t\t\t\tvar color = tier.browser.baseColors[base];\n\t\t\t\tif (!color) {\n\t\t            color = 'gray';\n\t\t\t\t}\n\n\t\t\t\tgc.fillStyle = color;\n\n\t\t\t\tif (scale >= 8) {\n                    var w = gc.measureText(base).width;\n                    // console.log(scale-w);\n\t\t\t\t    gc.fillText(base, (p - origin) * scale + ((scale-w)*0.5) , 52);\n\t\t\t\t} else {\n\t\t\t\t    gc.fillRect((p - origin) * scale, 42, scale, 12); \n\t\t\t\t}\n\t\t    }\n\t\t}\n    }\n}\n\nfunction svgSeqTier(tier, seq) {\n    var scale = tier.browser.scale, knownStart = tier.browser.viewStart - (1000/scale)|0, knownEnd = tier.browser.viewEnd + (2000/scale), currentSeqMax = tier.browser.currentSeqMax;\n\n    var fpw = tier.viewport.width|0; \n\n    var seqTierMax = knownEnd;\n    if (currentSeqMax > 0 && currentSeqMax < knownEnd) {\n        seqTierMax = currentSeqMax;\n    }\n    var tile = tileSizeForScale(scale);\n    var pos = Math.max(0, ((knownStart / tile)|0) * tile);\n    \n    var origin = tier.browser.viewStart;\n\n    var  g = makeElementNS(NS_SVG, 'g', [], {fontSize: '8pt'}); \n    while (pos <= seqTierMax) {\n    \tg.appendChild(\n    \t    makeElementNS(\n    \t\tNS_SVG, 'rect',\n    \t\tnull,\n    \t\t{x: (pos-origin)*scale,\n    \t\t y: 8,\n    \t\t width: tile*scale,\n    \t\t height: 3,\n    \t\t fill: ((pos / tile) % 2 == 0) ? 'white' : 'black',\n    \t\t stroke: 'black'}));\n\n    \tg.appendChild(\n    \t    makeElementNS(\n    \t\tNS_SVG, 'text',\n    \t\tformatLongInt(pos),\n    \t\t{x: (pos-origin)*scale,\n    \t\t y: 28,\n    \t\t fill: 'black', stroke: 'none'}));\n    \t\n    \tpos += tile;\n    }\n\n    if (seq && seq.seq) {\n    \tfor (var p = knownStart; p <= knownEnd; ++p) {\n    \t    if (p >= seq.start && p <= seq.end) {\n        \t\tvar base = seq.seq.substr(p - seq.start, 1).toUpperCase();\n        \t\tvar color = tier.browser.baseColors[base];\n        \t\tif (!color) {\n                    color = 'gray';\n        \t\t}\n\n        \t\tif (scale >= 8) {\n        \t\t    g.appendChild(\n        \t\t\tmakeElementNS(NS_SVG, 'text', base, {\n        \t\t\t    x: (0.5+p-origin)*scale,\n        \t\t\t    y: 52,\n                        textAnchor: 'middle',\n        \t\t\t    fill: color}));\n        \t\t} else {\n        \t\t    g.appendChild(\n        \t\t\tmakeElementNS(NS_SVG, 'rect', null, {\n        \t\t\t    x: (p - origin)*scale,\n        \t\t\t    y: 42,\n        \t\t\t    width: scale,\n        \t\t\t    height: 12,\n        \t            fill: color}));\n\n        \t\t}\n    \t    }\n    \t}\n    } \n\n    return g;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        drawSeqTier: drawSeqTier,\n        drawSeqTierGC: drawSeqTierGC,\n        svgSeqTier: svgSeqTier\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// session.js\n//\n\n\"use strict\";\n\nif (typeof(require) != 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var sc = require('./sourcecompare');\n    var sourceDataURI = sc.sourceDataURI;\n    var sourcesAreEqual = sc.sourcesAreEqual;\n\n    var VERSION = require('./version');\n\n    var utils = require('./utils');\n    var miniJSONify = utils.miniJSONify;\n\n    var sha1 = require('./sha1');\n    var hex_sha1 = sha1.hex_sha1;\n}\n\nBrowser.prototype.nukeStatus = function() {\n    delete localStorage['dalliance.' + this.cookieKey + '.view-chr'];\n    delete localStorage['dalliance.' + this.cookieKey + '.view-start'];\n    delete localStorage['dalliance.' + this.cookieKey + '.view-end'];\n    delete localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];\n    delete localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'];\n    delete localStorage['dalliance.' + this.cookieKey + '.saved-zoom'];\n\n    delete localStorage['dalliance.' + this.cookieKey + '.sources'];\n    delete localStorage['dalliance.' + this.cookieKey + '.hubs'];\n    delete localStorage['dalliance.' + this.cookieKey + '.version'];\n\n    delete localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];\n    delete localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];\n    delete localStorage['dalliance.' + this.cookieKey + '.ruler-location'];\n}\n\nBrowser.prototype.storeStatus = function() {\n    this.storeViewStatus();\n    this.storeTierStatus();\n}\n\nBrowser.prototype.storeViewStatus = function() {\n    if (!this.cookieKey || this.noPersist || this.noPersistView) {\n        return;\n    }\n\n    localStorage['dalliance.' + this.cookieKey + '.view-chr'] = this.chr;\n    localStorage['dalliance.' + this.cookieKey + '.view-start'] = this.viewStart|0;\n    localStorage['dalliance.' + this.cookieKey + '.view-end'] = this.viewEnd|0\n    localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom'] = '' + this.isSnapZooming;\n    localStorage['dalliance.' + this.cookieKey + '.saved-zoom'] = this.savedZoom;\n    if (this.currentSeqMax) {\n\t   localStorage['dalliance.' + this.cookieKey + '.current-seq-length'] = this.currentSeqMax;\n    }\n}\n\n\nBrowser.prototype.storeTierStatus = function() {\n    if (!this.cookieKey || this.noPersist) {\n        return;\n    }\n\n    var currentSourceList = [];\n    for (var t = 0; t < this.tiers.length; ++t) {\n        var tt = this.tiers[t];\n        var ts = tt.dasSource;\n        if (!ts.noPersist) {\n            currentSourceList.push({source: tt.dasSource, config: tt.config || {}});\n        }\n    }\n    localStorage['dalliance.' + this.cookieKey + '.sources'] = JSON.stringify(currentSourceList);\n\n\n    var coveredHubURLs = {};\n    var currentHubList = [];\n    for (var hi = 0; hi < this.hubObjects.length; ++hi) {\n        var tdb = this.hubObjects[hi];\n        var hc = {url: tdb.hub.url, genome: tdb.genome};\n        if (tdb.credentials)\n            hc.credentials = tdb.credentials;\n        if (tdb.mapping)\n            hc.mapping = tdb.mapping;\n        coveredHubURLs[hc.url] = true;\n        currentHubList.push(hc);\n    }\n\n    // Needed to handle hubs that failed to connect, or hubs that haven't\n    // connected yet when we're called soon after startup.\n    for (var hi = 0; hi < this.hubs.length; ++hi) {\n        var hc = this.hubs[hi];\n        if (typeof hc === 'string')\n            hc = {url: hc};\n        if (!coveredHubURLs[hc.url])\n            currentHubList.push(hc);\n    }\n\n    localStorage['dalliance.' + this.cookieKey + '.hubs'] = JSON.stringify(currentHubList);\n\n    localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'] = this.reverseScrolling;\n    localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'] = this.reverseKeyScrolling;\n    localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'] = this.singleBaseHighlight;\n    localStorage['dalliance.' + this.cookieKey + '.ruler-location'] = this.rulerLocation;\n\n    localStorage['dalliance.' + this.cookieKey + '.export-ruler'] = this.exportRuler;\n    localStorage['dalliance.' + this.cookieKey + '.export-highlights'] = this.exportHighlights;\n    \n    localStorage['dalliance.' + this.cookieKey + '.version'] = VERSION.CONFIG;\n}\n\nBrowser.prototype.restoreStatus = function() {\n    if (this.noPersist)\n        return;\n    \n    var storedConfigVersion = localStorage['dalliance.' + this.cookieKey + '.version'];\n    if (storedConfigVersion) {\n        storedConfigVersion = storedConfigVersion|0;\n    } else {\n        storedConfigVersion = -100;\n    }\n    if (VERSION.CONFIG != storedConfigVersion) {\n        return;\n    }\n\n    var storedConfigHash = localStorage['dalliance.' + this.cookieKey + '.configHash'] || '';\n    var pageConfigHash = hex_sha1(miniJSONify({sources: this.sources, hubs: this.hubs}));\n    if (pageConfigHash != storedConfigHash) {\n        localStorage['dalliance.' + this.cookieKey + '.configHash'] = pageConfigHash;\n        return;\n    }\n\n    var defaultSourcesByURI = {};\n    for (var si = 0; si < this.sources.length; ++si) {\n        var source = this.sources[si];\n        if (!source)\n            continue;\n\n        var uri = sourceDataURI(source);\n        var ul = defaultSourcesByURI[uri];\n        if (!ul)\n            defaultSourcesByURI[uri] = ul = [];\n        ul.push(source);\n        \n    }\n\n    if (!this.noPersistView) {\n        var qChr = localStorage['dalliance.' + this.cookieKey + '.view-chr'];\n        var qMin = localStorage['dalliance.' + this.cookieKey + '.view-start']|0;\n        var qMax = localStorage['dalliance.' + this.cookieKey + '.view-end']|0;\n        if (qChr && qMin && qMax) {\n        \tthis.chr = qChr;\n        \tthis.viewStart = qMin;\n        \tthis.viewEnd = qMax;\n        \t\n        \tvar csm = localStorage['dalliance.' + this.cookieKey + '.current-seq-length'];\n        \tif (csm) {\n        \t    this.currentSeqMax = csm|0;\n        \t}\n\n            this.isSnapZooming = (localStorage['dalliance.' + this.cookieKey + '.showing-alt-zoom']) == 'true';\n\n            var sz = parseFloat(localStorage['dalliance.' + this.cookieKey + '.saved-zoom']);\n            if (typeof sz === 'number' && !isNaN(sz)) {\n                this.savedZoom = sz;\n            }\n        }\n    }\n\n    var rs = localStorage['dalliance.' + this.cookieKey + '.reverse-scrolling'];\n    this.reverseScrolling = (rs && rs == 'true');\n    var rks = localStorage['dalliance.' + this.cookieKey + '.reverse-key-scrolling'];\n    this.reverseKeyScrolling = (rks && rks == 'true');\n    var sbh = localStorage['dalliance.' + this.cookieKey + '.single-base-highlight'];\n    this.singleBaseHighlight = (sbh && sbh == 'true');\n \n    var rl = localStorage['dalliance.' + this.cookieKey + '.ruler-location'];\n    if (rl)\n        this.rulerLocation = rl;\n\n    var x = localStorage['dalliance.' + this.cookieKey + '.export-ruler'];\n    if (x)\n        this.exportRuler = (x === 'true');\n    var x = localStorage['dalliance.' + this.cookieKey + '.export-highlights'];\n    if (x)\n        this.exportHighlights = (x === 'true');\n\n    var sourceStr = localStorage['dalliance.' + this.cookieKey + '.sources'];\n    if (sourceStr) {\n\t    var storedSources = JSON.parse(sourceStr);\n        this.sources = [];\n        this.restoredConfigs = [];\n        for (var si = 0; si < storedSources.length; ++si) {\n            var source = this.sources[si] = storedSources[si].source;\n            this.restoredConfigs[si] = storedSources[si].config;\n            var uri = sourceDataURI(source);\n            var ul = defaultSourcesByURI[uri] || [];\n            for (var osi = 0; osi < ul.length; ++osi) {    \n                var oldSource = ul[osi];\n                if (sourcesAreEqual(source, oldSource)) {\n                    for (var k in oldSource) {\n                        if (oldSource.hasOwnProperty(k) && \n                            (typeof(oldSource[k]) === 'function' || oldSource[k] instanceof Blob))\n                        {\n                            source[k] = oldSource[k];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    var hubStr = localStorage['dalliance.' + this.cookieKey + '.hubs'];\n    if (hubStr) {\n        this.hubs = JSON.parse(hubStr);\n    }\n\n    return true;\n}\n\nBrowser.prototype.reset = function() {\n    for (var i = this.tiers.length - 1; i >= 0; --i) {\n       this.removeTier({index: i}, true);\n    }\n    for (var i = 0; i < this.defaultSources.length; ++i) {\n        var s = this.defaultSources[i];\n        if (!s.disabled) \n            this.addTier(this.defaultSources[i]);\n    }\n\n    this.highlights.splice(0, this.highlights.length);\n\n    this.setLocation(this.defaultChr, this.defaultStart, this.defaultEnd);\n}\n","/*\r\n * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined\r\n * in FIPS 180-1\r\n * Version 2.2 Copyright Paul Johnston 2000 - 2009.\r\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\r\n * Distributed under the BSD License\r\n * See http://pajhome.org.uk/crypt/md5 for details.\r\n */\r\n\r\n \"use strict\";\r\n\r\n/*\r\n * Configurable variables. You may need to tweak these to be compatible with\r\n * the server-side, but the defaults work in most cases.\r\n */\r\nvar hexcase = 0;  /* hex output format. 0 - lowercase; 1 - uppercase        */\r\nvar b64pad  = \"\"; /* base-64 pad character. \"=\" for strict RFC compliance   */\r\n\r\n/*\r\n * These are the functions you'll usually want to call\r\n * They take string arguments and return either hex or base-64 encoded strings\r\n */\r\nfunction hex_sha1(s)    { return rstr2hex(rstr_sha1(str2rstr_utf8(s))); }\r\nfunction b64_sha1(s)    { return rstr2b64(rstr_sha1(str2rstr_utf8(s))); }\r\nfunction any_sha1(s, e) { return rstr2any(rstr_sha1(str2rstr_utf8(s)), e); }\r\nfunction hex_hmac_sha1(k, d)\r\n  { return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\r\nfunction b64_hmac_sha1(k, d)\r\n  { return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d))); }\r\nfunction any_hmac_sha1(k, d, e)\r\n  { return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e); }\r\n\r\n/*\r\n * Perform a simple self-test to see if the VM is working\r\n */\r\nfunction sha1_vm_test()\r\n{\r\n  return hex_sha1(\"abc\").toLowerCase() == \"a9993e364706816aba3e25717850c26c9cd0d89d\";\r\n}\r\n\r\n/*\r\n * Calculate the SHA1 of a raw string\r\n */\r\nfunction rstr_sha1(s)\r\n{\r\n  return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));\r\n}\r\n\r\n/*\r\n * Calculate the HMAC-SHA1 of a key and some data (raw strings)\r\n */\r\nfunction rstr_hmac_sha1(key, data)\r\n{\r\n  var bkey = rstr2binb(key);\r\n  if(bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);\r\n\r\n  var ipad = Array(16), opad = Array(16);\r\n  for(var i = 0; i < 16; i++)\r\n  {\r\n    ipad[i] = bkey[i] ^ 0x36363636;\r\n    opad[i] = bkey[i] ^ 0x5C5C5C5C;\r\n  }\r\n\r\n  var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);\r\n  return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));\r\n}\r\n\r\n/*\r\n * Convert a raw string to a hex string\r\n */\r\nfunction rstr2hex(input)\r\n{\r\n  // try { hexcase } catch(e) { hexcase=0; }\r\n  var hex_tab = hexcase ? \"0123456789ABCDEF\" : \"0123456789abcdef\";\r\n  var output = \"\";\r\n  var x;\r\n  for(var i = 0; i < input.length; i++)\r\n  {\r\n    x = input.charCodeAt(i);\r\n    output += hex_tab.charAt((x >>> 4) & 0x0F)\r\n           +  hex_tab.charAt( x        & 0x0F);\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to a base-64 string\r\n */\r\nfunction rstr2b64(input)\r\n{\r\n  // try { b64pad } catch(e) { b64pad=''; }\r\n  var tab = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n  var output = \"\";\r\n  var len = input.length;\r\n  for(var i = 0; i < len; i += 3)\r\n  {\r\n    var triplet = (input.charCodeAt(i) << 16)\r\n                | (i + 1 < len ? input.charCodeAt(i+1) << 8 : 0)\r\n                | (i + 2 < len ? input.charCodeAt(i+2)      : 0);\r\n    for(var j = 0; j < 4; j++)\r\n    {\r\n      if(i * 8 + j * 6 > input.length * 8) output += b64pad;\r\n      else output += tab.charAt((triplet >>> 6*(3-j)) & 0x3F);\r\n    }\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an arbitrary string encoding\r\n */\r\nfunction rstr2any(input, encoding)\r\n{\r\n  var divisor = encoding.length;\r\n  var remainders = Array();\r\n  var i, q, x, quotient;\r\n\r\n  /* Convert to an array of 16-bit big-endian values, forming the dividend */\r\n  var dividend = Array(Math.ceil(input.length / 2));\r\n  for(i = 0; i < dividend.length; i++)\r\n  {\r\n    dividend[i] = (input.charCodeAt(i * 2) << 8) | input.charCodeAt(i * 2 + 1);\r\n  }\r\n\r\n  /*\r\n   * Repeatedly perform a long division. The binary array forms the dividend,\r\n   * the length of the encoding is the divisor. Once computed, the quotient\r\n   * forms the dividend for the next step. We stop when the dividend is zero.\r\n   * All remainders are stored for later use.\r\n   */\r\n  while(dividend.length > 0)\r\n  {\r\n    quotient = Array();\r\n    x = 0;\r\n    for(i = 0; i < dividend.length; i++)\r\n    {\r\n      x = (x << 16) + dividend[i];\r\n      q = Math.floor(x / divisor);\r\n      x -= q * divisor;\r\n      if(quotient.length > 0 || q > 0)\r\n        quotient[quotient.length] = q;\r\n    }\r\n    remainders[remainders.length] = x;\r\n    dividend = quotient;\r\n  }\r\n\r\n  /* Convert the remainders to the output string */\r\n  var output = \"\";\r\n  for(i = remainders.length - 1; i >= 0; i--)\r\n    output += encoding.charAt(remainders[i]);\r\n\r\n  /* Append leading zero equivalents */\r\n  var full_length = Math.ceil(input.length * 8 /\r\n                                    (Math.log(encoding.length) / Math.log(2)))\r\n  for(i = output.length; i < full_length; i++)\r\n    output = encoding[0] + output;\r\n\r\n  return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-8.\r\n * For efficiency, this assumes the input is valid utf-16.\r\n */\r\nfunction str2rstr_utf8(input)\r\n{\r\n  var output = \"\";\r\n  var i = -1;\r\n  var x, y;\r\n\r\n  while(++i < input.length)\r\n  {\r\n    /* Decode utf-16 surrogate pairs */\r\n    x = input.charCodeAt(i);\r\n    y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;\r\n    if(0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF)\r\n    {\r\n      x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);\r\n      i++;\r\n    }\r\n\r\n    /* Encode output as utf-8 */\r\n    if(x <= 0x7F)\r\n      output += String.fromCharCode(x);\r\n    else if(x <= 0x7FF)\r\n      output += String.fromCharCode(0xC0 | ((x >>> 6 ) & 0x1F),\r\n                                    0x80 | ( x         & 0x3F));\r\n    else if(x <= 0xFFFF)\r\n      output += String.fromCharCode(0xE0 | ((x >>> 12) & 0x0F),\r\n                                    0x80 | ((x >>> 6 ) & 0x3F),\r\n                                    0x80 | ( x         & 0x3F));\r\n    else if(x <= 0x1FFFFF)\r\n      output += String.fromCharCode(0xF0 | ((x >>> 18) & 0x07),\r\n                                    0x80 | ((x >>> 12) & 0x3F),\r\n                                    0x80 | ((x >>> 6 ) & 0x3F),\r\n                                    0x80 | ( x         & 0x3F));\r\n  }\r\n  return output;\r\n}\r\n\r\n/*\r\n * Encode a string as utf-16\r\n */\r\nfunction str2rstr_utf16le(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length; i++)\r\n    output += String.fromCharCode( input.charCodeAt(i)        & 0xFF,\r\n                                  (input.charCodeAt(i) >>> 8) & 0xFF);\r\n  return output;\r\n}\r\n\r\nfunction str2rstr_utf16be(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length; i++)\r\n    output += String.fromCharCode((input.charCodeAt(i) >>> 8) & 0xFF,\r\n                                   input.charCodeAt(i)        & 0xFF);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert a raw string to an array of big-endian words\r\n * Characters >255 have their high-byte silently ignored.\r\n */\r\nfunction rstr2binb(input)\r\n{\r\n  var output = Array(input.length >> 2);\r\n  for(var i = 0; i < output.length; i++)\r\n    output[i] = 0;\r\n  for(var i = 0; i < input.length * 8; i += 8)\r\n    output[i>>5] |= (input.charCodeAt(i / 8) & 0xFF) << (24 - i % 32);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Convert an array of big-endian words to a string\r\n */\r\nfunction binb2rstr(input)\r\n{\r\n  var output = \"\";\r\n  for(var i = 0; i < input.length * 32; i += 8)\r\n    output += String.fromCharCode((input[i>>5] >>> (24 - i % 32)) & 0xFF);\r\n  return output;\r\n}\r\n\r\n/*\r\n * Calculate the SHA-1 of an array of big-endian words, and a bit length\r\n */\r\nfunction binb_sha1(x, len)\r\n{\r\n  /* append padding */\r\n  x[len >> 5] |= 0x80 << (24 - len % 32);\r\n  x[((len + 64 >> 9) << 4) + 15] = len;\r\n\r\n  var w = Array(80);\r\n  var a =  1732584193;\r\n  var b = -271733879;\r\n  var c = -1732584194;\r\n  var d =  271733878;\r\n  var e = -1009589776;\r\n\r\n  for(var i = 0; i < x.length; i += 16)\r\n  {\r\n    var olda = a;\r\n    var oldb = b;\r\n    var oldc = c;\r\n    var oldd = d;\r\n    var olde = e;\r\n\r\n    for(var j = 0; j < 80; j++)\r\n    {\r\n      if(j < 16) w[j] = x[i + j];\r\n      else w[j] = bit_rol(w[j-3] ^ w[j-8] ^ w[j-14] ^ w[j-16], 1);\r\n      var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)),\r\n                       safe_add(safe_add(e, w[j]), sha1_kt(j)));\r\n      e = d;\r\n      d = c;\r\n      c = bit_rol(b, 30);\r\n      b = a;\r\n      a = t;\r\n    }\r\n\r\n    a = safe_add(a, olda);\r\n    b = safe_add(b, oldb);\r\n    c = safe_add(c, oldc);\r\n    d = safe_add(d, oldd);\r\n    e = safe_add(e, olde);\r\n  }\r\n  return Array(a, b, c, d, e);\r\n\r\n}\r\n\r\n/*\r\n * Perform the appropriate triplet combination function for the current\r\n * iteration\r\n */\r\nfunction sha1_ft(t, b, c, d)\r\n{\r\n  if(t < 20) return (b & c) | ((~b) & d);\r\n  if(t < 40) return b ^ c ^ d;\r\n  if(t < 60) return (b & c) | (b & d) | (c & d);\r\n  return b ^ c ^ d;\r\n}\r\n\r\n/*\r\n * Determine the appropriate additive constant for the current iteration\r\n */\r\nfunction sha1_kt(t)\r\n{\r\n  return (t < 20) ?  1518500249 : (t < 40) ?  1859775393 :\r\n         (t < 60) ? -1894007588 : -899497514;\r\n}\r\n\r\n/*\r\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\r\n * to work around bugs in some JS interpreters.\r\n */\r\nfunction safe_add(x, y)\r\n{\r\n  var lsw = (x & 0xFFFF) + (y & 0xFFFF);\r\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\r\n  return (msw << 16) | (lsw & 0xFFFF);\r\n}\r\n\r\n/*\r\n * Bitwise rotate a 32-bit number to the left.\r\n */\r\nfunction bit_rol(num, cnt)\r\n{\r\n  return (num << cnt) | (num >>> (32 - cnt));\r\n}\r\n\r\nif (typeof(module) !== 'undefined') {\r\n  module.exports = {\r\n    b64_sha1: b64_sha1,\r\n    hex_sha1: hex_sha1\r\n  }\r\n}\r\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// sourceadapters.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var tier = require('./tier');\n    var DasTier = tier.DasTier;\n\n    var utils = require('./utils')\n    var Awaited = utils.Awaited;\n    var arrayIndexOf = utils.arrayIndexOf;\n    var shallowCopy = utils.shallowCopy;\n    var resolveUrlToPage = utils.resolveUrlToPage;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASSource = das.DASSource;\n    var DASSegment = das.DASSegment;\n    var DASFeature = das.DASFeature;\n    var DASSequence = das.DASSequence;\n    var DASLink = das.DASLink;\n\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n    var BlobFetchable = bin.BlobFetchable;\n\n    var twoBit = require('./twoBit');\n    var makeTwoBit = twoBit.makeTwoBit;\n\n    var bbi = require('./bigwig');\n    var makeBwg = bbi.makeBwg;\n\n    var bam = require('./bam');\n    var makeBam = bam.makeBam;\n    var BamFlags = bam.BamFlags;\n\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n\n    var parseCigar = require('./cigar').parseCigar;\n\n    var OverlayFeatureSource = require('./overlay').OverlayFeatureSource;\n\n    var JBrowseStore = require('./jbjson').JBrowseStore;\n\n    var Chainset = require('./chainset').Chainset;\n\n    var style = require('./style');\n    var StyleFilterSet = style.StyleFilterSet;\n\n    var EncodeFetchable = require('./encode').EncodeFetchable;\n}\n\nvar __dalliance_sourceAdapterFactories = {};\n\nfunction dalliance_registerSourceAdapterFactory(type, factory) {\n    __dalliance_sourceAdapterFactories[type] = factory;\n};\n\n\nvar __dalliance_parserFactories = {};\n\nfunction dalliance_registerParserFactory(type, factory) {\n    __dalliance_parserFactories[type] = factory;\n};\n\nfunction dalliance_makeParser(type) {\n    if (__dalliance_parserFactories[type]) {\n        return __dalliance_parserFactories[type](type);\n    }\n};\n\n\nDasTier.prototype.initSources = function() {\n    var thisTier = this;\n\n    var sources = this.browser.createSources(this.dasSource);\n    this.featureSource = sources.features || new DummyFeatureSource();\n    this.sequenceSource = sources.sequence;\n\n    if (this.featureSource && this.featureSource.addChangeListener) {\n        this.featureSource.addChangeListener(function() {\n            thisTier.browser.refreshTier(thisTier);\n        });\n    }\n}\n\nBrowser.prototype.createSources = function(config) {\n    var sources = this.sourceCache.get(config);\n    if (sources)\n        return sources;\n\n    var fs, ss;\n\n    if (config.tier_type == 'sequence' || config.twoBitURI || config.twoBitBlob) {\n        if (config.twoBitURI || config.twoBitBlob) {\n            ss = new TwoBitSequenceSource(config);\n        } else if (config.ensemblURI) {\n            ss = new EnsemblSequenceSource(config);\n        } else {\n            ss = new DASSequenceSource(config);\n        }\n    } else if (config.tier_type && __dalliance_sourceAdapterFactories[config.tier_type]) {\n        var saf = __dalliance_sourceAdapterFactories[config.tier_type];\n        var ns = saf(config);\n        fs = ns.features;\n        ss = ns.sequence;\n    } else if (config.bwgURI || config.bwgBlob) {\n        var worker = this.getWorker();\n        if (worker)\n            fs = new RemoteBWGFeatureSource(config, worker, this);\n        else\n            fs = new BWGFeatureSource(config);\n    } else if (config.bamURI || config.bamBlob) {\n        var worker = this.getWorker();\n        if (worker)\n            fs = new RemoteBAMFeatureSource(config, worker, this);\n        else\n            fs = new BAMFeatureSource(config);\n    } else if (config.jbURI) {\n        fs = new JBrowseFeatureSource(config);\n    } else if (config.uri || config.features_uri) {\n        fs = new DASFeatureSource(config);\n    }\n\n    if (config.overlay) {\n        var sources = [];\n        if (fs)\n            sources.push(new CachingFeatureSource(fs));\n\n        for (var oi = 0; oi < config.overlay.length; ++oi) {\n            var cs = this.createSources(config.overlay[oi]);\n            if (cs && cs.features)\n                sources.push(cs.features);\n        }\n        fs = new OverlayFeatureSource(sources, config);\n    }\n\n    if (config.sequenceAliases) {\n        fs = new MappedFeatureSource(fs, new Chainset({type: 'alias', sequenceAliases: config.sequenceAliases}));\n    }\n\n    if (config.mapping) {\n        fs = new MappedFeatureSource(fs, this.chains[config.mapping]);\n    }\n\n    if (config.name && fs && !fs.name) {\n        fs.name = config.name;\n    }\n\n    if (fs != null) {\n        fs = new CachingFeatureSource(fs);\n    }\n\n    if (fs != null || ss != null) {\n        sources = {\n            features: fs,\n            sequence: ss\n        };\n        this.sourceCache.put(config, sources);\n    }\n\n    return sources;\n}\n\nDasTier.prototype.fetchStylesheet = function(cb) {\n    var ssSource;\n    // Somewhat ugly workaround for the special case of DAS sources...\n    if (this.dasSource.stylesheet_uri || (\n        !this.dasSource.tier_type &&\n        !this.dasSource.bwgURI &&\n        !this.dasSource.bwgBlob &&\n        !this.dasSource.bamURI &&\n        !this.dasSource.bamBlob &&\n        !this.dasSource.twoBitURI &&\n        !this.dasSource.twoBitBlob &&\n        !this.dasSource.jbURI &&\n        !this.dasSource.overlay))\n    {\n        ssSource = new DASFeatureSource(this.dasSource);\n    } else {\n        ssSource = this.getSource();\n    }\n    ssSource.getStyleSheet(cb);\n}\n\nvar __cfs_id_seed = 0;\n\nfunction CachingFeatureSource(source) {\n    var thisB = this;\n\n    this.source = source;\n    this.cfsid = 'cfs' + (++__cfs_id_seed);\n    if (source.name) {\n        this.name = source.name;\n    }\n    if (source.addChangeListener) {\n        source.addChangeListener(function() {\n            thisB.cfsid = 'cfs' + (++__cfs_id_seed);\n        });\n    }\n}\n\nCachingFeatureSource.prototype.addReadinessListener = function(listener) {\n    if (this.source.addReadinessListener)\n        return this.source.addReadinessListener(listener);\n    else\n        listener(null);\n}\n\nCachingFeatureSource.prototype.removeReadinessListener = function(listener) {\n    if (this.source.removeReadinessListener)\n        return this.source.removeReadinessListener(listener);\n}\n\nCachingFeatureSource.prototype.search = function(query, callback) {\n    if (this.source.search)\n        return this.source.search(query, callback);\n}\n\nCachingFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.source.getDefaultFIPs)\n        return this.source.getDefaultFIPs(callback); \n}\n\nCachingFeatureSource.prototype.getStyleSheet = function(callback) {\n    this.source.getStyleSheet(callback);\n}\n\nCachingFeatureSource.prototype.getScales = function() {\n    return this.source.getScales();\n}\n\nCachingFeatureSource.prototype.addActivityListener = function(l) {\n    if (this.source.addActivityListener) {\n        this.source.addActivityListener(l);\n    }\n}\n\nCachingFeatureSource.prototype.removeActivityListener = function(l) {\n    if (this.source.removeActivityListener) {\n        this.source.removeActivityListener(l);\n    }\n}\n\nCachingFeatureSource.prototype.addChangeListener = function(l) {\n    if (this.source.addChangeListener)\n        this.source.addChangeListener(l);\n}\n\nCachingFeatureSource.prototype.removeChangeListener = function(l) {\n    if (this.source.removeChangeListener)\n        this.source.removeChangeListener(l);\n}\n\nCachingFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {\n    this.source.findNextFeature(chr, pos, dir, callback);\n}\n\nCachingFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {\n    this.source.quantFindNextFeature(chr, pos, dir, threshold, callback);\n}\n\nCachingFeatureSource.prototype.capabilities = function() {\n    if (this.source.capabilities) {\n        return this.source.capabilities();\n    } else {\n        return {};\n    }\n}\n\nCachingFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {\n    if (!pool) {\n        throw Error('Fetch pool is null');\n    }\n\n    var self = this;\n    var cacheKey = this.cfsid;\n\n    var awaitedFeatures = pool.awaitedFeatures[cacheKey];\n    if (awaitedFeatures && awaitedFeatures.started) {\n        if (awaitedFeatures.styleFilters.doesNotContain(styleFilters)) {\n            // console.log('Fetch already started with wrong parameters, skipping cache.');\n            self.source.fetch(chr, min, max, scale, types, pool, callback, styleFilters);\n            return;\n        }\n    } else if (awaitedFeatures) {\n        awaitedFeatures.styleFilters.addAll(styleFilters);\n    } else {\n        awaitedFeatures = new Awaited();\n        awaitedFeatures.styleFilters = styleFilters;\n        pool.awaitedFeatures[cacheKey] = awaitedFeatures;\n\n        pool.requestsIssued.then(function() {\n            awaitedFeatures.started = true;\n            self.source.fetch(\n                chr, \n                min, \n                max, \n                scale, \n                awaitedFeatures.styleFilters.typeList(), \n                pool, \n                function(status, features, scale, coverage) {\n                    if (!awaitedFeatures.res)\n                        awaitedFeatures.provide({status: status, features: features, scale: scale, coverage: coverage});\n                }, \n                awaitedFeatures.styleFilters);\n        }).catch(function(err) {\n            console.log(err);\n        });\n    } \n\n    awaitedFeatures.await(function(af) {\n        callback(af.status, af.features, af.scale, af.coverage);\n    });\n}\n    \nfunction FeatureSourceBase() {\n    this.busy = 0;\n    this.activityListeners = [];\n    this.readinessListeners = [];\n    this.readiness = null;\n}\n\nFeatureSourceBase.prototype.addReadinessListener = function(listener) {\n    this.readinessListeners.push(listener);\n    listener(this.readiness);\n}\n\nFeatureSourceBase.prototype.removeReadinessListener = function(listener) {\n    var idx = arrayIndexOf(this.readinessListeners, listener);\n    if (idx >= 0) {\n        this.readinessListeners.splice(idx, 1);\n    }\n}\n\nFeatureSourceBase.prototype.notifyReadiness = function() {\n    for (var li = 0; li < this.readinessListeners.length; ++li) {\n        try {\n            this.readinessListeners[li](this.readiness);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nFeatureSourceBase.prototype.addActivityListener = function(listener) {\n    this.activityListeners.push(listener);\n}\n\nFeatureSourceBase.prototype.removeActivityListener = function(listener) {\n    var idx = arrayIndexOf(this.activityListeners, listener);\n    if (idx >= 0) {\n        this.activityListeners.splice(idx, 1);\n    }\n}\n\nFeatureSourceBase.prototype.notifyActivity = function() {\n    for (var li = 0; li < this.activityListeners.length; ++li) {\n        try {\n            this.activityListeners[li](this.busy);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nFeatureSourceBase.prototype.getScales = function() {\n    return null;\n}\n\nFeatureSourceBase.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {\n    return cnt(null, [], 1000000000);\n}\n\nFeatureSourceBase.prototype.getStyleSheet = function(callback) {\n    var stylesheet = new DASStylesheet();\n    var defStyle = new DASStyle();\n    defStyle.glyph = 'BOX';\n    defStyle.BGCOLOR = 'blue';\n    defStyle.FGCOLOR = 'black';\n    stylesheet.pushStyle({type: 'default'}, null, defStyle);\n    return callback(stylesheet);\n}\n\n\n\nfunction DASFeatureSource(dasSource) {\n    this.dasSource = new DASSource(dasSource);\n    this.busy = 0;\n    this.activityListeners = [];\n}\n\nDASFeatureSource.prototype.addActivityListener = function(listener) {\n    this.activityListeners.push(listener);\n}\n\nDASFeatureSource.prototype.removeActivityListener = function(listener) {\n    var idx = arrayIndexOf(this.activityListeners, listener);\n    if (idx >= 0)\n        this.activityListeners.splice(idx, 1);\n}\n\n\nDASFeatureSource.prototype.notifyActivity = function() {\n    for (var li = 0; li < this.activityListeners.length; ++li) {\n        try {\n            this.activityListeners[li](this.busy);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nDASFeatureSource.prototype.getStyleSheet = function(callback) {\n    this.dasSource.stylesheet(function(stylesheet) {\n\tcallback(stylesheet);\n    }, function() {\n\tcallback(null, \"Couldn't fetch DAS stylesheet\");\n    });\n}\n\nDASFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    if (types && types.length == 0) {\n        callback(null, [], scale);\n        return;\n    }\n\n    if (!this.dasSource.uri && !this.dasSource.features_uri) {\n        // FIXME should this be making an error callback???\n        return;\n    }\n\n    if (this.dasSource.dasStaticFeatures && this.cachedStaticFeatures) {\n        return callback(null, this.cachedStaticFeatures, this.cachedStaticScale);\n    }\n\n    var tryMaxBins = (this.dasSource.maxbins !== false);\n    var fops = {\n        type: types\n    };\n    if (tryMaxBins) {\n        fops.maxbins = 1 + (((max - min) / scale) | 0);\n    }\n    \n    var thisB = this;\n    thisB.busy++;\n    thisB.notifyActivity();\n\n    this.dasSource.features(\n        new DASSegment(chr, min, max),\n        fops,\n        function(features, status) {\n            \n            thisB.busy--;\n            thisB.notifyActivity();\n\n            var retScale = scale;\n            if (!tryMaxBins) {\n                retScale = 0.1;\n            }\n            if (!status && thisB.dasSource.dasStaticFeatures) {\n                thisB.cachedStaticFeatures = features;\n                thisB.cachedStaticScale = retScale;\n            }\n            callback(status, features, retScale);\n        }\n    );\n}\n\nDASFeatureSource.prototype.findNextFeature = this.sourceFindNextFeature = function(chr, pos, dir, callback) {\n    if (this.dasSource.capabilities && arrayIndexOf(this.dasSource.capabilities, 'das1:adjacent-feature') >= 0) {\n        var thisB = this;\n        if (this.dasAdjLock) {\n            return console.log('Already looking for a next feature, be patient!');\n        }\n        this.dasAdjLock = true;\n        var fops = {\n            adjacent: chr + ':' + (pos|0) + ':' + (dir > 0 ? 'F' : 'B')\n        }\n        var types = thisTier.getDesiredTypes(thisTier.browser.scale);\n        if (types) {\n            fops.types = types;\n        }\n        thisTier.dasSource.features(null, fops, function(res) {\n            thisB.dasAdjLock = false;\n            if (res.length > 0 && res[0] != null) {\n                callback(res[0]);\n            }\n        });\n    }\n};\n\nfunction DASSequenceSource(dasSource) {\n    this.dasSource = new DASSource(dasSource);\n    this.awaitedEntryPoints = new Awaited();\n\n    var thisB = this;\n    this.dasSource.entryPoints(\n        function(ep) {\n            thisB.awaitedEntryPoints.provide(ep);\n        });\n}\n\n\nDASSequenceSource.prototype.fetch = function(chr, min, max, pool, callback) {\n    this.dasSource.sequence(\n        new DASSegment(chr, min, max),\n        function(seqs) {\n            if (seqs.length == 1) {\n                return callback(null, seqs[0]);\n            } else {\n                return callback(\"Didn't get sequence\");\n            }\n        }\n    );\n}\n\nDASSequenceSource.prototype.getSeqInfo = function(chr, cnt) {\n    this.awaitedEntryPoints.await(function(ep) {\n        for (var epi = 0; epi < ep.length; ++epi) {\n            if (ep[epi].name == chr) {\n                return cnt({length: ep[epi].end});\n            }\n        }\n        return cnt();\n    });\n}\n    \n\nfunction TwoBitSequenceSource(source) {\n    var thisB = this;\n    this.source = source;\n    this.twoBit = new Awaited();\n    var data;\n    if (source.twoBitURI) {\n        data = new URLFetchable(source.twoBitURI, {credentials: source.credentials, resolver: source.resolver});\n    } else if (source.twoBitBlob) {\n        data = new BlobFetchable(source.twoBitBlob);\n    } else {\n        throw Error(\"No twoBitURI or twoBitBlob parameter\");\n    }\n\n    makeTwoBit(data, function(tb, error) {\n        if (error) {\n            console.log(error);\n        } else {\n            thisB.twoBit.provide(tb);\n        }\n    });\n}\n\nTwoBitSequenceSource.prototype.fetch = function(chr, min, max, pool, callback) {\n        this.twoBit.await(function(tb) {\n            tb.fetch(chr, min, max,\n                     function(seq, err) {\n                         if (err) {\n                             return callback(err, null);\n                         } else {\n                             var sequence = new DASSequence(chr, min, max, 'DNA', seq);\n                             return callback(null, sequence);\n                         }\n                     })\n        });\n}\n\nTwoBitSequenceSource.prototype.getSeqInfo = function(chr, cnt) {\n    this.twoBit.await(function(tb) {\n        var seq = tb.getSeq(chr);\n        if (seq) {\n            tb.getSeq(chr).length(function(l) {\n                cnt({length: l});\n            });\n        } else {\n            cnt();\n        }\n    });\n}\n\nfunction EnsemblSequenceSource(source) {\n  this.source = source;\n  // http://data.gramene.org/ensembl/info/assembly/triticum_aestivum/2B?content-type=application/json\n  // http://data.gramene.org/ensembl/sequence/region/triticum_aestivum/2B:8001..18000:1?content-type=application/json\n}\n\nEnsemblSequenceSource.prototype.fetch = function(chr, min, max, pool, callback) {\n  var url = this.source.ensemblURI + '/sequence/region/' + this.source.species + '/'\n    + chr + ':' + min + '..' + max + ':1?content-type=application/json';\n  var req = new XMLHttpRequest();\n  req.onreadystatechange = function() {\n  \tif (req.readyState == 4) {\n\t    if (req.status >= 300) {\n        var err = 'Error code ' + req.status;\n        try {\n          var jr = JSON.parse(req.response);\n          if (jr.error) {\n            err = jr.error;\n          }\n        } catch (ex) {};\n\n\t\t    callback(err, null);\n\t    } else {\n    \t\tvar jr = JSON.parse(req.response);\n        var sequence = new DASSequence(chr, min, max, 'DNA', jr.seq);\n        return callback(null, sequence);\n      }\n    }\n  }\n  req.open('GET', url, true);\n  req.responseType = 'text';\n  req.send('');\n}\n\nEnsemblSequenceSource.prototype.getSeqInfo = function(chr, cnt) {\n  var url = this.source.ensemblURI + '/info/assembly/' + this.source.species + '/' + chr + '?content-type=application/json';\n  var req = new XMLHttpRequest();\n  req.onreadystatechange = function() {\n\t  if (req.readyState == 4) {\n      if (req.status >= 300) {\n\t      cnt();\n      } else {\n  \t\t  var jr = JSON.parse(req.response);\n        cnt(jr);\n      }\n    }\n  }\n  req.open('GET', url, true);\n  req.responseType = 'text';\n  req.send('');\n}\n\nDASFeatureSource.prototype.getScales = function() {\n    return [];\n}\n\nvar bwg_preflights = {};\n\nfunction BWGFeatureSource(bwgSource) {\n    FeatureSourceBase.call(this);\n\n    var thisB = this;\n    this.readiness = 'Connecting';\n    this.bwgSource = this.opts = bwgSource;    \n    thisB.bwgHolder = new Awaited();\n\n    if (this.opts.preflight) {\n        var pfs = bwg_preflights[this.opts.preflight];\n        if (!pfs) {\n            pfs = new Awaited();\n            bwg_preflights[this.opts.preflight] = pfs;\n\n            var req = new XMLHttpRequest();\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200) {\n                        pfs.provide('success');\n                    } else {\n                        pfs.provide('failure');\n                    }\n                }\n            };\n            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true);    // Instead, ensure we always preflight a unique URI.\n            if (this.opts.credentials) {\n                req.withCredentials = true;\n            }\n            req.send('');\n        }\n        pfs.await(function(status) {\n            if (status === 'success') {\n                thisB.init();\n            }\n        });\n    } else {\n        thisB.init();\n    }\n}\n\nBWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nBWGFeatureSource.prototype.init = function() {\n    var thisB = this;\n    var arg;\n\n    var uri = this.bwgSource.uri || this.bwgSource.bwgURI;\n    if (uri) {\n        if (this.bwgSource.transport === 'encode') {\n            arg = new EncodeFetchable(uri, {credentials: this.opts.credentials});\n        } else {\n            arg = new URLFetchable(uri, {credentials: this.opts.credentials, resolver: this.opts.resolver});\n        }\n    } else {\n        arg = new BlobFetchable(this.bwgSource.bwgBlob);\n    }\n\n    makeBwg(arg, function(bwg, err) {\n        if (err) {\n            thisB.error = err;\n            thisB.readiness = null;\n            thisB.notifyReadiness();\n            thisB.bwgHolder.provide(null);\n        } else {\n            thisB.bwgHolder.provide(bwg);\n            thisB.readiness = null;\n            thisB.notifyReadiness();\n            if (bwg.type == 'bigbed') {\n                bwg.getExtraIndices(function(ei) {\n                    thisB.extraIndices = ei;\n                });\n            }\n        }\n    });\n}\n\nBWGFeatureSource.prototype.capabilities = function() {\n    var caps = {leap: true};\n    if (this.bwgHolder.res && this.bwgHolder.res.type == 'bigwig')\n        caps.quantLeap = true;\n    if (this.extraIndices && this.extraIndices.length > 0) {\n        caps.search = [];\n        for (var eii = 0; eii < this.extraIndices.length; ++eii) {\n            caps.search.push(this.extraIndices[eii].field);\n        }\n    }\n    return caps;\n}\n\nBWGFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var thisB = this;\n    this.bwgHolder.await(function(bwg) {\n        if (bwg == null) {\n            return callback(thisB.error || \"Can't access binary file\", null, null);\n        }\n\n        var data;\n        var wantDensity = !types || types.length == 0 || arrayIndexOf(types, 'density') >= 0;\n        if (thisB.opts.clientBin) {\n            wantDensity = false;\n        }\n        if (bwg.type == 'bigwig' || wantDensity || (typeof thisB.opts.forceReduction !== 'undefined')) {\n            var zoom = -1;\n            for (var z = 0; z < bwg.zoomLevels.length; ++z) {\n                if (bwg.zoomLevels[z].reduction <= scale) {\n                    zoom = z;\n                } else {\n                    break;\n                }\n            }\n            if (typeof thisB.opts.forceReduction !== 'undefined') {\n                zoom = thisB.opts.forceReduction;\n            }\n\n            if (zoom < 0) {\n                data = bwg.getUnzoomedView();\n            } else {\n                data = bwg.getZoomedView(zoom);\n            }\n        } else {\n            data = bwg.getUnzoomedView();\n        }\n        \n        thisB.busy++;\n        thisB.notifyActivity();\n        data.readWigData(chr, min, max, function(features) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            var fs = 1000000000;\n            if (bwg.type === 'bigwig') {\n                var is = (max - min) / features.length / 2;\n                if (is < fs) {\n                    fs = is;\n                }\n            }\n            if (thisB.opts.link) {\n                for (var fi = 0; fi < features.length; ++fi) {\n                    var f = features[fi];\n                    if (f.label) {\n                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\\$\\$/, f.label))];\n                    }\n                }\n            }\n            callback(null, features, fs);\n        });\n    });\n}\n\nBWGFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {\n    // var beforeQFNF = Date.now()|0;\n    var thisB = this;\n    thisB.busy++;\n    thisB.notifyActivity();\n    this.bwgHolder.res.thresholdSearch(chr, pos, dir, threshold, function(a, b) {\n        thisB.busy--;\n        thisB.notifyActivity();\n        // var afterQFNF = Date.now()|0;\n        // console.log('QFNF took ' + (afterQFNF - beforeQFNF) + 'ms');\n        return callback(a, b);\n    });\n}\n\nBWGFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {\n    var thisB = this;\n    thisB.busy++;\n    thisB.notifyActivity();\n    this.bwgHolder.res.getUnzoomedView().getFirstAdjacent(chr, pos, dir, function(res) {\n        thisB.busy--;\n        thisB.notifyActivity();\n        if (res.length > 0 && res[0] != null) {\n            callback(res[0]);\n        }\n    });\n}\n\nBWGFeatureSource.prototype.getScales = function() {\n    var bwg = this.bwgHolder.res;\n    if (bwg /* && bwg.type == 'bigwig' */) {\n        var scales = [1];  // Can we be smarter about inferring baseline scale?\n        for (var z = 0; z < bwg.zoomLevels.length; ++z) {\n            scales.push(bwg.zoomLevels[z].reduction);\n        }\n        return scales;\n    } else {\n        return null;\n    }\n}\n\nBWGFeatureSource.prototype.search = function(query, callback) {\n    if (!this.extraIndices || this.extraIndices.length == 0) {\n        return callback(null, 'No indices available');\n    }\n\n    var index = this.extraIndices[0];\n    return index.lookup(query, callback);\n}\n\nBWGFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.opts.noExtraFeatureInfo)\n        return true;\n\n    this.bwgHolder.await(function(bwg) {\n        if (!bwg) return;\n\n        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {\n            var fip = function(feature, featureInfo) {\n                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {\n                    if (featureInfo.hit[hi].isSuperGroup)\n                        return;\n                }\n                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {\n                    var f = bwg.schema.fields[fi];\n                    featureInfo.add(f.comment, feature[f.name]);\n                }\n            };\n\n            callback(fip);\n        } else {\n            // No need to do anything.\n        }\n    });\n}\n\nBWGFeatureSource.prototype.getStyleSheet = function(callback) {\n    var thisB = this;\n\n    this.bwgHolder.await(function(bwg) {\n        if (!bwg) {\n            return callback(null, 'bbi error');\n        }\n\n    \tvar stylesheet = new DASStylesheet();\n        if (bwg.type == 'bigbed') {\n            var wigStyle = new DASStyle();\n            wigStyle.glyph = 'BOX';\n            wigStyle.FGCOLOR = 'black';\n            wigStyle.BGCOLOR = 'blue'\n            wigStyle.HEIGHT = 8;\n            wigStyle.BUMP = true;\n            wigStyle.LABEL = true;\n            wigStyle.ZINDEX = 20;\n            stylesheet.pushStyle({type: 'bigbed'}, null, wigStyle);\n\t    \n            wigStyle.glyph = 'BOX';\n            wigStyle.FGCOLOR = 'black';\n            wigStyle.BGCOLOR = 'red'\n            wigStyle.HEIGHT = 10;\n            wigStyle.BUMP = true;\n            wigStyle.ZINDEX = 20;\n            stylesheet.pushStyle({type: 'translation'}, null, wigStyle);\n                    \n            var tsStyle = new DASStyle();\n            tsStyle.glyph = 'BOX';\n            tsStyle.FGCOLOR = 'black';\n            tsStyle.BGCOLOR = 'white';\n            tsStyle.HEIGHT = 10;\n            tsStyle.ZINDEX = 10;\n            tsStyle.BUMP = true;\n            tsStyle.LABEL = true;\n            stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n\n            var densStyle = new DASStyle();\n            densStyle.glyph = 'HISTOGRAM';\n            densStyle.COLOR1 = 'white';\n            densStyle.COLOR2 = 'black';\n            densStyle.HEIGHT=30;\n            stylesheet.pushStyle({type: 'density'}, null, densStyle);\n        } else {\n            var wigStyle = new DASStyle();\n            wigStyle.glyph = 'HISTOGRAM';\n            wigStyle.COLOR1 = 'white';\n            wigStyle.COLOR2 = 'black';\n            wigStyle.HEIGHT=30;\n            stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n        }\n\n        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {\n            stylesheet.geneHint = true;\n        }\n\n    \treturn callback(stylesheet);\n    });\n}\n\nfunction RemoteBWGFeatureSource(bwgSource, worker, browser) {\n    FeatureSourceBase.call(this);\n\n    var thisB = this;\n    this.worker = worker;\n    this.readiness = 'Connecting';\n    this.bwgSource = this.opts = bwgSource;\n    this.keyHolder = new Awaited();\n\n    if (bwgSource.resolver) {\n        this.resolverKey = browser.registerResolver(bwgSource.resolver);\n    }\n\n    this.init();\n}\n\nRemoteBWGFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nRemoteBWGFeatureSource.prototype.init = function() {\n    var thisB = this;\n    var uri = this.uri || this.bwgSource.uri || this.bwgSource.bwgURI;\n    var blob = this.bwgSource.blob || this.bwgSource.bwgBlob;\n\n    var cnt = function(key, err) {\n        thisB.readiness = null;\n        thisB.notifyReadiness();\n\n        if (key) {\n            thisB.worker.postCommand({command: 'meta', connection: key}, function(meta, err) {\n                if (err) {\n                    thisB.error = err;\n                    thisB.keyHolder.provide(null);\n                } else {\n                    thisB.meta = meta;\n                    thisB.keyHolder.provide(key);\n                }\n            });\n        } else {\n            thisB.error = err;\n            thisB.keyHolder.provide(null);\n        }\n    };\n\n    if (blob) {\n        this.worker.postCommand({command: 'connectBBI', blob: blob}, cnt);\n    } else {\n        this.worker.postCommand({\n            command: 'connectBBI', \n            uri: resolveUrlToPage(uri), \n            resolver: this.resolverKey,\n            transport: this.bwgSource.transport,\n            credentials: this.bwgSource.credentials}, \n          cnt); \n    }\n}\n\nRemoteBWGFeatureSource.prototype.capabilities = function() {\n    var caps = {leap: true};\n\n    if (this.meta && this.meta.type == 'bigwig')\n        caps.quantLeap = true;\n    if (this.meta && this.meta.extraIndices && this.meta.extraIndices.length > 0) {\n        caps.search = [];\n        for (var eii = 0; eii < this.meta.extraIndices.length; ++eii) {\n            caps.search.push(this.meta.extraIndices[eii].field);\n        }\n    }\n    return caps;\n}\n\nRemoteBWGFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var thisB = this;\n\n    thisB.busy++;\n    thisB.notifyActivity();\n\n    this.keyHolder.await(function(key) {\n        if (!key) {\n            thisB.busy--;\n            thisB.notifyActivity();\n            return callback(thisB.error || \"Can't access binary file\", null, null);\n        }\n\n        var zoom = -1;\n        var wantDensity = !types || types.length == 0 || arrayIndexOf(types, 'density') >= 0;\n        if (thisB.opts.clientBin) {\n            wantDensity = false;\n        }\n        if (thisB.meta.type == 'bigwig' || wantDensity || (typeof thisB.opts.forceReduction !== 'undefined')) {\n            for (var z = 1; z < thisB.meta.zoomLevels.length; ++z) {\n                if (thisB.meta.zoomLevels[z] <= scale) {\n                    zoom = z - 1; // Scales returned in metadata start at 1, unlike \"real\" zoom levels.\n                } else {\n                    break;\n                }\n            }\n            if (typeof thisB.opts.forceReduction !== 'undefined') {\n                zoom = thisB.opts.forceReduction;\n            }\n        }\n        \n        thisB.worker.postCommand({command: 'fetch', connection: key, chr: chr, min: min, max: max, zoom: zoom}, function(features, error) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            var fs = 1000000000;\n            if (thisB.meta.type === 'bigwig') {\n                var is = (max - min) / features.length / 2;\n                if (is < fs) {\n                    fs = is;\n                }\n            } \n            if (thisB.opts.link) {\n                for (var fi = 0; fi < features.length; ++fi) {\n                    var f = features[fi];\n                    if (f.label) {\n                        f.links = [new DASLink('Link', thisB.opts.link.replace(/\\$\\$/, f.label))];\n                    }\n                }\n            } \n            callback(error, features, fs);\n        });\n    });\n}\n\n\nRemoteBWGFeatureSource.prototype.quantFindNextFeature = function(chr, pos, dir, threshold, callback) {\n    var thisB = this;\n    this.busy++;\n    this.notifyActivity();\n    this.worker.postCommand({command: 'quantLeap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir, threshold: threshold, under: false}, function(result, err) {\n        console.log(result, err);\n        thisB.busy--;\n        thisB.notifyActivity();\n        return callback(result, err);\n    });\n}\n\nRemoteBWGFeatureSource.prototype.findNextFeature = function(chr, pos, dir, callback) {\n    var thisB = this;\n    this.busy++;\n    this.notifyActivity();\n    this.worker.postCommand({command: 'leap', connection: this.keyHolder.res, chr: chr, pos: pos, dir: dir}, function(result, err) {\n        thisB.busy--;\n        thisB.notifyActivity();\n        if (result.length > 0 && result[0] != null) {\n            callback(result[0]);\n        }\n    });\n}\n\nRemoteBWGFeatureSource.prototype.getScales = function() {\n    var meta = this.meta;\n    if (meta) {\n        return meta.zoomLevels;\n    } else {\n        return null;\n    }\n}\n\nRemoteBWGFeatureSource.prototype.search = function(query, callback) {\n    if (!this.meta.extraIndices || this.meta.extraIndices.length == 0) {\n        return callback(null, 'No indices available');\n    }\n\n    var thisB = this;\n    this.busy++;\n    this.notifyActivity();\n    var index = this.meta.extraIndices[0];\n    this.worker.postCommand({command: 'search', connection: this.keyHolder.res, query: query, index: index}, function(result, err) {\n        thisB.busy--;\n        thisB.notifyActivity();\n\n        callback(result, err);\n    });\n}\n\nRemoteBWGFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.opts.noExtraFeatureInfo)\n        return true;\n\n    var thisB = this;\n    this.keyHolder.await(function(key) {\n        var bwg = thisB.meta;\n        if (!bwg) return;\n\n        if (bwg.schema && bwg.definedFieldCount < bwg.schema.fields.length) {\n            var fip = function(feature, featureInfo) {\n                for (var hi = 0; hi < featureInfo.hit.length; ++hi) {\n                    if (featureInfo.hit[hi].isSuperGroup)\n                        return;\n                }\n                for (var fi = bwg.definedFieldCount; fi < bwg.schema.fields.length; ++fi) {\n                    var f = bwg.schema.fields[fi];\n                    featureInfo.add(f.comment, feature[f.name]);\n                }\n            };\n\n            callback(fip);\n        } else {\n            // No need to do anything.\n        }\n    });\n} \n\nRemoteBWGFeatureSource.prototype.getStyleSheet = function(callback) {\n    var thisB = this;\n\n    this.keyHolder.await(function(key) {\n        var bwg = thisB.meta;\n        if (!bwg) {\n            return callback(null, 'bbi error');\n        } \n\n        var stylesheet = new DASStylesheet();\n        if (bwg.type == 'bigbed') {\n            var wigStyle = new DASStyle();\n            wigStyle.glyph = 'BOX';\n            wigStyle.FGCOLOR = 'black';\n            wigStyle.BGCOLOR = 'blue'\n            wigStyle.HEIGHT = 8;\n            wigStyle.BUMP = true;\n            wigStyle.LABEL = true;\n            wigStyle.ZINDEX = 20;\n            stylesheet.pushStyle({type: 'bigbed'}, null, wigStyle);\n        \n            wigStyle.glyph = 'BOX';\n            wigStyle.FGCOLOR = 'black';\n            wigStyle.BGCOLOR = 'red'\n            wigStyle.HEIGHT = 10;\n            wigStyle.BUMP = true;\n            wigStyle.ZINDEX = 20;\n            stylesheet.pushStyle({type: 'translation'}, null, wigStyle);\n                    \n            var tsStyle = new DASStyle();\n            tsStyle.glyph = 'BOX';\n            tsStyle.FGCOLOR = 'black';\n            tsStyle.BGCOLOR = 'white';\n            tsStyle.HEIGHT = 10;\n            tsStyle.ZINDEX = 10;\n            tsStyle.BUMP = true;\n            tsStyle.LABEL = true;\n            stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n\n            var densStyle = new DASStyle();\n            densStyle.glyph = 'HISTOGRAM';\n            densStyle.COLOR1 = 'white';\n            densStyle.COLOR2 = 'black';\n            densStyle.HEIGHT=30;\n            stylesheet.pushStyle({type: 'density'}, null, densStyle);\n        } else {\n            var wigStyle = new DASStyle();\n            wigStyle.glyph = 'HISTOGRAM';\n            wigStyle.COLOR1 = 'white';\n            wigStyle.COLOR2 = 'black';\n            wigStyle.HEIGHT=30;\n            stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n        }\n\n\n        if (bwg.definedFieldCount == 12 && bwg.fieldCount >= 14) {\n            stylesheet.geneHint = true;\n        } \n\n        return callback(stylesheet);\n    });\n}\n\nfunction bamRecordToFeature(r, group) {\n    if (r.flag & BamFlags.SEGMENT_UNMAPPED)\n        return; \n    \n    var len;\n    if (r.seq)\n        len = r.seq.length;\n    else \n        len = r.seqLength;\n    \n    if (r.cigar) {\n        len = 0;\n        var ops = parseCigar(r.cigar);\n        for (var ci = 0; ci < ops.length; ++ci) {\n            var co = ops[ci];\n            if (co.op == 'M' || co.op == 'D')\n                len += co.cnt;\n        }\n    }\n\n    var f = new DASFeature();\n    f.min = r.pos + 1;\n    f.max = r.pos + len;\n    f.segment = r.segment;\n    f.type = 'bam';\n    f.id = r.readName;\n    f.notes = [/* 'Sequence=' + r.seq, 'CIGAR=' + r.cigar, */ 'MQ=' + r.mq];\n    f.cigar = r.cigar;\n    f.seq = r.seq;\n    f.quals = r.quals;\n    f.orientation = (r.flag & BamFlags.REVERSE_COMPLEMENT) ? '-' : '+';\n    f.bamRecord = r;\n\n    if (group && (r.flag & BamFlags.MULTIPLE_SEGMENTS)) {\n        f.groups = [{id: r.readName, \n                     type: 'readpair'}];\n    }\n\n    return f;\n}\n\nfunction BAMFeatureSource(bamSource) {\n    FeatureSourceBase.call(this);\n\n    var thisB = this;\n    this.bamSource = bamSource;\n    this.opts = {credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup};\n    this.bamHolder = new Awaited();\n    \n    if (this.opts.preflight) {\n        var pfs = bwg_preflights[this.opts.preflight];\n        if (!pfs) {\n            pfs = new Awaited();\n            bwg_preflights[this.opts.preflight] = pfs;\n\n            var req = new XMLHttpRequest();\n            req.onreadystatechange = function() {\n                if (req.readyState == 4) {\n                    if (req.status == 200) {\n                        pfs.provide('success');\n                    } else {\n                        pfs.provide('failure');\n                    }\n                }\n            };\n            // req.setRequestHeader('cache-control', 'no-cache');    /* Doesn't work, not an allowed request header in CORS */\n            req.open('get', this.opts.preflight + '?' + hex_sha1('salt' + Date.now()), true);    // Instead, ensure we always preflight a unique URI.\n            if (this.opts.credentials) {\n                req.withCredentials = 'true';\n            }\n            req.send('');\n        }\n        pfs.await(function(status) {\n            if (status === 'success') {\n                thisB.init();\n            }\n        });\n    } else {\n        thisB.init();\n    }\n}\n\nBAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nBAMFeatureSource.prototype.init = function() {\n    var thisB = this;\n    var bamF, baiF;\n    if (this.bamSource.bamBlob) {\n        bamF = new BlobFetchable(this.bamSource.bamBlob);\n        baiF = new BlobFetchable(this.bamSource.baiBlob);\n    } else {\n        bamF = new URLFetchable(this.bamSource.bamURI, {credentials: this.opts.credentials, resolver: this.opts.resolver});\n        baiF = new URLFetchable(this.bamSource.baiURI || (this.bamSource.bamURI + '.bai'), \n                                {credentials: this.opts.credentials, resolver: this.opts.resolver});\n    }\n    makeBam(bamF, baiF, null, function(bam, err) {\n        thisB.readiness = null;\n        thisB.notifyReadiness();\n\n        if (bam) {\n            thisB.bamHolder.provide(bam);\n        } else {\n            thisB.error = err;\n            thisB.bamHolder.provide(null);\n        }\n    });\n}\n\nBAMFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var light = types && (types.length == 1) && (types[0] == 'density');\n\n    var thisB = this;\n    \n    thisB.busy++;\n    thisB.notifyActivity();\n    \n    this.bamHolder.await(function(bam) {\n        if (!bam) {\n            thisB.busy--;\n            thisB.notifyActivity();\n            return callback(thisB.error || \"Couldn't fetch BAM\");\n        }\n\n        bam.fetch(chr, min, max, function(bamRecords, error) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            if (error) {\n                callback(error, null, null);\n            } else {\n                var features = [];\n                for (var ri = 0; ri < bamRecords.length; ++ri) {\n                    var r = bamRecords[ri];\n\n                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);\n                    if (f)\n                        features.push(f);\n                }\n                callback(null, features, 1000000000);\n            }\n        }, {light: light});\n    });\n}\n\nBAMFeatureSource.prototype.getScales = function() {\n    return 1000000000;\n}\n\nBAMFeatureSource.prototype.getStyleSheet = function(callback) {\n    this.bamHolder.await(function(bam) {\n\t    var stylesheet = new DASStylesheet();\n                \n        var densStyle = new DASStyle();\n        densStyle.glyph = 'HISTOGRAM';\n        densStyle.COLOR1 = 'black';\n        densStyle.COLOR2 = 'red';\n        densStyle.HEIGHT=30;\n        stylesheet.pushStyle({type: 'density'}, 'low', densStyle);\n        stylesheet.pushStyle({type: 'density'}, 'medium', densStyle);\n\n        var wigStyle = new DASStyle();\n        wigStyle.glyph = '__SEQUENCE';\n        wigStyle.FGCOLOR = 'black';\n        wigStyle.BGCOLOR = 'blue'\n        wigStyle.HEIGHT = 8;\n        wigStyle.BUMP = true;\n        wigStyle.LABEL = false;\n        wigStyle.ZINDEX = 20;\n        stylesheet.pushStyle({type: 'bam'}, 'high', wigStyle);\n\n\t    return callback(stylesheet);\n    });\n}\n\n\nfunction RemoteBAMFeatureSource(bamSource, worker) {\n    FeatureSourceBase.call(this);\n\n    var thisB = this;\n    this.bamSource = bamSource;\n    this.worker = worker;\n    this.opts = {credentials: bamSource.credentials, preflight: bamSource.preflight, bamGroup: bamSource.bamGroup};\n    this.keyHolder = new Awaited();\n    \n    if (bamSource.resolver) {\n        this.resolverKey = browser.registerResolver(bamSource.resolver);\n    }\n\n    this.init();\n}\n\nRemoteBAMFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nRemoteBAMFeatureSource.prototype.init = function() {    var thisB = this;\n    var uri = this.bamSource.uri || this.bamSource.bamURI;\n    var indexUri = this.bamSource.indexUri || this.bamSource.baiURI || uri + '.bai';\n\n    var blob = this.bamSource.bamBlob || this.bamSource.blob;\n    var indexBlob = this.bamSource.baiBlob || this.bamSource.indexBlob;\n\n    var cnt = function(result, err) {\n        thisB.readiness = null;\n        thisB.notifyReadiness();\n\n        if (result) {\n            thisB.keyHolder.provide(result);\n        } else {\n            thisB.error = err;\n            thisB.keyHolder.provide(null);\n        }\n    };\n\n    if (blob) {\n        this.worker.postCommand({command: 'connectBAM', blob: blob, indexBlob: indexBlob}, cnt);\n    } else {\n        this.worker.postCommand({\n            command: 'connectBAM', \n            uri: resolveUrlToPage(uri), \n            resolver: this.resolverKey,\n            indexUri: resolveUrlToPage(indexUri),\n            credentials: this.bamSource.credentials,\n            indexChunks: this.bamSource.indexChunks},\n          cnt); \n    }\n}\n\nRemoteBAMFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var light = types && (types.length == 1) && (types[0] == 'density');\n    var thisB = this;\n    \n    thisB.busy++;\n    thisB.notifyActivity();\n    \n    this.keyHolder.await(function(key) {\n        if (!key) {\n            thisB.busy--;\n            thisB.notifyActivity();\n            return callback(thisB.error || \"Couldn't fetch BAM\");\n        }\n\n        thisB.worker.postCommand({command: 'fetch', connection: key, chr: chr, min: min, max: max, opts: {light: light}}, function(bamRecords, error) {\n            // console.log('retrieved ' + bamRecords.length + ' via worker.');\n\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            if (error) {\n                callback(error, null, null);\n            } else {\n                var features = [];\n                for (var ri = 0; ri < bamRecords.length; ++ri) {\n                    var r = bamRecords[ri];\n                    var f = bamRecordToFeature(r, thisB.opts.bamGroup);\n                    if (f)\n                        features.push(f);\n                }\n                callback(null, features, 1000000000);\n            }\n        });\n    });\n}\n\nRemoteBAMFeatureSource.prototype.getScales = function() {\n    return 1000000000;\n}\n\nRemoteBAMFeatureSource.prototype.getStyleSheet = function(callback) {\n    this.keyHolder.await(function(bam) {\n        var stylesheet = new DASStylesheet();\n                \n        var densStyle = new DASStyle();\n        densStyle.glyph = 'HISTOGRAM';\n        densStyle.COLOR1 = 'black';\n        densStyle.COLOR2 = 'red';\n        densStyle.HEIGHT=30;\n        stylesheet.pushStyle({type: 'density'}, 'low', densStyle);\n        stylesheet.pushStyle({type: 'density'}, 'medium', densStyle);\n\n        var wigStyle = new DASStyle();\n        wigStyle.glyph = '__SEQUENCE';\n        wigStyle.FGCOLOR = 'black';\n        wigStyle.BGCOLOR = 'blue'\n        wigStyle.HEIGHT = 8;\n        wigStyle.BUMP = true;\n        wigStyle.LABEL = false;\n        wigStyle.ZINDEX = 20;\n        stylesheet.pushStyle({type: 'bam'}, 'high', wigStyle);\n        return callback(stylesheet);\n    });\n}\n\n\nfunction MappedFeatureSource(source, mapping) {\n    this.source = source;\n    this.mapping = mapping;\n    \n    this.activityListeners = [];\n    this.busy = 0;\n}\n\nMappedFeatureSource.prototype.addActivityListener = function(listener) {\n    this.activityListeners.push(listener);\n}\n\nMappedFeatureSource.prototype.removeActivityListener = function(listener) {\n    var idx = arrayIndexOf(this.activityListeners, listener);\n    if (idx >= 0)\n        this.activityListeners.splice(idx, 0);\n}\n\nMappedFeatureSource.prototype.notifyActivity = function() {\n    for (var li = 0; li < this.activityListeners.length; ++li) {\n        try {\n            this.activityListeners[li](this.busy);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nMappedFeatureSource.prototype.getStyleSheet = function(callback) {\n    return this.source.getStyleSheet(callback);\n}\n\nMappedFeatureSource.prototype.getScales = function() {\n    return this.source.getScales();\n}\n\nMappedFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.source.getDefaultFIPs)\n        return this.source.getDefaultFIPs(callback);\n}\n\nMappedFeatureSource.prototype.simplifySegments = function(segs, minGap) {\n    if (segs.length == 0) return segs;\n\n    segs.sort(function(s1, s2) {\n        var d = s1.name - s2.name;\n        if (d)\n            return d;\n        d = s1.start - s2.start;\n        if (d)\n            return d;\n        return s1.end - s2.end;   // Should never come to this...?\n    });\n\n    var ssegs = [];\n    var currentSeg = segs[0];\n    for (var si = 0; si < segs.length; ++si) {\n        var ns = segs[si];\n\n        // console.log(ns.name + ' ' + ns.start + ' ' + ns.end);\n        if (ns.name != currentSeg.name || ns.start > (currentSeg.end + minGap)) {\n            ssegs.push(currentSeg);\n            currentSeg = ns;\n        } else {\n            currentSeg = new DASSegment(currentSeg.name, Math.min(currentSeg.start, ns.start), Math.max(currentSeg.end, ns.end));\n        }\n    }\n    ssegs.push(currentSeg);\n    return ssegs;\n}\n\nMappedFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback, styleFilters) {\n    var thisB = this;\n    var fetchLength = max - min + 1;\n\n    thisB.busy++;\n    thisB.notifyActivity();\n\n    this.mapping.sourceBlocksForRange(chr, min, max, function(mseg) {\n        if (mseg.length == 0) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            callback(\"No mapping available for this regions\", [], scale);\n        } else {\n            mseg = thisB.simplifySegments(mseg, Math.max(100, 0.05 * fetchLength));\n\n            var mappedFeatures = [];\n            var mappedLoc = null;\n            var count = mseg.length;\n            var finalStatus;\n\n            mseg.map(function(seg) {\n                thisB.source.fetch(seg.name, seg.start, seg.end, scale, types, pool, function(status, features, fscale) {\n                    if (status && !finalStatus)\n                        finalStatus = status;\n\n                    if (features) {\n                        for (var fi = 0; fi < features.length; ++fi) {\n                            var f = features[fi];\n                            var sn = f.segment;\n                            if (sn.indexOf('chr') == 0) {\n                                sn = sn.substr(3);\n                            }\n\n                            var mappings = thisB.mapping.mapSegment(sn, f.min, f.max);\n\n                            if (mappings.length == 0) {\n                                if (f.parts && f.parts.length > 0) {\n                                     mappedFeatures.push(f);\n                                }\n                            } else {\n                                for (var mi = 0; mi < mappings.length; ++mi) {\n                                    var m = mappings[mi];\n                                    var mf = shallowCopy(f);\n                                    mf.segment = m.segment;\n                                    mf.min = m.min;\n                                    mf.max = m.max;\n                                    if (m.partialMin)\n                                        mf.partialMin = m.partialMin;\n                                    if (m.partialMax)\n                                        mf.partialMax = m.partialMax;\n\n                                    if (m.flipped) {\n                                        if (f.orientation == '-') {\n                                            mf.orientation = '+';\n                                        } else if (f.orientation == '+') {\n                                            mf.orientation = '-';\n                                        }\n                                    }\n                                    mappedFeatures.push(mf);\n                                }\n                            }\n                        }\n                    }\n\n                    var m1 = thisB.mapping.mapPoint(seg.name, seg.start);\n                    var m2 = thisB.mapping.mapPoint(seg.name, seg.end);\n\n                    if (m1 && m2) {\n                        var segDestCoverage = new Range(m1.pos, m2.pos);\n                        if (mappedLoc)\n                            mappedLoc = union(mappedLoc, segDestCoverage);\n                        else\n                            mappedLoc = segDestCoverage;\n                    }\n\n                    --count;\n                    if (count == 0) {\n                        thisB.busy--;\n                        thisB.notifyActivity();\n                        callback(finalStatus, mappedFeatures, fscale, mappedLoc);\n                    }\n                }, styleFilters);\n            });\n        }\n    });\n}\n\nfunction DummyFeatureSource() {\n}\n\nDummyFeatureSource.prototype.getScales = function() {\n    return null;\n}\n\nDummyFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, cnt) {\n    return cnt(null, [], 1000000000);\n}\n\nDummyFeatureSource.prototype.getStyleSheet = function(callback) {\n    var stylesheet = new DASStylesheet();\n    var defStyle = new DASStyle();\n    defStyle.glyph = 'BOX';\n    defStyle.BGCOLOR = 'blue';\n    defStyle.FGCOLOR = 'black';\n    stylesheet.pushStyle({type: 'default'}, null, defStyle);\n    return callback(stylesheet);\n}\n\nfunction DummySequenceSource() {\n}\n\nDummySequenceSource.prototype.fetch = function(chr, min, max, pool, cnt) {\n    return cnt(null, null);\n}\n\nfunction JBrowseFeatureSource(source) {\n    this.store = new JBrowseStore(source.jbURI, source.jbQuery);\n}\n\nJBrowseFeatureSource.prototype.getScales = function() {\n    return null;\n}\n\nJBrowseFeatureSource.prototype.getStyleSheet = function(callback) {\n    var stylesheet = new DASStylesheet();\n    \n    var cdsStyle = new DASStyle();\n    cdsStyle.glyph = 'BOX';\n    cdsStyle.FGCOLOR = 'black';\n    cdsStyle.BGCOLOR = 'red'\n    cdsStyle.HEIGHT = 10;\n    cdsStyle.BUMP = true;\n    cdsStyle.ZINDEX = 20;\n    stylesheet.pushStyle({type: 'translation'}, null, cdsStyle);\n    \n    var tsStyle = new DASStyle();\n    tsStyle.glyph = 'BOX';\n    tsStyle.FGCOLOR = 'black';\n    tsStyle.BGCOLOR = 'white';\n    tsStyle.HEIGHT = 10;\n    tsStyle.ZINDEX = 10;\n    tsStyle.BUMP = true;\n    tsStyle.LABEL = true;\n    stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n\n    var wigStyle = new DASStyle();\n    wigStyle.glyph = 'BOX';\n    wigStyle.FGCOLOR = 'black';\n    wigStyle.BGCOLOR = 'green'\n    wigStyle.HEIGHT = 8;\n    wigStyle.BUMP = true;\n    wigStyle.LABEL = true;\n    wigStyle.ZINDEX = 20;\n    stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n\n    return callback(stylesheet);\n}\n\nJBrowseFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    if (types && types.length == 0) {\n        callback(null, [], scale);\n        return;\n    }\n    \n    var fops = {};\n\n    this.store.features(\n        new DASSegment(chr, min, max),\n        fops,\n        function(features, status) {\n            callback(status, features, 100000);\n        }\n    );\n}\n\nBrowser.prototype.sourceAdapterIsCapable = function(s, cap) {\n    if (!s.capabilities)\n        return false;\n    else return s.capabilities()[cap];\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        FeatureSourceBase: FeatureSourceBase,\n\n        TwoBitSequenceSource: TwoBitSequenceSource,\n        EnsemblSequenceSource: EnsemblSequenceSource,\n        DASSequenceSource: DASSequenceSource,\n        MappedFeatureSource: MappedFeatureSource,\n        CachingFeatureSource: CachingFeatureSource,\n        BWGFeatureSource: BWGFeatureSource,\n        RemoteBWGFeatureSource: RemoteBWGFeatureSource,\n        BAMFeatureSource: BAMFeatureSource,\n        RemoteBAMFeatureSource: RemoteBAMFeatureSource,\n        DummyFeatureSource: DummyFeatureSource,\n        DummySequenceSource: DummySequenceSource,\n\n        registerSourceAdapterFactory: dalliance_registerSourceAdapterFactory,\n        registerParserFactory: dalliance_registerParserFactory,\n        makeParser: dalliance_makeParser\n    }\n\n    // Standard set of plugins.\n    require('./ensembljson');\n    require('./tabix-source');\n    require('./memstore');\n    require('./bedwig');\n    require('./vcf');\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2015\n//\n// sourcecompare.js\n//\n\n\nfunction sourceDataURI(conf) {\n    if (conf.uri) {\n        return conf.uri;\n    } else if (conf.blob) {\n        return 'file:' + conf.blob.name;\n    } else if (conf.bwgBlob) {\n        return 'file:' + conf.bwgBlob.name;\n    } else if (conf.bamBlob) {\n        return 'file:' + conf.bamBlob.name;\n    } else if (conf.twoBitBlob) {\n        return 'file:' + conf.twoBitBlob.name;\n    }\n\n    return conf.bwgURI || conf.bamURI || conf.jbURI || conf.twoBitURI || 'https://www.biodalliance.org/magic/no_uri';\n}\n\nfunction sourceStyleURI(conf) {\n    if (conf.stylesheet_uri)\n        return conf.stylesheet_uri;\n    else if (conf.tier_type == 'sequence' || conf.twoBitURI || conf.twoBitBlob)\n        return 'https://www.biodalliance.org/magic/sequence'\n    else\n        return sourceDataURI(conf);\n}\n\nfunction sourcesAreEqualModuloStyle(a, b) {\n    if (sourceDataURI(a) != sourceDataURI(b))\n        return false;\n\n    if (a.mapping != b.mapping)\n        return false;\n\n    if (a.tier_type != b.tier_type)\n        return false;\n\n    if (a.overlay) {\n        if (!b.overlay || b.overlay.length != a.overlay.length)\n            return false;\n        for (var oi = 0; oi < a.overlay.length; ++oi) {\n            if (!sourcesAreEqualModuloStyle(a.overlay[oi], b.overlay[oi]))\n                return false;\n        }\n    } else {\n        if (b.overlay)\n            return false;\n    }\n\n    return true;\n}\n\nfunction sourcesAreEqual(a, b) {\n    if (sourceDataURI(a) != sourceDataURI(b) ||\n        sourceStyleURI(a) != sourceStyleURI(b))\n        return false;\n\n    if (a.mapping != b.mapping)\n        return false;\n\n    if (a.tier_type != b.tier_type)\n        return false;\n\n    if (a.overlay) {\n        if (!b.overlay || b.overlay.length != a.overlay.length)\n            return false;\n        for (var oi = 0; oi < a.overlay.length; ++oi) {\n            if (!sourcesAreEqual(a.overlay[oi], b.overlay[oi]))\n                return false;\n        }\n    } else {\n        if (b.overlay)\n            return false;\n    }\n\n    return true;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        sourcesAreEqual: sourcesAreEqual,\n        sourcesAreEqualModuloStyle: sourcesAreEqualModuloStyle,\n        sourceDataURI: sourceDataURI,\n        sourceStyleURI: sourceStyleURI\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// spans.js: JavaScript Intset/Location port.\n//\n\n\"use strict\";\n\n\nfunction Range(min, max)\n{\n    if (typeof(min) != 'number' || typeof(max) != 'number')\n        throw 'Bad range ' + min + ',' + max;\n    this._min = min;\n    this._max = max;\n}\n\nRange.prototype.min = function() {\n    return this._min;\n}\n\nRange.prototype.max = function() {\n    return this._max;\n}\n\nRange.prototype.contains = function(pos) {\n    return pos >= this._min && pos <= this._max;\n}\n\nRange.prototype.isContiguous = function() {\n    return true;\n}\n\nRange.prototype.ranges = function() {\n    return [this];\n}\n\nRange.prototype._pushRanges = function(ranges) {\n    ranges.push(this);\n}\n\nRange.prototype.toString = function() {\n    return '[' + this._min + '-' + this._max + ']';\n}\n\nfunction _Compound(ranges) {\n    // given: a set of unsorted possibly overlapping ranges\n    // sort the input ranges\n    var sorted = ranges.sort(_rangeOrder);\n    // merge overlaps between adjacent ranges\n    var merged = [];\n    var current = sorted.shift();\n    sorted.forEach(function(range) {\n        if (range._min <= current._max) {\n            if (range._max > current._max) {\n                current._max = range._max;\n            }\n        }\n        else {\n            merged.push(current);\n            current = range;\n        }\n    });\n    merged.push(current);\n    this._ranges = merged;\n}\n\n_Compound.prototype.min = function() {\n    return this._ranges[0].min();\n}\n\n_Compound.prototype.max = function() {\n    return this._ranges[this._ranges.length - 1].max();\n}\n\n// returns the index of the first range that is not less than pos\n_Compound.prototype.lower_bound = function(pos) {\n    // first check if pos is out of range\n    var r = this.ranges();\n    if (pos > this.max()) return r.length;\n    if (pos < this.min()) return 0;\n    // do a binary search\n    var a=0, b=r.length - 1;\n    while (a <= b) {\n        var m = Math.floor((a+b)/2);\n        if (pos > r[m]._max) {\n            a = m+1;\n        }\n        else if (pos < r[m]._min) {\n            b = m-1;\n        }\n        else {\n            return m;\n        }\n    }\n    return a;\n}\n\n_Compound.prototype.contains = function(pos) {\n    var lb = this.lower_bound(pos);\n    if (lb < this._ranges.length && this._ranges[lb].contains(pos)) {\n        return true;\n    }\n    return false;\n}\n\n_Compound.prototype.insertRange = function(range) {\n    var lb = this.lower_bound(range._min);\n    if (lb === this._ranges.length) { // range follows this\n        this._ranges.push(range);\n        return;\n    }\n    \n    var r = this.ranges();\n    if (range._max < r[lb]._min) { // range preceeds lb\n        this._ranges.splice(lb,0,range);\n        return;\n    }\n\n    // range overlaps lb (at least)\n    if (r[lb]._min < range._min) range._min = r[lb]._min;\n    var ub = lb+1;\n    while (ub < r.length && r[ub]._min <= range._max) {\n        ub++;\n    }\n    ub--;\n    // ub is the upper bound of the new range\n    if (r[ub]._max > range._max) range._max = r[ub]._max;\n    \n    // splice range into this._ranges\n    this._ranges.splice(lb,ub-lb+1,range);\n    return;\n}\n\n_Compound.prototype.isContiguous = function() {\n    return this._ranges.length > 1;\n}\n\n_Compound.prototype.ranges = function() {\n    return this._ranges;\n}\n\n_Compound.prototype._pushRanges = function(ranges) {\n    for (var ri = 0; ri < this._ranges.length; ++ri)\n        ranges.push(this._ranges[ri]);\n}\n\n_Compound.prototype.toString = function() {\n    var s = '';\n    for (var r = 0; r < this._ranges.length; ++r) {\n        if (r>0) {\n            s = s + ',';\n        }\n        s = s + this._ranges[r].toString();\n    }\n    return s;\n}\n\nfunction union(s0, s1) {\n    if (! (s0 instanceof _Compound)) {\n        if (! (s0 instanceof Array))\n            s0 = [s0];\n        s0 = new _Compound(s0);\n    }\n    \n    if (s1)\n        s0.insertRange(s1);\n\n    return s0;\n}\n\nfunction intersection(s0, s1) {\n    var r0 = s0.ranges();\n    var r1 = s1.ranges();\n    var l0 = r0.length, l1 = r1.length;\n    var i0 = 0, i1 = 0;\n    var or = [];\n\n    while (i0 < l0 && i1 < l1) {\n        var s0 = r0[i0], s1 = r1[i1];\n        var lapMin = Math.max(s0.min(), s1.min());\n        var lapMax = Math.min(s0.max(), s1.max());\n        if (lapMax >= lapMin) {\n            or.push(new Range(lapMin, lapMax));\n        }\n        if (s0.max() > s1.max()) {\n            ++i1;\n        } else {\n            ++i0;\n        }\n    }\n    \n    if (or.length == 0) {\n        return null; // FIXME\n    } else if (or.length == 1) {\n        return or[0];\n    } else {\n        return new _Compound(or);\n    }\n}\n\nfunction coverage(s) {\n    var tot = 0;\n    var rl = s.ranges();\n    for (var ri = 0; ri < rl.length; ++ri) {\n        var r = rl[ri];\n        tot += (r.max() - r.min() + 1);\n    }\n    return tot;\n}\n\n\n\nfunction rangeOrder(a, b)\n{\n    if (a.min() < b.min()) {\n        return -1;\n    } else if (a.min() > b.min()) {\n        return 1;\n    } else if (a.max() < b.max()) {\n        return -1;\n    } else if (b.max() > a.max()) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nfunction _rangeOrder(a, b)\n{\n    if (a._min < b._min) {\n        return -1;\n    } else if (a._min > b._min) {\n        return 1;\n    } else if (a._max < b._max) {\n        return -1;\n    } else if (b._max > a._max) {\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        Range: Range,\n        union: union,\n        intersection: intersection,\n        coverage: coverage,\n        rangeOver: rangeOrder,\n        _rangeOrder: _rangeOrder\n    }\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2014\n//\n// style.js\n//\n\n\"use strict\";\n\nfunction StyleFilter(type, method, label) {\n    this.type = type;\n    this.method = method;\n    this.label = label;\n}\n\nStyleFilter.prototype.equals = function(o) {\n    return this.type == o.type && this.method == o.method && this.label == o.label;\n}\n\nStyleFilter.prototype.toString = function() {\n    var fs = [];\n    if (this.type) \n        fs.push('type=' + this.type);\n    if (this.method)\n        fs.push('method=' + this.method);\n    if (this.label)\n        fs.push('label=' + this.label);\n    return 'StyleFilter<' + fs.join(';') + '>';\n}\n\nfunction StyleFilterSet(filters) {\n    this._filters = {};\n    if (filters) {\n        for (var fi = 0; fi < filters.length; ++fi) {\n            this.add(filters[fi]);\n        }\n    }\n}\n\nStyleFilterSet.prototype.add = function(filter) {\n    var fs = filter.toString();\n    if (!this._filters[fs]) {\n        this._filters[fs] = filter;\n        this._list = null;\n    }\n}\n\nStyleFilterSet.prototype.addAll = function(filterSet) {\n    var l = filterSet.list();\n    for (var fi = 0; fi < l.length; ++fi) {\n        this.add(l[fi]);\n    }\n}\n\nStyleFilterSet.prototype.doesNotContain = function(filterSet) {\n    var l = filterSet.list();\n    for (var fi = 0; fi < l.length; ++fi) {\n        if (!this._filters[fi.toString()])\n            return true;\n    }\n    return false\n}\n\nStyleFilterSet.prototype.list = function() {\n    if (!this._list) {\n        this._list = [];\n        for (var k in this._filters) {\n            if (this._filters.hasOwnProperty(k)) {\n                this._list.push(this._filters[k]);\n            }\n        }\n    }\n    return this._list;\n}\n\nStyleFilterSet.prototype.typeList = function() {\n    var types = [];\n    var list = this.list();\n    for (var fi = 0; fi < list.length; ++fi) {\n        var filter = list[fi];\n        var type = filter.type;\n        if (!type || type == 'default')\n            return null;\n        if (types.indexOf(type) < 0)\n            types.push(type);\n    }\n    return types;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        StyleFilter: StyleFilter,\n        StyleFilterSet: StyleFilterSet\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// svg-export.js\n//\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var makeElementNS = utils.makeElementNS;\n\n    var VERSION = require('./version');\n\n    var svgSeqTier = require('./sequence-draw').svgSeqTier;\n\n    var svgu = require('./svg-utils');\n    var NS_SVG = svgu.NS_SVG;\n    var NS_XLINK = svgu.NS_XLINK;\n    var SVGPath = svgu.SVGPath;\n\n    var nf = require('./numformats');\n    var formatQuantLabel = nf.formatQuantLabel;\n}\n\n\nBrowser.prototype.makeSVG = function(opts) {\n    opts = opts || {};\n    var minTierHeight = opts.minTierHeight || 20;\n    var padding = 3;\n\n    var b = this;\n    var saveDoc = document.implementation.createDocument(NS_SVG, 'svg', null);\n\n    var saveRoot = makeElementNS(NS_SVG, 'g', null, {\n        fontFamily: 'helvetica',\n        fontSize: '8pt'\n    });\n    saveDoc.documentElement.appendChild(saveRoot);\n\n    var margin = 200;\n\n    var dallianceAnchor = makeElementNS(NS_SVG, 'a',\n       makeElementNS(NS_SVG, 'text', 'Graphics from Dalliance ' + VERSION, {\n           x: (b.featurePanelWidth + margin + 20)/2,\n           y: 30,\n           strokeWidth: 0,\n           fontSize: '12pt',\n\t       textAnchor: 'middle',\n\t       fill: 'blue'\n       }));\n    dallianceAnchor.setAttribute('xmlns:xlink', NS_XLINK);\n    dallianceAnchor.setAttribute('xlink:href', 'http://www.biodalliance.org/');\n  \n    saveRoot.appendChild(dallianceAnchor);\n    \n    var clipRect = makeElementNS(NS_SVG, 'rect', null, {\n    \tx: margin,\n    \ty: 50,\n    \twidth: b.featurePanelWidth,\n    \theight: 100000\n    });\n    var clip = makeElementNS(NS_SVG, 'clipPath', clipRect, {id: 'featureClip'});\n    saveRoot.appendChild(clip);\n\n    var pos = 70;\n    var tierHolder = makeElementNS(NS_SVG, 'g', null, {});\n\n    for (var ti = 0; ti < b.tiers.length; ++ti) {\n        var tier = b.tiers[ti];\n    \tvar tierSVG = makeElementNS(NS_SVG, 'g', null, {clipPath: 'url(#featureClip)', clipRule: 'nonzero'});\n    \tvar tierLabels = makeElementNS(NS_SVG, 'g');\n    \tvar tierTopPos = pos;\n\n    \tvar tierBackground = makeElementNS(NS_SVG, 'rect', null, {x: 0, y: tierTopPos, width: '10000', height: 50, fill: tier.background});\n    \ttierSVG.appendChild(tierBackground);\n\n    \tif (tier.sequenceSource) {\n    \t    var seqTrack = svgSeqTier(tier, tier.currentSequence);\n    \t    \n    \t    tierSVG.appendChild(makeElementNS(NS_SVG, 'g', seqTrack, {transform: 'translate(' + (margin) + ', ' + pos + ')'}));\n    \t    pos += 80;\n    \t} else {\n            if (!tier.subtiers) {\n    \t\t   continue;\n            }\n    \t\n    \t    var offset = ((tier.glyphCacheOrigin - b.viewStart) * b.scale);\n            var hasQuant = false;\n            for (var sti = 0; sti < tier.subtiers.length; ++sti) {\n                pos += padding;\n        \t\tvar subtier = tier.subtiers[sti];\n                    \n        \t\tvar glyphElements = [];\n        \t\tfor (var gi = 0; gi < subtier.glyphs.length; ++gi) {\n                    var glyph = subtier.glyphs[gi];\n                    glyphElements.push(glyph.toSVG());\n        \t\t}\n\n    \t\t    tierSVG.appendChild(makeElementNS(NS_SVG, 'g', glyphElements, {transform: 'translate(' + (margin+offset) + ', ' + pos + ')'}));\n\n        \t\tif (subtier.quant) {\n                    hasQuant = true;\n        \t\t    var q = subtier.quant;\n                    var h = subtier.height;\n\n                    var numTics = 2;\n                    if (h > 40) {\n                        numTics = 1 + ((h/20) | 0);\n                    }\n                    var ticSpacing = h / (numTics - 1);\n                    var ticInterval = (q.max - q.min) / (numTics - 1);\n\n        \t\t    var path = new SVGPath();\n        \t\t    path.moveTo(margin + 5, pos);\n        \t\t    path.lineTo(margin, pos);\n        \t\t    path.lineTo(margin, pos + subtier.height);\n        \t\t    path.lineTo(margin + 5, pos + subtier.height);\n                    for (var t = 1; t < numTics-1; ++t) {\n                        var ty = t*ticSpacing;\n                        path.moveTo(margin, pos + ty);\n                        path.lineTo(margin+3, pos + ty);\n                    }\n\n        \t\t    tierLabels.appendChild(makeElementNS(NS_SVG, 'path', null, {d: path.toPathData(), fill: 'none', stroke: 'black', strokeWidth: '2px'}));\n        \t\t    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.max), {x: margin - 3, y: pos + 7, textAnchor: 'end'}));\n        \t\t    tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel(q.min), {x: margin - 3, y: pos +  subtier.height, textAnchor: 'end'}));\n                    for (var t = 1; t < numTics-1; ++t) {\n                        var ty = t*ticSpacing;\n                        tierLabels.appendChild(makeElementNS(NS_SVG, 'text', formatQuantLabel((1.0*q.max) - (t*ticInterval)), \n                            {x: margin - 3, y: pos +  ty + 3, textAnchor: 'end'}));\n                    }\n        \t\t}\n\n    \t\t    pos += subtier.height + padding;\n            }\n\n            if (pos - tierTopPos < minTierHeight) {\n                pos = tierTopPos + minTierHeight;\n            }\n    \t}\n\n        var labelName;\n        if (typeof tier.config.name === 'string')\n            labelName = tier.config.name;\n        else\n            labelName = tier.dasSource.name;\n    \ttierLabels.appendChild(\n    \t    makeElementNS(\n    \t\tNS_SVG, 'text',\n    \t\tlabelName,\n    \t\t{x: margin - (hasQuant ? 20 : 12), y: (pos+tierTopPos+8)/2, fontSize: '10pt', textAnchor: 'end'}));\n\n    \t\n    \ttierBackground.setAttribute('height', pos - tierTopPos);\n    \ttierHolder.appendChild(makeElementNS(NS_SVG, 'g', [tierSVG, tierLabels]));\n    }\n\n    if (opts.highlights) {\n        var highlights = this.highlights || [];\n        for (var hi = 0; hi < highlights.length; ++hi) {\n            var h = highlights[hi];\n            if ((h.chr == this.chr || h.chr == ('chr' + this.chr)) && h.min < this.viewEnd && h.max > this.viewStart) {\n                var tmin = (Math.max(h.min, this.viewStart) - this.viewStart) * this.scale;\n                var tmax = (Math.min(h.max, this.viewEnd) - this.viewStart) * this.scale;\n\n                tierHolder.appendChild(makeElementNS(NS_SVG, 'rect', null, {x: margin + tmin, y: 70, width: (tmax-tmin), height: pos-70,\n                                                                      stroke: 'none', fill: this.defaultHighlightFill, fillOpacity: this.defaultHighlightAlpha}));\n            }\n        }\n    }\n\n    var rulerPos = -1; \n    if (opts.ruler == 'center') {\n        rulerPos = margin + ((this.viewEnd - this.viewStart)*this.scale) / 2;\n    } else if (opts.ruler == 'left') {\n        rulerPos = margin;\n    } else if (opts.ruler == 'right') {\n        rulerPos = margin + ((this.viewEnd - this.viewStart)*this.scale);\n    }\n    if (rulerPos >= 0) {\n        tierHolder.appendChild(makeElementNS(NS_SVG, 'line', null, {x1: rulerPos, y1: 70, x2: rulerPos, y2: pos,\n                                                              stroke: 'blue'}));\n    }\n\n    saveRoot.appendChild(tierHolder);\n    saveDoc.documentElement.setAttribute('width', b.featurePanelWidth + 20 + margin);\n    saveDoc.documentElement.setAttribute('height', pos + 50);\n\n    var svgBlob = new Blob([new XMLSerializer().serializeToString(saveDoc)], {type: 'image/svg+xml'});\n    return svgBlob;\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// svg-utils.js\n//\n\nvar NS_SVG = 'http://www.w3.org/2000/svg';\nvar NS_XLINK = 'http://www.w3.org/1999/xlink';\n\nfunction SVGPath() {\n    this.ops = [];\n}\n\nSVGPath.prototype.moveTo = function(x, y) {\n    this.ops.push('M ' + x + ' ' + y);\n}\n\nSVGPath.prototype.lineTo = function(x, y) {\n    this.ops.push('L ' + x + ' ' + y);\n}\n\nSVGPath.prototype.closePath = function() {\n    this.ops.push('Z');\n}\n\nSVGPath.prototype.toPathData = function() {\n    return this.ops.join(' ');\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        NS_SVG: NS_SVG,\n        NS_XLINK: NS_XLINK,\n        SVGPath: SVGPath\n    }\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// tabix-source.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sa = require('./sourceadapters');\n    var dalliance_registerSourceAdapterFactory = sa.registerSourceAdapterFactory;\n    var dalliance_makeParser = sa.makeParser;\n    var FeatureSourceBase = sa.FeatureSourceBase;\n\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n    var BlobFetchable = bin.BlobFetchable;\n\n    var utils = require('./utils');\n    var Awaited = utils.Awaited;\n\n    var connectTabix = require('./tabix').connectTabix;\n}\n\nfunction TabixFeatureSource(source) {\n    FeatureSourceBase.call(this);\n    this.readiness = 'Connecting';\n    this.source = source;\n\n    this.tabixHolder = new Awaited();\n    var thisB = this;\n\n\n    var parser = dalliance_makeParser(source.payload);\n    if (!parser) {\n        throw 'Unsuported tabix payload ' + source.payload;\n    } else {\n        this.parser = parser;\n    }\n\n    var data, index;\n    if (this.source.blob) {\n        data = new BlobFetchable(this.source.blob);\n        index = new BlobFetchable(this.source.indexBlob);\n    } else {\n        data = new URLFetchable(this.source.uri, {credentials: this.source.credentials, resolver: this.source.resolver});\n        index = new URLFetchable(this.source.indexURI || (this.source.uri + '.tbi'), \n                                 {credentials: this.source.credentials, resolver: this.source.resolver});\n    }\n    connectTabix(data, index, function(tabix, err) {\n        thisB.tabixHolder.provide(tabix);\n        tabix.fetchHeader(function(lines, err) {\n            if (lines) {\n                var session = parser.createSession(function() { /* Null sink because we shouldn't get records */ });\n                for (var li = 0; li < lines.length; ++li) {\n                    session.parse(lines[li]);\n                }\n                session.flush();\n            }\n        });\n        thisB.readiness = null\n        thisB.notifyReadiness();\n    });\n}\n\nTabixFeatureSource.prototype = Object.create(FeatureSourceBase.prototype);\n\nTabixFeatureSource.prototype.fetch = function(chr, min, max, scale, types, pool, callback) {\n    var thisB = this;\n    \n    thisB.busy++;\n    thisB.notifyActivity();\n    \n    this.tabixHolder.await(function(tabix) {\n        tabix.fetch(chr, min, max, function(records, error) {\n            thisB.busy--;\n            thisB.notifyActivity();\n\n            var features = [];\n            var session = thisB.parser.createSession(function(f) {features.push(f)});\n            for (var ri = 0; ri < records.length; ++ri) {\n                var f = session.parse(records[ri]);\n            }\n            session.flush();\n            callback(null, features, 1000000000);\n        });\n    });\n}\n\n\nTabixFeatureSource.prototype.getStyleSheet = function(callback) {\n    if (this.parser && this.parser.getStyleSheet)\n        this.parser.getStyleSheet(callback)\n}\n\nTabixFeatureSource.prototype.getDefaultFIPs = function(callback) {\n    if (this.parser && this.parser.getDefaultFIPs)\n        this.parser.getDefaultFIPs(callback);\n}\n\n\ndalliance_registerSourceAdapterFactory('tabix', function(source) {\n    return {features: new TabixFeatureSource(source)};\n});\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2011\n//\n// tabix.js: basic support for tabix-indexed flatfiles\n//\n\n\"use strict\";\n\nvar TABIX_MAGIC = 0x01494254;\n\nif (typeof(require) !== 'undefined') {\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readShort = bin.readShort;\n    var readByte = bin.readByte;\n    var readInt64 = bin.readInt64;\n    var readFloat = bin.readFloat;\n\n    var lh3utils = require('./lh3utils');\n    var readVob = lh3utils.readVob;\n    var unbgzf = lh3utils.unbgzf;\n    var reg2bins = lh3utils.reg2bins;\n    var Chunk = lh3utils.Chunk;\n}\n\nfunction TabixFile() {\n}\n\nfunction connectTabix(data, tbi, callback) {\n    var tabix = new TabixFile();\n    tabix.data = data;\n    tabix.tbi = tbi;\n\n    tabix.tbi.fetch(function(header) {   // Do we really need to fetch the whole thing? :-(\n        if (!header) {\n            return callback(null, \"Couldn't access Tabix\");\n        }\n\n        var unchead = unbgzf(header, header.byteLength);\n        var uncba = new Uint8Array(unchead);\n        var magic = readInt(uncba, 0);\n        if (magic != TABIX_MAGIC) {\n            return callback(null, 'Not a tabix index');\n        }\n\n        var nref = readInt(uncba, 4);\n        tabix.format = readInt(uncba, 8);\n        tabix.colSeq = readInt(uncba, 12);\n        tabix.colStart = readInt(uncba, 16);\n        tabix.colEnd = readInt(uncba, 20);\n        tabix.meta = readInt(uncba, 24);\n        tabix.skip = readInt(uncba, 28);\n        var nameLength = readInt(uncba, 32);\n\n        tabix.indices = [];\n\n        var p = 36;\n        tabix.chrToIndex = {};\n        tabix.indexToChr = [];\n        for (var i = 0; i < nref; ++i) {\n            var name = ''\n\n            while (true) {\n                var ch = uncba[p++];\n                if (ch == 0)\n                    break;\n\n                name += String.fromCharCode(ch);\n            }\n\n            tabix.chrToIndex[name] = i;\n            if (name.indexOf('chr') == 0) {\n                tabix.chrToIndex[name.substring(3)] = i;\n            } else {\n                tabix.chrToIndex['chr' + name] = i;\n            }\n            tabix.indexToChr.push(name);\n        }\n\n        var minBlockIndex = 1000000000;\n        for (var ref = 0; ref < nref; ++ref) {\n            var blockStart = p;\n            var nbin = readInt(uncba, p); p += 4;\n            for (var b = 0; b < nbin; ++b) {\n                var bin = readInt(uncba, p);\n                var nchnk = readInt(uncba, p+4);\n                p += 8 + (nchnk * 16);\n            }\n            var nintv = readInt(uncba, p); p += 4;\n            \n            var q = p;\n            for (var i = 0; i < nintv; ++i) {\n                var v = readVob(uncba, q); q += 8;\n                if (v) {\n                    var bi = v.block;\n                    if (v.offset > 0)\n                        bi += 65536;\n\n                    if (bi < minBlockIndex)\n                        minBlockIndex = bi;\n                    break;\n                }\n            }\n            p += (nintv * 8);\n\n\n            var ub = uncba;\n            if (nbin > 0) {\n                tabix.indices[ref] = new Uint8Array(unchead, blockStart, p - blockStart);\n            }                     \n        }\n\n        tabix.headerMax = minBlockIndex;\n\n        callback(tabix);\n    }, {timeout: 5000});\n}\n\n// Copy-paste from BamFile\n\nTabixFile.prototype.blocksForRange = function(refId, min, max) {\n    var index = this.indices[refId];\n    if (!index) {\n        return [];\n    }\n\n    var intBinsL = reg2bins(min, max);\n    var intBins = [];\n    for (var i = 0; i < intBinsL.length; ++i) {\n        intBins[intBinsL[i]] = true;\n    }\n    var leafChunks = [], otherChunks = [];\n\n    var nbin = readInt(index, 0);\n    var p = 4;\n    for (var b = 0; b < nbin; ++b) {\n        var bin = readInt(index, p);\n        var nchnk = readInt(index, p+4);\n        p += 8;\n        if (intBins[bin]) {\n            for (var c = 0; c < nchnk; ++c) {\n                var cs = readVob(index, p, true);\n                var ce = readVob(index, p + 8, true);\n                (bin < 4681 ? otherChunks : leafChunks).push(new Chunk(cs, ce));\n                p += 16;\n            }\n        } else {\n            p +=  (nchnk * 16);\n        }\n    }\n\n    var nintv = readInt(index, p);\n    var lowest = null;\n    var minLin = Math.min(min>>14, nintv - 1), maxLin = Math.min(max>>14, nintv - 1);\n    for (var i = minLin; i <= maxLin; ++i) {\n        var lb =  readVob(index, p + 4 + (i * 8));\n        if (!lb) {\n            continue;\n        }\n        if (!lowest || lb.block < lowest.block || lb.offset < lowest.offset) {\n            lowest = lb;\n        }\n    }\n    \n    var prunedOtherChunks = [];\n    if (lowest != null) {\n        for (var i = 0; i < otherChunks.length; ++i) {\n            var chnk = otherChunks[i];\n            if (chnk.maxv.block >= lowest.block && chnk.maxv.offset >= lowest.offset) {\n                prunedOtherChunks.push(chnk);\n            }\n        }\n    } \n    otherChunks = prunedOtherChunks;\n\n    var intChunks = [];\n    for (var i = 0; i < otherChunks.length; ++i) {\n        intChunks.push(otherChunks[i]);\n    }\n    for (var i = 0; i < leafChunks.length; ++i) {\n        intChunks.push(leafChunks[i]);\n    }\n\n    intChunks.sort(function(c0, c1) {\n        var dif = c0.minv.block - c1.minv.block;\n        if (dif != 0) {\n            return dif;\n        } else {\n            return c0.minv.offset - c1.minv.offset;\n        }\n    });\n    var mergedChunks = [];\n    if (intChunks.length > 0) {\n        var cur = intChunks[0];\n        for (var i = 1; i < intChunks.length; ++i) {\n            var nc = intChunks[i];\n            if (nc.minv.block == cur.maxv.block /* && nc.minv.offset == cur.maxv.offset */) { // no point splitting mid-block\n                cur = new Chunk(cur.minv, nc.maxv);\n            } else {\n                mergedChunks.push(cur);\n                cur = nc;\n            }\n        }\n        mergedChunks.push(cur);\n    }\n\n    return mergedChunks;\n}\n\nTabixFile.prototype.fetch = function(chr, min, max, callback) {\n    var thisB = this;\n\n    var chrId = this.chrToIndex[chr];\n    if (chrId == undefined)\n        return callback([]);\n\n    var canonicalChr = this.indexToChr[chrId];\n\n    var chunks;\n    if (chrId === undefined) {\n        chunks = [];\n    } else {\n        chunks = this.blocksForRange(chrId, min, max);\n        if (!chunks) {\n            callback(null, 'Error in index fetch');\n        }\n    }\n\n    var records = [];\n    var index = 0;\n    var data;\n\n    function tramp() {\n        if (index >= chunks.length) {\n            return callback(records);\n        } else if (!data) {\n            var c = chunks[index];\n            var fetchMin = c.minv.block;\n            var fetchMax = c.maxv.block + (1<<16); // *sigh*\n            thisB.data.slice(fetchMin, fetchMax - fetchMin).fetch(function(r) {\n                data = unbgzf(r, c.maxv.block - c.minv.block + 1);\n                return tramp();\n            });\n        } else {\n            var ba = new Uint8Array(data);\n            thisB.readRecords(ba, chunks[index].minv.offset, records, min, max, canonicalChr);\n            data = null;\n            ++index;\n            return tramp();\n        }\n    }\n    tramp();\n}\n\nTabixFile.prototype.readRecords = function(ba, offset, sink, min, max, chr) {\n   LINE_LOOP:\n    while (true) {\n        var line = '';\n        while (offset < ba.length) {\n            var ch = ba[offset++];\n            if (ch == 10) {\n                var toks = line.split('\\t');\n\n                if (toks[this.colSeq - 1] == chr) {\n                    var fmin = parseInt(toks[this.colStart - 1]);\n                    var fmax = fmin;\n                    if (this.colEnd > 0)\n                        fmax = parseInt(toks[this.colEnd - 1]);\n                    if (this.format & 0x10000) ++fmin;\n\n                    if (fmin <= max && fmax >= min)\n                        sink.push(line);\n                }\n                continue LINE_LOOP;\n            } else {\n                line += String.fromCharCode(ch);\n            }\n        }\n        return;\n    }\n}\n\nTabixFile.prototype.fetchHeader = function(callback) {\n    var self = this;\n    var fetchPtr = 0, ptr = 0, line='';\n    var lines = [];\n\n    self.data.slice(0, self.headerMax).fetch(function(chnk) {\n        if (!chnk) {\n            return callback(null, \"Fetch failed\");\n        }\n        var ba = new Uint8Array(unbgzf(chnk, chnk.byteLength));\n        var ptr = 0, line = '', lines = [];\n        while (ptr < ba.length) {\n            var ch = ba[ptr++]\n            if (ch == 10) {\n                if (line.charCodeAt(0) == self.meta) {\n                    lines.push(line);\n                    line = '';\n                } else {\n                    return callback(lines);\n                }\n            } else {\n                line += String.fromCharCode(ch);\n            }\n        }\n        callback(lines);\n    });\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        connectTabix: connectTabix,\n        TABIX_MAGIC: TABIX_MAGIC\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// thub.js: support for track-hub style registries\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var textXHR = utils.textXHR;\n    var relativeURL = utils.relativeURL;\n    var shallowCopy = utils.shallowCopy;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n}\n\nvar THUB_STANZA_REGEXP = /\\n\\s*\\n/;\nvar THUB_PARSE_REGEXP  = /(\\w+) +(.+)\\n?/;\nvar THUB_SUBGROUP_REGEXP = /subGroup[1-9]/;\n\nvar THUB_PENNANT_PREFIX = 'http://genome.ucsc.edu/images/';\n\nfunction TrackHub(url) {\n    this.genomes = {};\n    this.url = url;\n}\n\nfunction TrackHubTrack() {\n}\n\nTrackHubTrack.prototype.get = function(k) {\n    if (this[k])\n        return this[k];\n    else if (this._parent) \n        return this._parent.get(k);\n}\n\nfunction TrackHubDB(hub) {\n    this.hub = hub;\n}\n\nTrackHubDB.prototype.getTracks = function(callback) {\n    var thisB = this;\n    if (this._tracks) {\n        return callback(this._tracks);\n    } \n    \n    textXHR(this.absURL, function(trackFile, err) {\n        if (err) {\n            return callback(null, err);\n        }\n        \n        // trackFile = trackFile.replace(/\\#.*/g, '');\n        trackFile = trackFile.replace('\\\\\\n', ' ');\n\n        var tracks = [];\n        var tracksById = {};\n        var stanzas = trackFile.split(THUB_STANZA_REGEXP);\n        for (var s = 0; s < stanzas.length; ++s) {\n            var toks = stanzas[s].replace(/\\#.*/g, '').split(THUB_PARSE_REGEXP);\n            var track = new TrackHubTrack();\n            track._db = thisB;\n            for (var l = 0; l < toks.length - 2; l += 3) {\n                var k = toks[l+1], v = toks[l+2];\n                if (k.match(THUB_SUBGROUP_REGEXP)) {\n                    if (!track.subgroups)\n                        track.subgroups = {};\n                    var sgtoks = v.split(/\\s/);\n                    var sgtag = sgtoks[0];\n                    var sgrecord = {name: sgtoks[1], tags: [], titles: []};\n                    for (var sgti = 2; sgti < sgtoks.length; ++sgti) {\n                        var grp = sgtoks[sgti].split(/=/);\n                        sgrecord.tags.push(grp[0]);\n                        sgrecord.titles.push(grp[1]);\n                    }\n                    track.subgroups[sgtag] = sgrecord;\n                } else if (k === 'subGroups') {\n                    var sgtoks = v.split(/(\\w+)=(\\w+)/);\n                    track.sgm = {};\n                    for (var sgti = 0; sgti < sgtoks.length - 2; sgti += 3) {\n                        track.sgm[sgtoks[sgti+1]] = sgtoks[sgti + 2];\n                    }\n                } else {\n                    track[toks[l+1]] = toks[l+2];\n                }\n            }\n\n            if (track.track && (track.type || track.container || track.view || track.bigDataUrl)) {\n                tracks.push(track);\n                tracksById[track.track] = track;\n            } else {\n                // console.log('skipping ', track);\n            }\n        }\n        \n        var toplevels = [];\n        var composites = [];\n        for (var ti = 0; ti < tracks.length; ++ti) {\n            var track = tracks[ti];\n            var top = true;\n            if (track.parent) {\n                var ptoks = track.parent.split(/\\s+/);\n                var parent = tracksById[ptoks[0]];\n                if (parent) {\n                    track._parent = parent;\n\n                    if (!parent.children)\n                        parent.children = [];\n                    parent.children.push(track);\n\n                    if (parent)\n                        top = false;\n                } else {\n                    console.log(\"Couldn't find parent \" + ptoks[0] + '(' + track.parent + ')');\n                }\n               \n            }\n            if (track.compositeTrack) {\n                composites.push(track);\n            } else if (top) {\n                toplevels.push(track);\n            }\n        }\n\n        for (var ci = 0; ci < composites.length; ++ci) {\n            var comp = composites[ci];\n            if (!comp.children)\n                continue;\n\n            var parentOfViews = false;\n            for (var ki = 0; ki < comp.children.length; ++ki) {\n                var k = comp.children[ki];\n                if (k.view) {\n                    k.shortLabel = comp.shortLabel + \": \" + k.shortLabel;\n                    toplevels.push(k);\n                    parentOfViews = true;\n                }\n            }\n            if (!parentOfViews)\n                toplevels.push(comp);\n        }\n            \n        thisB._tracks = toplevels;\n        return callback(thisB._tracks, null);\n    }, {credentials: this.credentials, salt: true});\n}\n\nfunction connectTrackHub(hubURL, callback, opts) {\n    opts = opts || {};\n    opts.salt = true;\n\n    textXHR(hubURL, function(hubFile, err) {\n        if (err) {\n            return callback(null, err);\n        }\n\n        var toks = hubFile.split(THUB_PARSE_REGEXP);\n        var hub = new TrackHub(hubURL);\n        if (opts.credentials) {\n            hub.credentials = opts.credentials;\n        }\n        for (var l = 0; l < toks.length - 2; l += 3) {\n            hub[toks[l+1]] = toks[l+2];\n        }\n        \n        \n        if (hub.genomesFile) {\n            var genURL = relativeURL(hubURL, hub.genomesFile);\n            textXHR(genURL, function(genFile, err) {\n                if (err) {\n                    return callback(null, err);\n                }\n\n                var stanzas = genFile.split(THUB_STANZA_REGEXP);\n                for (var s = 0; s < stanzas.length; ++s) {\n                    var toks = stanzas[s].split(THUB_PARSE_REGEXP);\n                    var gprops = new TrackHubDB(hub);\n                    if (opts.credentials) {\n                        gprops.credentials = opts.credentials;\n                    }\n\n                    for (var l = 0; l < toks.length - 2; l += 3) {\n                        gprops[toks[l+1]] = toks[l+2];\n                    }\n\n                    if (gprops.twoBitPath) {\n                        gprops.twoBitPath = relativeURL(genURL, gprops.twoBitPath);\n                    }\n\n                    if (gprops.genome && gprops.trackDb) {\n                        gprops.absURL = relativeURL(genURL, gprops.trackDb);\n                        hub.genomes[gprops.genome] = gprops;\n                    }\n                }\n\n                callback(hub);\n                        \n            }, opts);\n        } else {\n            callback(null, 'No genomesFile');\n        }\n    }, opts);\n}\n\n\nTrackHubTrack.prototype.toDallianceSource = function() {\n    var source = {\n        name: this.shortLabel,\n        desc: this.longLabel\n    };\n    if (this._db.mapping) {\n        source.mapping = this._db.mapping;\n    }\n\n    var pennantIcon = this.get('pennantIcon');\n    if (pennantIcon) {\n        var ptoks = pennantIcon.split(/\\s+/);\n        source.pennant = THUB_PENNANT_PREFIX + ptoks[0];\n    }\n\n    var searchTrix = this.get('searchTrix');\n    if (searchTrix) {\n        source.trixURI = relativeURL(this._db.absURL, searchTrix);\n    }\n\n    if (this.container == 'multiWig') {\n        source.merge = 'concat';\n        source.overlay = [];\n        var children = this.children || [];\n        source.style = [];\n        source.noDownsample = true;\n\n        for (var ci = 0; ci < children.length; ++ci) {\n            var ch = children[ci];\n            var cs = ch.toDallianceSource()\n            source.overlay.push(cs);\n\n            if (cs.style) {\n                for (var si = 0; si < cs.style.length; ++si) {\n                    var style = cs.style[si];\n                    style.method = ch.shortLabel;  // FIXME\n                    if (this.aggregate == 'transparentOverlay')\n                        style.style.ALPHA = 0.5;\n                    source.style.push(style);\n                }\n            }\n        }\n        return source;       \n    } else {\n        var type = this.type;\n        if (!type) {\n            var p = this;\n            while (p._parent && !p.type) {\n                p = p._parent;\n            }\n            type = p.type;\n        }\n        if (!type)\n            return;\n        var typeToks = type.split(/\\s+/);\n        if (typeToks[0] == 'bigBed' && this.bigDataUrl) {\n            var bedTokens = typeToks[1]|0\n            var bedPlus = typeToks[2] == '+';\n\n            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);\n            source.style = this.bigbedStyles();\n            if (this._db.credentials) {\n                source.credentials = true;\n            }\n            if (bedTokens >= 12 && bedPlus)\n                source.collapseSuperGroups = true;\n            return source;\n        } else if (typeToks[0] == 'bigWig' && this.bigDataUrl) {\n            source.bwgURI = relativeURL(this._db.absURL, this.bigDataUrl);\n            source.style = this.bigwigStyles();\n            source.noDownsample = true;     // FIXME seems like a blunt instrument...\n            \n            if (this.yLineOnOff && this.yLineOnOff == 'on') {\n                source.quantLeapThreshold = this.yLineMark !== undefined ? (1.0 * this.yLineMark) : 0.0;\n            }\n\n            if (this._db.credentials) {\n                source.credentials = true;\n            }\n\n            return source;\n        } else if (typeToks[0] == 'bam'  && this.bigDataUrl) {\n            source.bamURI = relativeURL(this._db.absURL, this.bigDataUrl);\n            if (this._db.credentials) {\n                source.credentials = true;\n            }\n            return source;\n        } else if (typeToks[0] == 'vcfTabix' && this.bigDataUrl) {\n            source.uri = relativeURL(this._db.absURL, this.bigDataUrl);\n            source.tier_type = 'tabix';\n            source.payload = 'vcf';\n            if (this._db.credentials) {\n                source.credentials = true;\n            }\n            return source;\n        } else {\n            console.log('Unsupported ' + this.type);\n        }\n    }\n}\n\nTrackHubTrack.prototype.bigwigStyles = function() {\n    var type = this.type;\n    if (!type) {\n        var p = this;\n        while (p._parent && !p.type) {\n            p = p._parent;\n        }\n        type = p.type;\n    }\n    if (!type)\n        return;\n    var typeToks = type.split(/\\s+/);\n\n    var min, max;\n    if (typeToks.length >= 3) {\n        min = 1.0 * typeToks[1];\n        max = 1.0 * typeToks[2];\n    }\n\n    var height;\n    if (this.maxHeightPixels) {\n        var mhpToks = this.maxHeightPixels.split(/:/);\n        if (mhpToks.length == 3) {\n            height = mhpToks[1] | 0;\n        } else {\n            console.log('maxHeightPixels should be of the form max:default:min');\n        }\n    }\n    \n    var gtype = 'bars';\n    if (this.graphTypeDefault) {\n        gtype = this.graphTypeDefault;\n    }\n    \n    var color = 'black';\n    var altColor = null;\n    if (this.color) {\n        color = 'rgb(' + this.color + ')';\n    }\n    if (this.altColor) {\n        altColor = 'rgb(' + this.altColor + ')';\n    }\n    \n    var stylesheet = new DASStylesheet();\n    var wigStyle = new DASStyle();\n    if (gtype == 'points') {\n        wigStyle.glyph = 'POINT';\n    } else {\n        wigStyle.glyph = 'HISTOGRAM';\n    }\n\n    if (altColor) {\n        wigStyle.COLOR1 = color;\n        wigStyle.COLOR2 = altColor;\n    } else {\n        wigStyle.BGCOLOR = color;\n    }\n    wigStyle.HEIGHT = height || 30;\n    if (min || max) {\n        wigStyle.MIN = min;\n        wigStyle.MAX = max;\n    }\n    stylesheet.pushStyle({type: 'default'}, null, wigStyle);\n    return stylesheet.styles;\n}\n\nTrackHubTrack.prototype.bigbedStyles = function() {\n    var itemRgb = (''+this.get('itemRgb')).toLowerCase() == 'on';\n    var visibility = this.get('visibility') || 'full';\n    var color = this.get('color');\n    if (color)\n        color = 'rgb(' + color + ')';\n    else \n        color = 'blue';\n    \n    var stylesheet = new DASStylesheet();\n    var wigStyle = new DASStyle();\n    wigStyle.glyph = 'BOX';\n    wigStyle.FGCOLOR = 'black';\n    wigStyle.BGCOLOR = color;\n    wigStyle.HEIGHT = (visibility == 'full' || visibility == 'pack') ? 12 : 8;\n    wigStyle.BUMP = (visibility == 'full' || visibility == 'pack');\n    wigStyle.LABEL = (visibility == 'full' || visibility == 'pack');\n    wigStyle.ZINDEX = 20;\n    if (itemRgb)\n        wigStyle.BGITEM = true;\n\n    var cbs = this.get('colorByStrand');\n    if (cbs) {\n        var cbsToks = cbs.split(/\\s+/);\n        \n        var plus = shallowCopy(wigStyle);\n        plus.BGCOLOR = 'rgb(' + cbsToks[0] + ')';\n        stylesheet.pushStyle({type: 'bigwig', orientation: '+'}, null, plus);\n\n        var minus = shallowCopy(wigStyle);\n        minus.BGCOLOR = 'rgb(' + cbsToks[1] + ')';\n        stylesheet.pushStyle({type: 'bigwig', orientation: '-'}, null, minus);\n    } else {\n        stylesheet.pushStyle({type: 'bigwig'}, null, wigStyle);\n    }   \n    \n    var tlStyle = new DASStyle();\n    tlStyle.glyph = 'BOX';\n    tlStyle.FGCOLOR = 'black';\n    if (itemRgb)\n        tlStyle.BGITEM = true;\n    tlStyle.BGCOLOR = 'red'\n    tlStyle.HEIGHT = 10;\n    tlStyle.BUMP = true;\n    tlStyle.ZINDEX = 20;\n    stylesheet.pushStyle({type: 'translation'}, null, tlStyle);\n    \n    var tsStyle = new DASStyle();\n    tsStyle.glyph = 'BOX';\n    tsStyle.FGCOLOR = 'black';\n    tsStyle.BGCOLOR = 'white';\n    tsStyle.HEIGHT = 10;\n    tsStyle.ZINDEX = 10;\n    tsStyle.BUMP = true;\n    tsStyle.LABEL = true;\n    stylesheet.pushStyle({type: 'transcript'}, null, tsStyle);\n\n    return stylesheet.styles;\n}\n\nfunction THUB_COMPARE(g, h) {\n    if (g.priority && h.priority) {\n        return (1.0 * g.priority) - (1.0 * h.priority)\n    } else if (g.priority) {\n        return 1;\n    } else if (h.priority) {\n        return -1;\n    } else {\n        return g.shortLabel.localeCompare(h.shortLabel);\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        connectTrackHub: connectTrackHub,\n        THUB_COMPARE: THUB_COMPARE\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// tier-actions.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var shallowCopy = utils.shallowCopy;\n}\n\nBrowser.prototype.mergeSelectedTiers = function() {\n    var sources = [];\n    var styles = [];\n\n    for (var sti = 0; sti < this.selectedTiers.length; ++sti) {\n        var tier = this.tiers[this.selectedTiers[sti]];\n\t    sources.push(shallowCopy(tier.dasSource));\n        var ss = tier.stylesheet.styles;\n        for (var si = 0; si < ss.length; ++si) {\n            var sh = ss[si];\n            var nsh = shallowCopy(sh);\n            nsh.method = tier.dasSource.name.replace(/[()+*?]/g, '\\\\$&');\n            nsh._methodRE = null;\n            nsh.style = shallowCopy(sh.style);\n            if (nsh.style.ZINDEX === undefined)\n                nsh.style.ZINDEX = sti;\n\n            if (tier.forceMin) {\n                nsh.style.MIN = tier.forceMin;\n            }\n            if (tier.forceMax) {\n                nsh.style.MAX = tier.forceMax;\n            }\n\n            styles.push(nsh);\n        }\n    }\n    \n    this.addTier(\n\t{name: 'Merged',\n\t merge: 'concat',\n\t overlay: sources,\n\t noDownsample: true,\n     style: styles});\n\n    this.setSelectedTier(this.tiers.length - 1);\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2013\n//\n// tier-edit.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n\n    var das = require('./das');\n    var isDasBooleanTrue = das.isDasBooleanTrue;\n    var isDasBooleanNotFalse = das.isDasBooleanNotFalse;\n    var copyStylesheet = das.copyStylesheet;\n\n    var color = require('./color');\n    var dasColourForName = color.dasColourForName;\n\n    var sourceDataURI = require('./sourcecompare').sourceDataURI;\n}\n\nvar __dalliance_smallGlyphs = {\n    DOT: true, \n    EX: true, \n    STAR: true, \n    SQUARE: true, \n    CROSS: true, \n    TRIANGLE: true, \n    PLIMSOLL: true\n};\n\nBrowser.prototype.openTierPanel = function(tier) {\n    var b = this;\n\n    if (this.uiMode === 'tier' && this.manipulatingTier === tier) {\n        this.hideToolPanel();\n        this.setUiMode('none');\n    } else if (!tier) {\n        return;\n    } else {\n        var setStyleColors = function(style) {\n            if (style.BGGRAD)\n                return;\n\n            if (numColors == 1) {\n                if (style.glyph == 'LINEPLOT' || __dalliance_smallGlyphs[style.glyph]) {\n                    style.FGCOLOR = tierColorField.value;\n                } else {\n                    style.BGCOLOR = tierColorField.value;\n                }\n                style.COLOR1 = style.COLOR2 = style.COLOR3 = null;\n            } else {\n                style.COLOR1 = tierColorField.value;\n                style.COLOR2 = tierColorField2.value;\n                if (numColors > 2) {\n                    style.COLOR3 = tierColorField3.value;\n                } else {\n                    style.COLOR3 = null;\n                }\n            }\n            style._gradient = null;\n            style._plusColor = tierPlusColorField.value;\n            style._minusColor = tierMinusColorField.value;\n        }\n\n        var mutateStylesheet = function(visitor) {\n            var nss = copyStylesheet(tier.stylesheet);\n            var ssScale = tier.browser.zoomForCurrentScale();\n\n            for (var i = 0; i < nss.styles.length; ++i) {\n                var sh = nss.styles[i];\n                if (sh.zoom && sh.zoom != ssScale) {\n                    continue;\n                }\n\n                visitor(sh.style);\n            }\n\n            return nss;\n        }\n\n        var changeColor = function(ev) {\n            tier.mergeStylesheet(mutateStylesheet(setStyleColors));\n        }\n        \n        this.manipulatingTier = tier;\n\n        var tierForm = makeElement('div', null, {className: 'tier-edit'});\n\n        var aboutBanner = makeElement('div', \"About '\" + (tier.config.Name || tier.dasSource.name) + \"'\", null,\n                {background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center'});\n        tierForm.appendChild(aboutBanner);\n\n        var about = makeElement('div', \n            [makeElement('p', tier.dasSource.desc)]\n        );\n        var aboutNotes = [];\n        var sduri = sourceDataURI(tier.dasSource);\n        if (sduri &&\n            (sduri.indexOf('http://') == 0 ||\n             sduri.indexOf('https://') == 0 ||\n             sduri.indexOf('//') == 0) &&\n            sduri !== 'https://www.biodalliance.org/magic/no_uri')\n        {\n            aboutNotes.push(makeElement('li', makeElement('a', '(Download data)', {href: sduri})));\n        }\n\n        if (tier.dasSource.mapping) {\n            var coords = this.chains[tier.dasSource.mapping].coords;\n            aboutNotes.push(makeElement('li',  'Mapped from ' + coords.auth + coords.version));\n        }\n\n        if (aboutNotes.length > 0) {\n            about.appendChild(makeElement('ul', aboutNotes));\n        }\n        \n        tierForm.appendChild(about);\n\n        var semanticBanner = makeElement('span', ' (styles for current zoom level)', null, {display: 'none'});\n        var editBanner = makeElement('div', ['Edit', semanticBanner], null,\n              {background: 'gray', paddingBottom: '5px', marginBottom: '5px', textAlign: 'center'});\n        tierForm.appendChild(editBanner);\n\n        var tierNameField = makeElement('input', null, {type: 'text'});\n        var tierPinnedToggle = makeElement('input', null, {type: 'checkbox', disabled: this.disablePinning});\n\n        var glyphField = makeElement('select');\n        glyphField.appendChild(makeElement('option', 'Histogram', {value: 'HISTOGRAM'}));\n        glyphField.appendChild(makeElement('option', 'Line Plot', {value: 'LINEPLOT'}));\n        glyphField.appendChild(makeElement('option', 'Ribbon', {value: 'GRADIENT'}));\n        glyphField.appendChild(makeElement('option', 'Scatter', {value: 'SCATTER'}));\n\n        var tierColorField = makeElement('input', null, {type: 'text', value: '#dd00dd'});\n        var tierColorField2 = makeElement('input', null, {type: 'text', value: '#dd00dd'});\n        var tierColorField3 = makeElement('input', null, {type: 'text', value: '#dd00dd'});\n\n        var tierPlusColorField = makeElement('input', null, {type: 'text', value: '#ffa07a'});\n        var tierMinusColorField = makeElement('input', null, {type: 'text', value: '#87cefa'});\n\n        try {\n            tierColorField.type = tierColorField2.type = tierColorField3.type = 'color';\n            tierPlusColorField.type = tierMinusColorField.type = 'color';\n        } catch (e) {\n            // IE throws if attempt to set type to 'color'.\n        }\n\n        var tierColorFields = [tierColorField, tierColorField2, tierColorField3];\n        var colorListPlus = makeElement('i', null, {className: 'fa fa-plus-circle'});\n        var colorListMinus = makeElement('i', null, {className: 'fa fa-minus-circle'});\n        var numColors = 1;\n        var colorListElement = makeElement('td', tierColorFields);\n        var setNumColors = function(n) {\n            numColors = n;\n            for (var i = 0; i < n; ++i) \n                tierColorFields[i].style.display = 'block';\n            for (var i = n; i < tierColorFields.length; ++i)\n                tierColorFields[i].style.display = 'none';\n        }\n        colorListPlus.addEventListener('click', function(ev) {\n            if (numColors < 3) {\n                setNumColors(numColors + 1);\n                changeColor(null);\n            }\n        }, false);\n        colorListMinus.addEventListener('click', function(ev) {\n            if (numColors > 1) {\n                setNumColors(numColors - 1);\n                changeColor(null);\n            }\n        }, false);\n\n        var tierMinField = makeElement('input', null, {type: 'text', value: '0.0'});\n        var tierMaxField = makeElement('input', null, {type: 'text', value: '10.0'});\n        var tierMinToggle = makeElement('input', null, {type: 'checkbox'});\n        var tierMaxToggle = makeElement('input', null, {type: 'checkbox'});\n\n        var quantLeapToggle = makeElement('input', null, {type: 'checkbox', checked: tier.quantLeapThreshold !== undefined});\n        var quantLeapThreshField = makeElement('input', null, {type: 'text', value: tier.quantLeapThreshold, disabled: !quantLeapToggle.checked});\n\n        var tierHeightField = makeElement('input', null, {type: 'text', value: '50'});\n\n        var bumpToggle = makeElement('input', null, {type: 'checkbox'});\n        var bumpLimit = makeElement('input', null, {type: 'text'});\n        var labelToggle = makeElement('input', null, {type: 'checkbox'});\n\n        var mainStyle = null;\n        if (tier.stylesheet.styles.length > 0) {\n            var s = mainStyle = tier.stylesheet.styles[0].style;\n        }\n\n        var refresh = function() {\n            if (typeof tier.config.name === 'string')\n                tierNameField.value = tier.config.name;\n            else \n                tierNameField.value = tier.dasSource.name;\n\n            tierPinnedToggle.checked = tier.pinned;\n\n            if (tier.forceHeight) {\n                tierHeightField.value = '' + tier.forceHeight;\n            } else if (mainStyle && mainStyle.HEIGHT) {\n                tierHeightField.value = '' + mainStyle.HEIGHT;\n            }\n\n            if (typeof tier.quantLeapThreshold == 'number') {\n                quantLeapToggle.checked = true;\n                quantLeapThreshField.disabled = false;\n                if (parseFloat(quantLeapThreshField.value) != tier.quantLeapThreshold)\n                    quantLeapThreshField.value = tier.quantLeapThreshold;\n            } else {\n                quantLeapToggle.checked = false;\n                quantLeapThreshField.disabled = true;\n            }\n\n            if (typeof tier.subtierMax == 'number') {\n                bumpLimit.value = '' + tier.subtierMax;\n            } else {\n                bumpLimit.value = '' + (tier.dasSource.subtierMax || tier.browser.defaultSubtierMax);\n            }\n\n            if (tier.stylesheet.styles.length > 0) {\n                var s = null;\n                var isQuantitative=false, isSimpleQuantitative = false;\n                var ssScale = tier.browser.zoomForCurrentScale();\n                var activeStyleCount = 0;\n\n                for (var si = 0; si < tier.stylesheet.styles.length; ++si) {\n                    var sh = tier.stylesheet.styles[si];  \n                    if (sh.zoom && sh.zoom != ssScale) {\n                        continue;\n                    }\n                    ++activeStyleCount;\n                    var ss = tier.stylesheet.styles[si].style;\n\n                    if (!s) {\n                        s = mainStyle = ss;\n                    }\n                    \n                    if (ss.glyph == 'LINEPLOT' || ss.glyph == 'HISTOGRAM' || ss.glyph == 'GRADIENT' || isDasBooleanTrue(ss.SCATTER)) {\n                        if (!isQuantitative)\n                            s = mainStyle = ss;\n                        isQuantitative = true;\n                    }\n                }\n                if (!s) {\n                    return;\n                }\n\n                semanticBanner.style.display = (activeStyleCount == tier.stylesheet.styles.length) ? 'none' : 'inline';\n\n                isSimpleQuantitative = isQuantitative && activeStyleCount == 1;\n                var isGradient = s.COLOR2 || s.BGGRAD;\n\n                if (isQuantitative) {\n                    minRow.style.display = 'table-row';\n                    maxRow.style.display = 'table-row';\n                    bumpRow.style.display = 'none';\n                    labelRow.style.display = 'none';\n                } else {\n                    minRow.style.display = 'none';\n                    maxRow.style.display = 'none';\n                    bumpRow.style.display = 'table-row';\n                    bumpToggle.checked = isDasBooleanTrue(mainStyle.BUMP);\n                    bumpLimit.disabled = !isDasBooleanTrue(mainStyle.BUMP);\n                    labelRow.style.display = 'table-row';\n                    labelToggle.checked = isDasBooleanTrue(mainStyle.LABEL);\n                }\n\n                if (isSimpleQuantitative) {\n                    styleRow.style.display = 'table-row';\n                    colorRow.style.display = 'table-row';\n                } else {\n                    styleRow.style.display = 'none';\n                    colorRow.style.display = 'none';\n\n                }\n\n                var numColors = 1;\n                if (s.COLOR1) {\n                    tierColorField.value = dasColourForName(s.COLOR1).toHexString();\n                    if (s.COLOR2) {\n                        tierColorField2.value = dasColourForName(s.COLOR2).toHexString();\n                        if (s.COLOR3) {\n                            tierColorField3.value = dasColourForName(s.COLOR3).toHexString();\n                            numColors = 3;\n                        } else {\n                            numColors = 2;\n                        }\n                    }\n                } else {\n                    if (s.glyph == 'LINEPLOT' || s.glyph == 'DOT' && s.FGCOLOR) {\n                        tierColorField.value = dasColourForName(s.FGCOLOR).toHexString();\n                    } else if (s.BGCOLOR) {\n                        tierColorField.value = dasColourForName(s.BGCOLOR).toHexString();\n                    }\n                } \n                setNumColors(numColors);\n\n                if (s._plusColor)\n                    tierPlusColorField.value = dasColourForName(s._plusColor).toHexString() || s._plusColor;\n                if (s._minusColor)\n                    tierMinusColorField.value = dasColourForName(s._minusColor).toHexString() || s._minusColor;\n                if (isDasBooleanTrue(s.SCATTER)) {\n                    glyphField.value = 'SCATTER';\n                } else {\n                    glyphField.value = s.glyph;\n                } \n\n                var setMinValue, setMaxValue;\n                if (s.MIN !== undefined) {\n                    var x = parseFloat(s.MIN);\n                    if (!isNaN(x))\n                        setMinValue = x;\n                }\n                if (!tier.forceMinDynamic && (s.MIN !== undefined || tier.forceMin !== undefined)) {\n                    tierMinToggle.checked = true;\n                    tierMinField.disabled = false;\n                } else {\n                    tierMinToggle.checked = false;\n                    tierMinField.disabled = true;\n                }\n\n                if (s.MAX !== undefined) {\n                    var x = parseFloat(s.MAX)\n                    if (!isNaN(x))\n                        setMaxValue = x;\n                }\n                if (!tier.forceMaxDynamic && (s.MAX !== undefined || tier.forceMax !== undefined)) {\n                    tierMaxToggle.checked = true;\n                    tierMaxField.disabled = false;\n                } else {\n                    tierMaxToggle.checked = false;\n                    tierMaxField.disabled = true;\n                }\n\n                if (tier.forceMin != undefined) {\n                    setMinValue = tier.forceMin;\n                }\n                if (tier.forceMax != undefined) {\n                    setMaxValue = tier.forceMax;\n                }\n                if (typeof(setMinValue) == 'number' && setMinValue != parseFloat(tierMinField.value)) {\n                    tierMinField.value = setMinValue;\n                }\n                if (typeof(setMaxValue) == 'number' && setMaxValue != parseFloat(tierMaxField.value)) {\n                    tierMaxField.value = setMaxValue;\n                }\n\n                var seqStyle = getSeqStyle(tier.stylesheet);\n                if (seqStyle) {\n                    seqMismatchRow.style.display = 'table-row';\n                    seqMismatchToggle.checked = (seqStyle.__SEQCOLOR === 'mismatch');\n                    seqInsertRow.style.display = 'table-row';\n                    seqInsertToggle.checked =  isDasBooleanTrue(seqStyle.__INSERTIONS);\n                    seqIgnoreQualsRow.style.display = 'table-row';\n                    seqIgnoreQualsToggle.checked = (seqStyle.__disableQuals === undefined || seqStyle.__disableQuals === false);\n                    console.log(seqStyle.__disableQuals);\n                } else {\n                    seqMismatchRow.style.display = 'none';\n                    seqInsertRow.style.display = 'none';\n                    seqIgnoreQualsRow.style.display = 'none';\n                }\n\n                if (seqStyle && seqMismatchToggle.checked && !isSimpleQuantitative) {\n                    plusStrandColorRow.style.display = 'table-row';\n                    minusStrandColorRow.style.display = 'table-row';\n                } else {\n                    plusStrandColorRow.style.display = 'none';\n                    minusStrandColorRow.style.display = 'none';\n                }\n            }\n\n            if (isQuantitative && tier.browser.sourceAdapterIsCapable(tier.featureSource, 'quantLeap'))\n                quantLeapRow.style.display = 'table-row';\n            else \n                quantLeapRow.style.display = 'none';\n        }\n\n        var seqMismatchToggle = makeElement('input', null, {type: 'checkbox'});\n        var seqMismatchRow = makeElement('tr',\n            [makeElement('th', 'Highlight mismatches & strands'),\n             makeElement('td', seqMismatchToggle)]);\n        seqMismatchToggle.addEventListener('change', function(ev) {\n            var nss = copyStylesheet(tier.stylesheet);\n            var seqStyle = getSeqStyle(nss);\n            seqStyle.__SEQCOLOR = seqMismatchToggle.checked ? 'mismatch' : 'base';\n            tier.mergeStylesheet(nss);\n        });\n\n        var seqInsertToggle = makeElement('input', null, {type: 'checkbox'});\n        var seqInsertRow = makeElement('tr',\n            [makeElement('th', 'Show insertions'),\n             makeElement('td', seqInsertToggle)]);\n        seqInsertToggle.addEventListener('change', function(ev) {\n            var nss = copyStylesheet(tier.stylesheet);\n            var seqStyle = getSeqStyle(nss);\n            seqStyle.__INSERTIONS = seqInsertToggle.checked ? 'yes' : 'no';\n            tier.mergeStylesheet(nss);\n        });\n\n        var seqIgnoreQualsToggle = makeElement('input', null, {type: 'checkbox'});\n        var seqIgnoreQualsRow = makeElement('tr',\n            [makeElement('th', 'Reflect base quality as base color transparency'),\n             makeElement('td', seqIgnoreQualsToggle)]);\n        seqIgnoreQualsToggle.addEventListener('change', function(ev) {\n            var nss = copyStylesheet(tier.stylesheet);\n            var seqStyle = getSeqStyle(nss);\n            seqStyle.__disableQuals = !seqIgnoreQualsToggle.checked;\n            console.log(seqStyle.__disableQuals);\n            tier.mergeStylesheet(nss);\n        });\n\n        var styleRow = makeElement('tr',\n                [makeElement('th', 'Style'),\n                 makeElement('td', glyphField)]);\n        var colorRow = makeElement('tr',\n                [makeElement('th', ['Colour(s)', colorListPlus, colorListMinus]),\n                 colorListElement]);\n        var plusStrandColorRow = makeElement('tr',\n                [makeElement('th', 'Plus Strand Color'),\n                 makeElement('td', tierPlusColorField)]);\n        var minusStrandColorRow = makeElement('tr',\n                [makeElement('th', 'Minus Strand Color'),\n                 makeElement('td', tierMinusColorField)]);\n        var minRow = makeElement('tr',\n                [makeElement('th', 'Min value'),\n                 makeElement('td', [tierMinToggle, ' ', tierMinField])]);\n        var maxRow = makeElement('tr',\n                [makeElement('th', 'Max value'),\n                 makeElement('td', [tierMaxToggle, ' ', tierMaxField])]);\n        var quantLeapRow = \n             makeElement('tr',\n                [makeElement('th', 'Threshold leap:'),\n                 makeElement('td', [quantLeapToggle, ' ', quantLeapThreshField])]);\n        var bumpRow = makeElement('tr',\n                [makeElement('th', 'Bump overlaps'),\n                 makeElement('td', [bumpToggle, ' limit: ', bumpLimit])]);\n        var labelRow = makeElement('tr',\n                [makeElement('th', 'Label features'),\n                 makeElement('td', labelToggle)]);\n\n\n        var tierTable = makeElement('table',\n            [makeElement('tr',\n                [makeElement('th', 'Name', {}, {width: '150px', textAlign: 'right'}),\n                 tierNameField]),\n\n             makeElement('tr',\n                [makeElement('th', 'Pin to top'),\n                 tierPinnedToggle]),\n\n             makeElement('tr',\n                [makeElement('th', 'Height'),\n                 makeElement('td', tierHeightField)]),\n\n            styleRow,\n            colorRow,\n            plusStrandColorRow,\n            minusStrandColorRow,\n            minRow,\n            maxRow,\n            quantLeapRow,\n            bumpRow,\n            labelRow,\n            seqMismatchRow,\n            seqInsertRow,\n            seqIgnoreQualsRow\n             ]);\n\n\n        refresh();\n\n        tierForm.appendChild(tierTable);\n\n        var resetButton = makeElement('button', 'Reset track', {className: 'btn'}, {marginLeft: 'auto', marginRight: 'auto', display: 'block'});\n        resetButton.addEventListener('click', function(ev) {\n            tier.setConfig({});\n        }, false);\n        tierForm.appendChild(resetButton);\n\n        tierNameField.addEventListener('input', function(ev) {\n            tier.mergeConfig({name: tierNameField.value});\n        }, false);\n\n        tierPinnedToggle.addEventListener('change', function(ev) {\n            tier.mergeConfig({pinned: tierPinnedToggle.checked});\n        }, false);\n\n        for (var ci = 0; ci < tierColorFields.length; ++ci) {\n            tierColorFields[ci].addEventListener('change', changeColor, false);\n        }\n\n        tierPlusColorField.addEventListener('change', changeColor, false);\n        tierMinusColorField.addEventListener('change', changeColor, false);\n\n        glyphField.addEventListener('change', function(ev) {\n            var nss = mutateStylesheet(function(ts) {\n                if (glyphField.value === 'SCATTER') {\n                    ts.SCATTER = true;\n                    ts.glyph = 'DOT';\n                    ts.SIZE = '3';\n                } else {\n                    ts.glyph = glyphField.value;\n                    ts.SCATTER = undefined;\n                }\n                setStyleColors(ts);\n            });\n            tier.mergeStylesheet(nss);\n        }, false);\n\n        tierMinToggle.addEventListener('change', function(ev) {\n            var conf = {forceMinDynamic: !tierMinToggle.checked};\n            tierMinField.disabled = !tierMinToggle.checked;\n            var x = parseFloat(tierMinField.value);\n            if (tierMinToggle.checked && typeof(x) == 'number' && !isNaN(x))\n                conf.forceMin = parseFloat(x);\n            tier.mergeConfig(conf);\n        });\n        tierMinField.addEventListener('input', function(ev) {\n            var x = parseFloat(tierMinField.value);\n            if (typeof(x) == 'number' && !isNaN(x))\n                tier.mergeConfig({forceMin: x});\n        }, false);\n\n        tierMaxToggle.addEventListener('change', function(ev) {\n            var conf = {forceMaxDynamic: !tierMaxToggle.checked};\n            tierMaxField.disabled = !tierMaxToggle.checked;\n            var x = parseFloat(tierMaxField.value);\n            if (tierMaxToggle.checked && typeof(x) == 'number' && !isNaN(x))\n                conf.forceMax = parseFloat(x);\n            tier.mergeConfig(conf);\n        });\n        tierMaxField.addEventListener('input', function(ev) {\n            var x = parseFloat(tierMaxField.value);\n            if (typeof(x) == 'number' && !isNaN(x))\n                tier.mergeConfig({forceMax: x});\n        }, false);\n\n        tierHeightField.addEventListener('input', function(ev) {\n            var x = parseFloat(tierHeightField.value);\n            if (typeof(x) == 'number' && !isNaN(x))\n                tier.mergeConfig({height: Math.min(500, x|0)});\n        }, false);\n\n        var updateQuant = function() {\n            quantLeapThreshField.disabled = !quantLeapToggle.checked;\n            if (quantLeapToggle.checked) {\n                var x = parseFloat(quantLeapThreshField.value);\n                if (typeof(x) == 'number' && !isNaN(x)) {\n                    tier.mergeConfig({quantLeapThreshold: parseFloat(quantLeapThreshField.value)});\n                }\n            } else {\n                tier.mergeConfig({quantLeapThreshold: null});\n            }\n        }\n        quantLeapToggle.addEventListener('change', function(ev) {\n            updateQuant();\n        }, false);\n        quantLeapThreshField.addEventListener('input', function(ev) {\n            updateQuant();\n        }, false);\n\n        labelToggle.addEventListener('change', function(ev) {\n            var nss = mutateStylesheet(function(style) {\n                style.LABEL = labelToggle.checked ? 'yes' : 'no';\n            });\n            tier.mergeStylesheet(nss);\n        }, false);\n        bumpToggle.addEventListener('change', function(ev) {\n            var nss = mutateStylesheet(function(style) {\n                style.BUMP = bumpToggle.checked ? 'yes' : 'no';\n            });\n            tier.mergeStylesheet(nss);\n        }, false);\n        bumpLimit.addEventListener('input', function(ev) {\n            var x = parseInt(bumpLimit.value);\n            if (typeof(x) == 'number' && x > 0) {\n                tier.mergeConfig({subtierMax: x});\n            }\n        }, false);\n\n\n        this.showToolPanel(tierForm);\n        this.setUiMode('tier');\n\n        tier.addTierListener(refresh);\n\n        var currentScale = tier.browser.scale;\n        tier.browser.addViewListener(function() {\n            if (tier.browser.scale != currentScale) {\n                currentScale = tier.browser.scale;\n                refresh();\n            }\n        });\n    }\n}\n\nfunction getSeqStyle(stylesheet) {\n    for (var si = 0; si < stylesheet.styles.length; ++si) {\n        var ss = stylesheet.styles[si].style;\n        if (ss.glyph === '__SEQUENCE') {\n            return ss;\n        }\n    }\n}\n\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// tier.js: (try) to encapsulate the functionality of a browser tier.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n    var shallowCopy = utils.shallowCopy;\n    var pushnew = utils.pushnew;\n    var miniJSONify = utils.miniJSONify;\n    var arrayIndexOf = utils.arrayIndexOf;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n\n    var style = require('./style');\n    var StyleFilter = style.StyleFilter;\n    var StyleFilterSet = style.StyleFilterSet;\n\n    var sc = require('./sourcecompare');\n    var sourceDataURI = sc.sourceDataURI;\n\n    var Promise = require('es6-promise').Promise;\n\n    var sortFeatures = require('./features').sortFeatures;\n}\n\nvar __tier_idSeed = 0;\n\nfunction DasTier(browser, source, config, background)\n{\n    this.config = config || {};\n    this.id = 'tier' + (++__tier_idSeed);\n    this.browser = browser;\n    this.dasSource = shallowCopy(source);\n    this.background = background;\n\n    this.viewport = makeElement('canvas', null, \n                                {width: '' + ((this.browser.featurePanelWidth|0) + 2000), \n                                 height: \"30\",\n                                 className: 'viewport_12_5'},\n                                {position: 'inline-block',\n                                 margin: '0px', border: '0px'});\n    this.viewportHolder = makeElement('div', this.viewport, {className: 'viewport-holder_12_5'}, \n                                      {background: background,\n                                       position: 'absolute',\n                                       padding: '0px', margin: '0px',\n                                       border: '0px',\n                                       left: '-1000px',\n                                       minHeight: '200px'});\n    this.overlay = makeElement('canvas', null,\n         {width: + ((this.browser.featurePanelWidth|0)), \n          height: \"30\",\n          className: 'viewport-overlay'});\n\n    this.notifier = makeElement('div', '', {className: 'notifier'});\n    this.notifierHolder = makeElement('div', this.notifier, {className: 'notifier-holder'});\n    this.quantOverlay = makeElement(\n        'canvas', null, \n        {width: '50', height: \"56\",\n         className: 'quant-overlay'});\n\n    this.removeButton = makeElement('i', null, {className: 'fa fa-times'});\n    this.bumpButton = makeElement('i', null, {className: 'fa fa-plus-circle'});\n    this.loaderButton = browser.makeLoader(16);\n    this.loaderButton.style.display = 'none';\n    this.infoElement = makeElement('div', this.dasSource.desc, {className: 'track-label-info'});\n    this.nameButton = makeElement('div', [], {className: 'tier-tab'});\n    this.nameButton.appendChild(this.removeButton);\n    if (source.pennant) {\n        this.nameButton.appendChild(makeElement('img', null, {src: source.pennant, width: '16', height: '16'}))\n    } else if (source.mapping) {\n        var version = null;\n        if (this.browser.chains[source.mapping])\n            version = this.browser.chains[source.mapping].coords.version;\n        if (version)\n            this.nameButton.appendChild(makeElement('span', '' + version, null, {fontSize: '8pt', background: 'black', color: 'white', paddingLeft: '3px', paddingRight: '3px', paddingTop: '1px', paddingBottom: '1px', marginLeft: '2px', borderRadius: '10px'}));\n    }\n    this.nameElement = makeElement('span', source.name);\n    this.nameButton.appendChild(makeElement('span', [this.nameElement, this.infoElement], {className: 'track-name-holder'}));\n    this.nameButton.appendChild(this.bumpButton);\n    this.nameButton.appendChild(this.loaderButton);\n\n    this.label = makeElement('span',\n       [this.nameButton],\n       {className: 'btn-group track-label'});\n\n    var classes = 'tier' + (source.className ? ' ' + source.className : '');\n    this.row = makeElement('div', [this.viewportHolder,\n                                   this.overlay,\n                                   this.quantOverlay],\n                            {className: classes});\n\n    if (!background) {\n        this.row.style.background = 'none';\n    }\n\n    if (!browser.noDefaultLabels)\n        this.row.appendChild(this.label);\n    this.row.appendChild(this.notifierHolder);\n    \n    this.layoutHeight = 25;\n    this.bumped = true;\n    this.styleIdSeed = 0;\n    if (source.quantLeapThreshold) {\n        this.quantLeapThreshold = source.quantLeapThreshold;\n    }\n    if (this.dasSource.collapseSuperGroups) {\n        this.bumped = false;\n    }\n    this.layoutWasDone = false;\n\n    if (source.featureInfoPlugin) {\n        this.addFeatureInfoPlugin(source.featureInfoPlugin);\n    }\n\n    this.initSources();\n\n    var thisB = this;\n    if (this.featureSource && this.featureSource.getDefaultFIPs && !source.noSourceFeatureInfo) {\n        this.featureSource.getDefaultFIPs(function(fip) {\n            if (fip)\n                thisB.addFeatureInfoPlugin(fip);\n        });\n    }\n\n    if (this.featureSource && this.featureSource.addReadinessListener) {\n        this.readinessListener = function(ready) {\n            thisB.notify(ready, -1);\n        };\n        this.featureSource.addReadinessListener(this.readinessListener);\n    }\n\n    if (this.featureSource && this.featureSource.addActivityListener) {\n        this.activityListener = function(busy) {\n            if (busy > 0) {\n                thisB.loaderButton.style.display = 'inline-block';\n            } else {\n                thisB.loaderButton.style.display = 'none';\n            }\n            thisB.browser.pingActivity();\n        };\n        this.featureSource.addActivityListener(this.activityListener);\n    }\n\n    this.listeners = [];\n    this.featuresLoadedListeners = [];\n}\n\nDasTier.prototype.destroy = function() {\n    if (this.featureSource.removeReadinessListener) {\n        this.featureSource.removeReadinessListener(this.readinessListener);\n    }\n    if (this.featureSource.removeActivityListener) {\n        this.featureSource.removeActivityListener(this.activityListener);\n    }\n}\n\nDasTier.prototype.setBackground = function(b) {\n    this.background = b;\n    this.viewportHolder.style.background = b;\n}\n\nDasTier.prototype.toString = function() {\n    return this.id;\n}\n\nDasTier.prototype.addFeatureInfoPlugin = function(p) {\n    if (!this.featureInfoPlugins) \n        this.featureInfoPlugins = [];\n    this.featureInfoPlugins.push(p);\n}\n\nDasTier.prototype.init = function() {\n    var tier = this;\n    return new Promise(function (resolve, reject) {\n        \n        if (tier.dasSource.style) {\n            tier.setStylesheet({styles: tier.dasSource.style});\n            resolve(tier);\n        } else {\n            tier.status = 'Fetching stylesheet';\n            tier.fetchStylesheet(function(ss, err) {\n                if (err || !ss) {\n                    tier.error = 'No stylesheet';\n                    var ss = new DASStylesheet();\n                    var defStyle = new DASStyle();\n                    defStyle.glyph = 'BOX';\n                    defStyle.BGCOLOR = 'blue';\n                    defStyle.FGCOLOR = 'black';\n                    ss.pushStyle({type: 'default'}, null, defStyle);\n                    tier.setStylesheet(ss);\n                } else {\n                    tier.setStylesheet(ss);\n                    if (ss.geneHint) {\n                        tier.dasSource.collapseSuperGroups = true;\n                        tier.bumped = false;\n                        tier.updateLabel();\n                    }\n                    tier._updateFromConfig();\n                }\n                resolve(tier);\n            });\n        }\n    });\n}\n\nDasTier.prototype.setStylesheet = function(ss) {\n    this.baseStylesheet = shallowCopy(ss);\n    for (var si = 0; si < this.baseStylesheet.styles.length; ++si) {\n        var sh = this.baseStylesheet.styles[si] = shallowCopy(this.baseStylesheet.styles[si]);\n        sh._methodRE = sh._labelRE = sh._typeRE = null;\n        sh.style = shallowCopy(sh.style);\n        sh.style.id = 'style' + (++this.styleIdSeed);\n    }\n    this.baseStylesheetValidity = b64_sha1(miniJSONify(this.baseStylesheet));\n    this._updateFromConfig();\n}\n\nDasTier.prototype.getSource = function() {\n    return this.featureSource;\n}\n\nDasTier.prototype.getDesiredTypes = function(scale) {\n    var sfs = this.getActiveStyleFilters(scale);\n    if (sfs)\n        return sfs.typeList();\n}\n\nDasTier.prototype.getActiveStyleFilters = function(scale) {\n    var ssScale = this.browser.zoomForCurrentScale();\n\n    if (this.stylesheet) {\n        var styles = new StyleFilterSet();\n        var ss = this.stylesheet.styles;\n        for (var si = 0; si < ss.length; ++si) {\n            var sh = ss[si];\n            if (!sh.zoom || sh.zoom == ssScale) {\n                styles.add(new StyleFilter(sh.type, sh.method, sh.label));\n            }\n        }\n        return styles;\n    }\n}\n\nDasTier.prototype.needsSequence = function(scale ) {\n    if (this.sequenceSource && scale < 5) {\n        return true;\n    } else if ((this.dasSource.bamURI || this.dasSource.bamBlob || this.dasSource.bwgURI || this.dasSource.bwgBlob)\n                 && scale < 20) {\n        return true\n    }\n    return false;\n}\n\nDasTier.prototype.setFeatures = function(chr, coverage, scale, features, sequence) {\n    this.currentFeatures = features;\n    this.currentSequence = sequence;    \n    this.knownChr = chr;\n    this.knownCoverage = coverage;\n    \n\n    // only notify features loaded, if they are valid\n    if (features) {\n        sortFeatures(this);\n        this.notifyFeaturesLoaded();\n    }\n}\n\nDasTier.prototype.draw = function() {\n    var features = this.currentFeatures;\n    var seq = this.currentSequence;\n    if (this.sequenceSource) {\n        drawSeqTier(this, seq); \n    } else {\n        drawFeatureTier(this);\n    }\n    this.paint();\n    this.originHaxx = 0;\n    this.browser.arrangeTiers();\n}\n\nDasTier.prototype.findNextFeature = function(chr, pos, dir, fedge, callback) {\n    if (this.quantLeapThreshold) {\n        var width = this.browser.viewEnd - this.browser.viewStart + 1;\n        pos = (pos +  ((width * dir) / 2))|0\n        this.featureSource.quantFindNextFeature(chr, pos, dir, this.quantLeapThreshold, callback);\n    } else {\n        if (this.knownCoverage && pos >= this.knownCoverage.min() && pos <= this.knownCoverage.max()) {\n            if (this.currentFeatures) {\n                var bestFeature = null;\n                for (var fi = 0; fi < this.currentFeatures.length; ++fi) {\n                    var f = this.currentFeatures[fi];\n                    if (!f.min || !f.max) {\n                        continue;\n                    }\n                    if (f.parents && f.parents.length > 0) {\n                        continue;\n                    }\n                    if (dir < 0) {\n                        if (fedge == 1 && f.max >= pos && f.min < pos) {\n                            if (!bestFeature || f.min > bestFeature.min ||\n                                (f.min == bestFeature.min && f.max < bestFeature.max)) {\n                                bestFeature = f;\n                            }\n                        } else if (f.max < pos) {\n                            if (!bestFeature || f.max > bestFeature.max || \n                                (f.max == bestFeature.max && f.min < bestFeature.min) ||\n                                (f.min == bestFeature.mmin && bestFeature.max >= pos)) {\n                                bestFeature = f;\n                            } \n                        }\n                    } else {\n                        if (fedge == 1 && f.min <= pos && f.max > pos) {\n                            if (!bestFeature || f.max < bestFeature.max ||\n                                (f.max == bestFeature.max && f.min > bestFeature.min)) {\n                                bestFeature = f;\n                            }\n                        } else if (f.min > pos) {\n                            if (!bestFeature || f.min < bestFeature.min ||\n                                (f.min == bestFeature.min && f.max > bestFeature.max) ||\n                                (f.max == bestFeature.max && bestFeature.min <= pos)) {\n                                bestFeature = f;\n                            }\n                        }\n                    }\n                }\n                if (bestFeature) {\n                    return callback(bestFeature);\n                }\n                if (dir < 0) {\n                    pos = this.browser.knownSpace.min;\n                } else {\n                    pos = this.browser.knownSpace.max;\n                }\n            }\n        }\n\n        this.trySourceFNF(chr, pos, dir, callback);\n    }\n}\n\nDasTier.prototype.trySourceFNF = function(chr, pos, dir, callback) {\n    var self = this;\n    this.featureSource.findNextFeature(chr, pos, dir, function(feature) {\n        if (!feature)\n            callback(feature);\n\n        var ss = self.browser.getSequenceSource();\n        if (!ss) // We're probably in trouble, but return anyway.\n            callback(feature)\n\n        ss.getSeqInfo(feature.segment, function(si) {\n            if (si)\n                callback(feature);\n            else\n                self.trySourceFNF(feature.segment, dir > 0 ? 10000000000 : 0, dir, callback);\n        });\n    });\n}\n\n\nDasTier.prototype.updateLabel = function() {\n   this.bumpButton.className = this.bumped ? 'fa fa-minus-circle' : 'fa fa-plus-circle';\n   if (this.dasSource.collapseSuperGroups) {\n        this.bumpButton.style.display = 'inline-block';\n    } else {\n        this.bumpButton.style.display = 'none';\n    }\n}\n\nDasTier.prototype.updateHeight = function() {\n    this.currentHeight = Math.max(Math.max(this.layoutHeight, this.label.clientHeight + 2), this.browser.minTierHeight);\n    this.row.style.height = '' + this.currentHeight + 'px';\n    this.browser.updateHeight();\n }\n\n\nDasTier.prototype.drawOverlay = function() {\n    var t = this;\n    var b = this.browser;\n    var retina = b.retina && window.devicePixelRatio > 1;\n    \n    t.overlay.height = t.viewport.height;\n    t.overlay.width = retina ? b.featurePanelWidth * 2 : b.featurePanelWidth;\n\n    var g = t.overlay.getContext('2d');\n    if (retina) {\n        g.scale(2, 2);\n    }\n    \n    var origin = b.viewStart;\n    var visStart = b.viewStart;\n    var visEnd = b.viewEnd;\n\n    if (this.overlayLabelCanvas) {\n        var offset = ((this.glyphCacheOrigin - this.browser.viewStart)*this.browser.scale);\n        g.save();\n        g.translate(offset, 0);\n        var drawStart = -offset + 2;\n        if (this.dasSource.tierGroup)\n            drawStart += 15;\n        this.overlayLabelCanvas.draw(g, drawStart, b.featurePanelWidth-offset);\n        g.restore();\n    }\n\n    for (var hi = 0; hi < b.highlights.length; ++hi) {\n        var h = b.highlights[hi];\n        if (((h.chr === b.chr) || (h.chr === ('chr' + b.chr))) && h.min < visEnd && h.max > visStart) {\n            g.globalAlpha = b.defaultHighlightAlpha;\n            g.fillStyle = b.defaultHighlightFill;\n            g.fillRect((h.min - origin) * b.scale,\n                       0,\n                       (h.max - h.min) * b.scale,\n                       t.overlay.height);\n        }\n    } \n\n    // t.oorigin = b.viewStart;\n    t.overlay.style.width = b.featurePanelWidth;\n    t.overlay.style.height = t.viewport.style.height;\n    t.overlay.style.left = '0px';\n}\n\n\nDasTier.prototype.updateStatus = function(status) {\n    var self = this;\n    if (status) {\n        this.status = status;\n        this._notifierToStatus();\n        var sd = sourceDataURI(this.dasSource);\n        if (window.location.protocol === 'https:' && sourceDataURI(this.dasSource).indexOf('http:') == 0 && !this.checkedHTTP) {\n            this.checkedHTTP = true;\n            this.browser.canFetchPlainHTTP().then(\n                function(can) {\n                    if (!can) {\n                        self.warnHTTP = true;\n                        self._notifierToStatus();\n                    }\n                }\n            );\n        }\n    } else {\n        if (this.status) {\n            this.status = null\n            this._notifierToStatus();\n        }\n    }\n}\n\nDasTier.prototype.notify = function(message, timeout) {\n    if (typeof(timeout) !== 'number')\n        timeout = 2000;\n\n    if (this.notifierFadeTimeout) {\n        clearTimeout(this.notifierFadeTimeout);\n        this.notifierFadeTimeout = null;\n    }\n\n    if (message) {\n        this._notifierOn(message);\n        if (timeout > 0) {\n            var thisB = this;\n            this.notifierFadeTimeout = setTimeout(function() {\n                thisB._notifierToStatus();\n            }, timeout);\n        }\n    } else {\n        this._notifierToStatus();\n    }\n}\n\nDasTier.prototype._notifierOn = function(message, warnHTTP) {\n    removeChildren(this.notifier);\n    if (warnHTTP) {\n        this.notifier.appendChild(\n            makeElement(\n                'span',\n                [makeElement('a', '[HTTP Warning] ', {href: this.browser.httpWarningURL, target: \"_blank\"}),\n                 message]\n            )\n        );\n    } else {\n        this.notifier.textContent = message;\n    }\n    this.notifier.style.opacity = 0.8;\n}\n\nDasTier.prototype._notifierOff = function() {\n    this.notifier.style.opacity = 0;\n}\n\nDasTier.prototype._notifierToStatus = function() {\n    if (this.status) {\n        this._notifierOn(this.status, this.warnHTTP)\n    } else {\n        this._notifierOff();\n    }\n}\n\nDasTier.prototype.setConfig = function(config) {\n    this.config = config || {};\n    this._updateFromConfig();\n    this.notifyTierListeners();\n}\n\nDasTier.prototype.mergeStylesheet = function(newStyle) {\n    this.mergeConfig({\n        stylesheet: newStyle, \n        stylesheetValidity: this.baseStylesheetValidity\n    });\n}\n\nDasTier.prototype.mergeConfig = function(newConfig) {\n    for (var k in newConfig) {\n        this.config[k] = newConfig[k];\n    }\n    this._updateFromConfig();\n    this.notifyTierListeners();\n}\n\nDasTier.prototype._updateFromConfig = function() {\n    var needsRefresh = false;\n    var needsReorder = false;\n\n    if (typeof this.config.name === 'string')\n        this.nameElement.textContent = this.config.name;\n    else\n        this.nameElement.textContent = this.dasSource.name;\n\n    var wantedHeight = this.config.height || this.dasSource.forceHeight;\n    if (wantedHeight != this.forceHeight) {\n        this.forceHeight = wantedHeight;\n        needsRefresh = true;\n    }\n\n    if (this.forceMinDynamic != this.config.forceMinDynamic) {\n        this.forceMinDynamic = this.config.forceMinDynamic;\n        needsRefresh = true;\n    }\n\n    var forceMin = this.config.forceMin != undefined ? this.config.forceMin : this.dasSource.forceMin;\n    if (this.forceMin != forceMin) {\n        this.forceMin = forceMin;\n        needsRefresh = true;\n    }\n\n    if (this.forceMaxDynamic != this.config.forceMaxDynamic) {\n        this.forceMaxDynamic = this.config.forceMaxDynamic;\n        needsRefresh = true;\n    }\n    \n    var forceMax = this.config.forceMax != undefined ? this.config.forceMax : this.dasSource.forceMax;\n    if (this.forceMax != forceMax) {\n        this.forceMax = forceMax;\n        needsRefresh = true;\n    }\n\n    var quantLeapThreshold = null;\n    if (this.config.quantLeapThreshold !== undefined)\n        quantLeapThreshold = this.config.quantLeapThreshold;\n    else if (this.dasSource.quantLeapThreshold !== undefined)\n        quantLeapThreshold = this.dasSource.quantLeapThreshold;\n    if (quantLeapThreshold != this.quantLeapThreshold) {\n        this.quantLeapThreshold = quantLeapThreshold;\n        needsRefresh = true;\n    }\n    \n    // Possible FIXME -- are there cases where style IDs need to be reassigned?\n    var stylesheet = null;\n    if (this.config.stylesheetValidity == this.baseStylesheetValidity)\n        stylesheet = this.config.stylesheet;\n    stylesheet = stylesheet || this.baseStylesheet;\n    if (this.stylesheet !== stylesheet) {\n        this.stylesheet = stylesheet;\n        needsRefresh = true;\n    }\n\n    var wantedPinned = this.config.pinned !== undefined ? this.config.pinned : this.dasSource.pinned;\n    if (wantedPinned !== this.pinned) {\n        this.pinned = wantedPinned;\n        needsReorder = true;\n    }\n\n    var wantedSubtierMax = (typeof(this.config.subtierMax === 'number') ? \n        this.config.subtierMax : this.dasSource.subtierMax || this.browser.defaultSubtierMax);\n    if (wantedSubtierMax != this.subtierMax) {\n        this.subtierMax = wantedSubtierMax;\n        needsRefresh = true;\n    }\n\n    var wantedBumped;\n    if (this.config.bumped !== undefined) {\n        wantedBumped = this.config.bumped;\n    } else if (this.dasSource.bumped !== undefined) {\n        wantedBumped = this.dasSource.bumped;\n    } else {\n        wantedBumped = this.dasSource.collapseSuperGroups ? false : true;\n    }\n    if (wantedBumped !== this.bumped) {\n        this.bumped = wantedBumped;\n        needsRefresh = true;\n        this.updateLabel();\n    }\n\n    if (needsRefresh)\n        this.scheduleRedraw();\n\n    if (needsReorder)\n        this.browser.reorderTiers();\n}\n\nDasTier.prototype.scheduleRedraw = function() {\n    if (!this.currentFeatures)\n        return;\n    \n    var tier = this;\n\n    if (!this.redrawTimeout) {\n        this.redrawTimeout = setTimeout(function() {\n            tier.draw();\n            tier.redrawTimeout = null;\n        }, 10);\n    }\n}\nDasTier.prototype.clearTierListeners = function() {\n\tthis.listeners = [];\n}\n\n\nDasTier.prototype.addTierListener = function(l) {\n    this.listeners.push(l);\n}\n\nDasTier.prototype.removeTierListener = function(l) {\n    var idx = arrayIndexOf(this.listeners, l);\n    if (idx >= 0) {\n        this.listeners.splice(idx, 1);\n    }\n}\n\nDasTier.prototype.notifyTierListeners = function(change) {\n    for (var li = 0; li < this.listeners.length; ++li) {\n        try {\n            this.listeners[li](change);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n    this.browser.notifyTier();\n}\n\nDasTier.prototype.clearFeaturesLoadedListeners = function() {\n  this.featuresLoadedListeners = [];\n}\n\nDasTier.prototype.addFeaturesLoadedListener = function(handler) {\n    this.featuresLoadedListeners.push(handler);\n}\n\nDasTier.prototype.removeFeaturesLoadedListener = function(handler) {\n    var idx = arrayIndexOf(this.featuresLoadedListeners, handler);\n    if (idx >= 0) {\n        this.featuresLoadedListeners.splice(idx, 1);\n    }\n}\n\n\nDasTier.prototype.notifyFeaturesLoaded = function() {\n    for (var li = 0; li < this.featuresLoadedListeners.length; ++li) {\n        try {\n            this.featuresLoadedListeners[li].call(this);\n        } catch (e) {\n            console.log(e);\n        }\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        DasTier: DasTier\n    };\n\n    // Imported for side effects\n    var fd = require('./feature-draw');\n    var drawFeatureTier = fd.drawFeatureTier;\n    var sd = require('./sequence-draw');\n    var drawSeqTier = sd.drawSeqTier;\n    // require('./sourceadapters');  /* Done in cbrowser instead */\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// track-adder.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var browser = require('./cbrowser');\n    var Browser = browser.Browser;\n\n    var sc = require('./sourcecompare');\n    var sourcesAreEqual = sc.sourcesAreEqual;\n\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n    var removeChildren = utils.removeChildren;\n    var Observed = utils.Observed;\n\n    var thub = require('./thub');\n    var THUB_COMPARE = thub.THUB_COMPARE;\n    var connectTrackHub = thub.connectTrackHub;\n\n    var domui = require('./domui');\n    var makeTreeTableSection = domui.makeTreeTableSection;\n\n    var probeResource = require('./probe').probeResource;\n\n\n    // Most of this could disappear if we leave all probing to the probe module...\n    var bin = require('./bin');\n    var URLFetchable = bin.URLFetchable;\n    var BlobFetchable = bin.BlobFetchable;\n    var readInt = bin.readInt;\n\n    var lh3utils = require('./lh3utils');\n    var unbgzf = lh3utils.unbgzf;\n\n    var bam = require('./bam');\n    var BAM_MAGIC = bam.BAM_MAGIC;\n    var BAI_MAGIC = bam.BAI_MAGIC;\n\n    var tbi = require('./tabix');\n    var TABIX_MAGIC = tbi.TABIX_MAGIC;\n\n    var das = require('./das');\n    var DASSource = das.DASSource;\n    var DASSegment = das.DASSegment;\n    var DASRegistry = das.DASRegistry;\n    var coordsMatch = das.coordsMatch;\n\n    var EncodeFetchable = require('./encode').EncodeFetchable;\n}\n\nBrowser.prototype.currentlyActive = function(source) {\n    for (var ti = 0; ti < this.tiers.length; ++ti) {\n        if (sourcesAreEqual(this.tiers[ti].dasSource, source))\n            return this.tiers[ti];\n    }\n    return false;\n}\n\nBrowser.prototype.makeButton = function(name, tooltip) {\n    var regButton = makeElement('a', name, {href: '#'});\n    if (tooltip) {\n        this.makeTooltip(regButton, tooltip);\n    }\n    return makeElement('li', regButton);\n}\n\nfunction activateButton(addModeButtons, which) {\n    for (var i = 0; i < addModeButtons.length; ++i) {\n        var b = addModeButtons[i];\n        if (b === which) {\n            b.classList.add('active');\n        } else {\n            b.classList.remove('active');\n        }\n    }\n}\n\nBrowser.prototype.showTrackAdder = function(ev) {\n    if (this.uiMode === 'add') {\n        this.hideToolPanel();\n        this.setUiMode('none');\n        return;\n    }\n\n    var thisB = this;\n\n    var popup = makeElement('div', null, {className: 'dalliance'} , {width: '100%', display: 'inline-block', boxSizing: 'border-box', MozBoxSizing: 'border-box', verticalAlign: 'top', paddingRight: '15px'});\n\n    var addModeButtons = [];\n    var makeStab, makeStabObserver;\n\n\n    if (!this.noRegistryTabs) {\n        var regButton = this.makeButton('Registry', 'Browse compatible datasources from the DAS registry');\n        addModeButtons.push(regButton);\n        \n        for (var m in this.mappableSources) {\n            var mf  = function(mm) {\n                var mapButton = thisB.makeButton(thisB.chains[mm].srcTag, 'Browse datasources mapped from ' + thisB.chains[mm].srcTag);\n                addModeButtons.push(mapButton);\n                mapButton.addEventListener('click', function(ev) {\n                    ev.preventDefault(); ev.stopPropagation();\n                    activateButton(addModeButtons, mapButton);\n                    makeStab(thisB.mappableSources[mm], mm);\n                }, false);\n            }; mf(m);\n        }\n    }\n\n    var groupedDefaults = {};\n    for (var si = 0; si < this.defaultSources.length; ++si) {\n        var s = this.defaultSources[si];\n        var g = s.group || 'Defaults';\n        if (groupedDefaults[g]) {\n            groupedDefaults[g].push(s);\n        } else {\n            groupedDefaults[g] = [s];\n        }\n    }\n    \n\n    var makeHubButton = function(tdb) {\n        var hub = tdb.hub;\n        var hubMenuButton = makeElement('i', null, {className: 'fa fa-list-alt'}, {cursor: 'context-menu'});\n        var label = hub.altLabel || hub.shortLabel || 'Unknown';\n        if (tdb.mapping)\n            label = label + ' (' + tdb.genome + ')';\n        var hbContent = makeElement('span', [label, ' ', hubMenuButton]);\n        var hubButton = thisB.makeButton(hbContent, hub.longLabel);\n        hubButton.hub = tdb;\n        addModeButtons.push(hubButton);\n        \n        hubButton.addEventListener('click', function(ev) {\n            ev.preventDefault(); ev.stopPropagation();\n            activateButton(addModeButtons, hubButton);\n            removeChildren(stabHolder);\n            var loader = thisB.makeLoader(24);\n            loader.style.marginLeft = 'auto';\n            loader.style.marginRight = 'auto';\n            loader.style.marginTop = '100px';\n            stabHolder.appendChild(makeElement('div', loader, null, {textAlign: 'center'}));\n\n            refreshButton.style.display = 'none';\n            addButton.style.display = 'none';\n            canButton.style.display = 'none';\n\n            tdb.getTracks(function(tracks, err) {\n                if (err) {\n                    console.log(err);\n                }\n                \n                makeHubStab(tracks);\n            });\n        }, false);\n\n        hubMenuButton.addEventListener('click', function(ev) {\n            ev.preventDefault(); ev.stopPropagation();\n            \n            var removeHubItem = makeElement('li', makeElement('a', 'Remove hub'));\n            var allOnItem = makeElement('li',  makeElement('a', 'Enable all'));\n            var allOffItem = makeElement('li',  makeElement('a', 'Disable all'));\n            var hubMenu = makeElement('ul', [removeHubItem, allOnItem, allOffItem], {className: 'dropdown-menu'}, {display: 'block'});\n\n            var mx =  ev.clientX, my = ev.clientY;\n            mx +=  document.documentElement.scrollLeft || document.body.scrollLeft;\n            my +=  document.documentElement.scrollTop || document.body.scrollTop;\n\n            hubMenu.style.position = 'absolute';\n            hubMenu.style.top = '' + (my+10) + 'px';\n            hubMenu.style.left = '' + (mx-30) + 'px';\n            thisB.hPopupHolder.appendChild(hubMenu);\n\n            var clickCatcher = function(ev) {\n                console.log('cc');\n                document.body.removeEventListener('click', clickCatcher, true);\n                thisB.hPopupHolder.removeChild(hubMenu);\n            };\n            document.body.addEventListener('click', clickCatcher, true);\n\n            removeHubItem.addEventListener('click', function(ev) {\n                for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {\n                    if (thisB.hubObjects[hi].absURL == tdb.absURL) {\n                        thisB.hubObjects.splice(hi, 1);\n                        break;\n                    }\n                }\n                for (var hi = 0; hi < thisB.hubs.length; ++hi) {\n                    var hc = thisB.hubs[hi];\n                    if (typeof hc === 'string')\n                        hc = {url: hc};\n                    if (hc.url == tdb.hub.url && !hc.genome || hc.genome == tdb.genome) {\n                        thisB.hubs.splice(hi, 1);\n                        break;\n                    }\n\n                }\n\n                thisB.notifyTier();\n\n                modeButtonHolder.removeChild(hubButton);\n                activateButton(addModeButtons, addHubButton);\n                switchToHubConnectMode();\n            }, false);\n\n\n            allOnItem.addEventListener('click', function(ev) {\n                tdb.getTracks(function(tracks, err) {\n                    if (err) {\n                        console.log(err);\n                    }\n                    \n                    for (var ti = 0; ti < tracks.length; ++ti) {\n                        var ds = tracks[ti].toDallianceSource();\n                        if (!thisB.currentlyActive(ds)) {\n                            thisB.addTier(ds);\n                        }\n                    }\n                });\n            }, false);\n\n            allOffItem.addEventListener('click', function(ev) {\n                tdb.getTracks(function(tracks, err) {\n                    if (err) {\n                        console.log(err);\n                    }\n                    \n                    for (var ti = 0; ti < tracks.length; ++ti) {\n                        var ds = tracks[ti].toDallianceSource();\n                        if (thisB.currentlyActive(ds)) {\n                            thisB.removeTier(ds);\n                        }\n                    }\n                });\n            }, false);\n        }, false);\n\n        return hubButton;\n    }\n\n    var firstDefButton = null;\n    var firstDefSources = null;\n    for (var g in groupedDefaults) {\n        (function(g, ds) {\n            var defButton = thisB.makeButton(g, 'Browse the default set of data for this browser');\n            defButton.addEventListener('click', function(ev) {\n                ev.preventDefault(); ev.stopPropagation();\n                activateButton(addModeButtons, defButton);\n                makeStab(new Observed(ds));\n            }, false);\n            addModeButtons.push(defButton);\n\n            if (!firstDefButton) {\n                firstDefButton = defButton;\n                firstDefSources = ds;\n            }\n        })(g, groupedDefaults[g]);\n    }   \n    var custButton = this.makeButton('DAS', 'Add arbitrary DAS data');\n    addModeButtons.push(custButton);\n    var binButton = this.makeButton('Binary', 'Add data in bigwig or bigbed format');\n    addModeButtons.push(binButton);\n\n\n    for (var hi = 0; hi < this.hubObjects.length; ++hi) {\n        var hub = this.hubObjects[hi];\n        makeHubButton(hub);\n    }\n\n    var addHubButton = this.makeButton('+', 'Connect to a new track-hub');\n    addModeButtons.push(addHubButton);\n\n\n    var modeButtonHolder = makeElement('ul', addModeButtons, {className: 'nav nav-tabs'}, {marginBottom: '0px'});\n    popup.appendChild(modeButtonHolder);\n    \n    var custURL, custName, custCS, custQuant, custFile, custUser, custPass;\n    var customMode = false;\n    var dataToFinalize = null;\n\n    var asform = makeElement('form', null, {}, {display: 'inline-block', width: '100%'});\n    asform.addEventListener('submit', function(ev) {\n            ev.stopPropagation(); ev.preventDefault();\n            doAdd();\n            return false;\n    }, true); \n    var stabHolder = makeElement('div');\n    stabHolder.style.position = 'relative';\n    stabHolder.style.overflow = 'scroll';\n    // stabHolder.style.height = '500px';\n    asform.appendChild(stabHolder);\n\n    var __mapping;\n    var __sourceHolder;\n\n\n    makeStab = function(msources, mapping) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'none';\n        canButton.style.display = 'none';\n        if (__sourceHolder) {\n            __sourceHolder.removeListener(makeStabObserver);\n        }\n        __mapping = mapping;\n        __sourceHolder = msources;\n        __sourceHolder.addListenerAndFire(makeStabObserver);\n    }\n\n    makeStabObserver = function(msources) {\n        customMode = false;\n        var buttons = [];\n        removeChildren(stabHolder);\n        if (!msources) {\n            stabHolder.appendChild(makeElement('p', 'Dalliance was unable to retrieve data source information from the DAS registry, please try again later'));\n            return;\n        }\n        \n        var stabBody = makeElement('tbody', null, {className: 'table table-striped table-condensed'}, {width: '100%'});\n        var stab = makeElement('table', stabBody, {className: 'table table-striped table-condensed'}, {width: '100%', tableLayout: 'fixed'}); \n        var idx = 0;\n\n        var sources = [];\n        for (var i = 0; i < msources.length; ++i) {\n            sources.push(msources[i]);\n        }\n        \n        sources.sort(function(a, b) {\n            return a.name.toLowerCase().trim().localeCompare(b.name.toLowerCase().trim());\n        });\n\n        for (var i = 0; i < sources.length; ++i) {\n            var source = sources[i];\n            var r = makeElement('tr');\n\n            var bd = makeElement('td', null, {}, {width: '30px'});\n            bd.style.textAlign = 'center';\n            if (!source.props || source.props.cors) {\n                var b = makeElement('input');\n                b.type = 'checkbox';\n                b.dalliance_source = source;\n                if (__mapping) {\n                    b.dalliance_mapping = __mapping;\n                }\n                // b.checked = thisB.currentlyActive(source);\n                bd.appendChild(b);\n                buttons.push(b);\n                b.addEventListener('change', function(ev) {\n                    if (ev.target.checked) {\n                        thisB.addTier(ev.target.dalliance_source);\n                    } else {\n                        thisB.removeTier(ev.target.dalliance_source);\n                    }\n                });\n            } else {\n                bd.appendChild(document.createTextNode('!'));\n                thisB.makeTooltip(bd, makeElement('span', [\"This data source isn't accessible because it doesn't support \", makeElement('a', \"CORS\", {href: 'http://www.w3.org/TR/cors/'}), \".\"]));\n            }\n            r.appendChild(bd);\n            var ld = makeElement('td');\n            ld.appendChild(document.createTextNode(source.name));\n            if (source.desc && source.desc.length > 0) {\n                thisB.makeTooltip(ld, source.desc);\n            }\n            r.appendChild(ld);\n            stabBody.appendChild(r);\n            ++idx;\n        }\n\n        var setChecks = function() {\n            for (var bi = 0; bi < buttons.length; ++bi) {\n                var b = buttons[bi];\n                var t = thisB.currentlyActive(b.dalliance_source);\n                if (t) {\n                    b.checked = true;\n                } else {\n                    b.checked = false;\n                }\n            }\n        }\n        setChecks();\n        thisB.addTierListener(function(l) {\n            setChecks();\n        });\n\n        stabHolder.appendChild(stab);\n    };\n\n    function makeHubStab(tracks) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'none';\n        canButton.style.display = 'none';\n\n        customMode = false;\n        removeChildren(stabHolder);\n        \n        var ttab = makeElement('div', null, {}, {width: '100%'});\n        var sources = [];\n        for (var i = 0; i < tracks.length; ++i) {\n            sources.push(tracks[i]);\n        }\n        \n        sources.sort(function(a, b) {\n            return a.shortLabel.toLowerCase().trim().localeCompare(b.shortLabel.toLowerCase().trim());\n        });\n\n        var groups = [];\n        var tops = [];\n        \n        for (var ti = 0; ti < sources.length; ++ti) {\n            var track = sources[ti];\n            if (track.children && track.children.length > 0 && track.container != 'multiWig') {\n                groups.push(track);\n            } else {\n                tops.push(track);\n            }\n        }\n        if (tops.length > 0) {\n            groups.push({\n                shortLabel: 'Others',\n                priority: -100000000,\n                children: tops});\n        }\n\n        groups.sort(THUB_COMPARE);\n        \n        var buttons = [];\n        for (var gi = 0; gi < groups.length; ++gi) {\n            var group = groups[gi];\n            var dg = group;\n            if (!dg.dimensions && dg._parent && dg._parent.dimensions)\n                dg = dg._parent;\n\n            var dprops = {}\n            if (dg.dimensions) {\n                var dtoks = dg.dimensions.split(/(\\w+)=(\\w+)/);\n                for (var dti = 0; dti < dtoks.length - 2; dti += 3) {\n                    dprops[dtoks[dti + 1]] = dtoks[dti + 2];\n                }\n            }\n\n            if (dprops.dimX && dprops.dimY) {\n                var dimX = dprops.dimX, dimY = dprops.dimY;\n                var sgX = dg.subgroups[dimX];\n                var sgY = dg.subgroups[dimY];\n                \n                var trks = {};\n                for (var ci = 0; ci < group.children.length; ++ci) {\n                    var child = group.children[ci];\n                    var vX = child.sgm[dimX], vY = child.sgm[dimY];\n                    if (!trks[vX])\n                        trks[vX] = {};\n                    trks[vX][vY] = child;\n                }\n\n                var matrix = makeElement('table', null, {className: 'table table-striped table-condensed'}, {tableLayout: 'fixed'});\n                {\n                    var header = makeElement('tr');\n                    header.appendChild(makeElement('th', null, {}, {width: '150px', height: '100px'}));   // blank corner element\n                    for (var si = 0; si < sgX.titles.length; ++si) {\n                        var h = makeElement('th', makeElement('div', sgX.titles[si], {}, {transform: 'rotate(-60deg)', \n                                                                       transformOrigin: '0% 100%', \n                                                                       webkitTransform: 'rotate(-60deg) translate(20px,10px)', \n                                                                       webkitTransformOrigin: '0% 100%',\n                                                                       textAlign: 'left'}), {}, {width: '35px',\n                                                                                                 height: '100px',\n                                                                                                 verticalAlign: 'bottom'})\n                        header.appendChild(h);\n                    }\n                    matrix.appendChild(header);\n                }\n\n                var mbody = makeElement('tbody', null, {className: 'table table-striped table-condensed'})\n                for (var yi = 0; yi < sgY.titles.length; ++yi) {\n                    var vY = sgY.tags[yi];\n                    var row = makeElement('tr');\n                    row.appendChild(makeElement('th', sgY.titles[yi]), {});\n                    \n                    for (var xi = 0; xi < sgX.titles.length; ++xi) {\n                        var vX = sgX.tags[xi];\n                        var cell = makeElement('td');\n                        if (trks[vX] && trks[vX][vY]) {\n                            var track = trks[vX][vY];\n                            var ds = track.toDallianceSource();\n                            if (!ds)\n                                continue;\n                            \n                            var r = makeElement('tr');\n                            var bd = makeElement('td');\n                            bd.style.textAlign = 'center';\n                            \n                            var b = makeElement('input');\n                            b.type = 'checkbox';\n                            b.dalliance_source = ds;\n                            if (__mapping) {\n                                b.dalliance_mapping = __mapping;\n                            }\n                            buttons.push(b);\n                            cell.appendChild(b);\n                            b.addEventListener('change', function(ev) {\n                                if (ev.target.checked) {\n                                    thisB.addTier(ev.target.dalliance_source);\n                                } else {\n                                    thisB.removeTier(ev.target.dalliance_source);\n                                }\n                            });\n\n                        }\n                        row.appendChild(cell);\n                    } \n                    mbody.appendChild(row);\n                }\n                matrix.appendChild(mbody);\n                ttab.appendChild(makeTreeTableSection(group.shortLabel, matrix, gi==0));                \n            } else {\n                var stabBody = makeElement('tbody', null, {className: 'table table-striped table-condensed'});\n                var stab = makeElement('table', stabBody, {className: 'table table-striped table-condensed'}, {width: '100%', tableLayout: 'fixed'}); \n                var idx = 0;\n            \n                group.children.sort(THUB_COMPARE);\n                for (var i = 0; i < group.children.length; ++i) {\n                    var track = group.children[i];\n                    var ds = track.toDallianceSource();\n                    if (!ds)\n                        continue;\n\n                    var r = makeElement('tr');\n                    var bd = makeElement('td', null, {}, {width: '30px'});\n                    bd.style.textAlign = 'center';\n                    \n                    var b = makeElement('input');\n                    b.type = 'checkbox';\n                    b.dalliance_source = ds;\n                    if (__mapping) {\n                        b.dalliance_mapping = __mapping;\n                    }\n                    buttons.push(b);\n                    bd.appendChild(b);\n                    b.addEventListener('change', function(ev) {\n                        if (ev.target.checked) {\n                            thisB.addTier(ev.target.dalliance_source);\n                        } else {\n                            thisB.removeTier(ev.target.dalliance_source);\n                        }\n                    });\n\n                    r.appendChild(bd);\n                    var ld = makeElement('td');\n                    ld.appendChild(document.createTextNode(track.shortLabel));\n                    if (track.longLabel && track.longLabel.length > 0) {\n                        thisB.makeTooltip(ld, track.longLabel);\n                    }\n                    r.appendChild(ld);\n                    stabBody.appendChild(r);\n                    ++idx;\n                }\n\n                if (groups.length > 1 || group.shortLabel !== 'Others') {\n                    ttab.appendChild(makeTreeTableSection(group.shortLabel, stab, gi==0));\n                } else {\n                    ttab.appendChild(stab);\n                }\n                \n            }\n        }\n\n        var setChecks = function() {\n            for (var bi = 0; bi < buttons.length; ++bi) {\n                var b = buttons[bi];\n                var t = thisB.currentlyActive(b.dalliance_source);\n                if (t) {\n                    b.checked = true;\n                    b.disabled = t.sequenceSource != null;\n                } else {\n                    b.checked = false;\n                }\n            }\n        }\n        setChecks();\n        thisB.addTierListener(function(l) {\n            setChecks();\n        });\n        \n        stabHolder.appendChild(ttab);\n    }\n\n    if (regButton) {\n        regButton.addEventListener('click', function(ev) {\n            ev.preventDefault(); ev.stopPropagation();\n            activateButton(addModeButtons, regButton);\n            makeStab(thisB.availableSources);\n        }, false);\n    }\n \n    binButton.addEventListener('click', function(ev) {\n        ev.preventDefault(); ev.stopPropagation();\n        switchToBinMode();\n    }, false);\n    addHubButton.addEventListener('click', function(ev) {\n        ev.preventDefault(); ev.stopPropagation();\n        switchToHubConnectMode();\n    }, false);\n\n\n    function switchToBinMode() {\n        activateButton(addModeButtons, binButton);\n        customMode = 'bin';\n\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'none';\n\n        removeChildren(stabHolder);\n        var pageHolder = makeElement('div', null, {}, {paddingLeft: '10px', paddingRight: '10px'});\n        pageHolder.appendChild(makeElement('h3', 'Add custom URL-based data'));\n        pageHolder.appendChild(makeElement('p', ['You can add indexed binary data hosted on an web server that supports CORS (', makeElement('a', 'full details', {href: 'http://www.biodalliance.org/bin.html'}), ').  Currently supported formats are bigwig, bigbed, and indexed BAM.']));\n\n        pageHolder.appendChild(makeElement('br'));\n        pageHolder.appendChild(document.createTextNode('URL: '));\n        custURL = makeElement('input', '', {size: 80, value: 'http://www.biodalliance.org/datasets/ensGene.bb'}, {width: '100%'});\n        pageHolder.appendChild(custURL);\n        \n        pageHolder.appendChild(makeElement('br'));\n        pageHolder.appendChild(makeElement('b', '- or -'));\n        pageHolder.appendChild(makeElement('br'));\n        pageHolder.appendChild(document.createTextNode('File: '));\n        custFile = makeElement('input', null, {type: 'file', multiple: 'multiple'});\n        pageHolder.appendChild(custFile);\n        \n        pageHolder.appendChild(makeElement('p', 'Clicking the \"Add\" button below will initiate a series of test queries.'));\n\n        stabHolder.appendChild(pageHolder);\n        custURL.focus();\n    }\n\n    function switchToHubConnectMode() {\n        activateButton(addModeButtons, addHubButton);\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'none';\n\n        customMode = 'hub-connect';\n        refreshButton.style.visibility = 'hidden';\n\n        removeChildren(stabHolder);\n\n        var pageHolder = makeElement('div', null, {}, {paddingLeft: '10px', paddingRight: '10px'});\n        pageHolder.appendChild(makeElement('h3', 'Connect to a track hub.'));\n        pageHolder.appendChild(makeElement('p', ['Enter the top-level URL (usually points to a file called \"hub.txt\") of a UCSC-style track hub']));\n        \n        custURL = makeElement('input', '', {size: 120, value: 'http://www.biodalliance.org/datasets/testhub/hub.txt'}, {width: '100%'});\n        pageHolder.appendChild(custURL);\n        \n        stabHolder.appendChild(pageHolder);\n        \n        custURL.focus();\n    }\n\n    custButton.addEventListener('click', function(ev) {\n        ev.preventDefault(); ev.stopPropagation();\n        switchToCustomMode();\n    }, false);\n\n    function switchToCustomMode() {\n        activateButton(addModeButtons, custButton);\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'none';\n\n        customMode = 'das';\n\n        removeChildren(stabHolder);\n\n        var customForm = makeElement('div', null, {},  {paddingLeft: '10px', paddingRight: '10px'});\n        customForm.appendChild(makeElement('h3', 'Add custom DAS data'));\n        customForm.appendChild(makeElement('p', 'This interface is intended for adding custom or lab-specific data.  Public data can be added more easily via the registry interface.'));\n                \n        customForm.appendChild(document.createTextNode('URL: '));\n        customForm.appendChild(makeElement('br'));\n        custURL = makeElement('input', '', {size: 80, value: 'http://www.derkholm.net:8080/das/medipseq_reads/'}, {width: '100%'});\n        customForm.appendChild(custURL);\n\n        customForm.appendChild(makeElement('p', 'Clicking the \"Add\" button below will initiate a series of test queries.  If the source is password-protected, you may be prompted to enter credentials.'));\n        stabHolder.appendChild(customForm);\n\n        custURL.focus();\n    }\n\n\n\n    var addButton = makeElement('button', 'Add', {className: 'btn btn-primary'});\n    addButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        doAdd();\n    }, false);\n\n    function doAdd() {\n        if (customMode) {\n            if (customMode === 'das') {\n                var curi = custURL.value.trim();\n                if (!/^.+:\\/\\//.exec(curi)) {\n                    curi = 'http://' + curi;\n                }\n                var nds = new DASSource({name: 'temporary', uri: curi});\n                tryAddDAS(nds);\n            } else if (customMode === 'bin') {\n                var fileList = custFile.files;\n\n                if (fileList && fileList.length > 0) {\n                    tryAddMultiple(fileList);\n                } else {\n                    var curi = custURL.value.trim();\n                    if (!/^.+:\\/\\//.exec(curi)) {\n                        curi = 'http://' + curi;\n                    }\n                    var source = {uri: curi};\n                    var lcuri = curi.toLowerCase();\n                    if (lcuri.indexOf(\"https://www.encodeproject.org/\") == 0 &&\n                        lcuri.indexOf(\"@@download\") >= 0) \n                    {\n                        source.transport = 'encode';\n                    }\n                    tryAddBin(source);\n                }\n            } else if (customMode === 'reset') {\n                switchToCustomMode();\n            } else if (customMode === 'reset-bin') {\n                switchToBinMode(); \n            } else if (customMode === 'reset-hub') {\n                switchToHubConnectMode();\n            } else if (customMode === 'prompt-bai') {\n                var fileList = custFile.files;\n                if (fileList && fileList.length > 0 && fileList[0]) {\n                    dataToFinalize.baiBlob = fileList[0];\n                    completeBAM(dataToFinalize);\n                } else {\n                    promptForBAI(dataToFinalize);\n                }\n            } else if (customMode === 'prompt-tbi') {\n                var fileList = custFile.files;\n                if (fileList && fileList.length > 0 && fileList[0]) {\n                    dataToFinalize.indexBlob = fileList[0];\n                    completeTabixVCF(dataToFinalize);\n                } else {\n                    promptForTabix(dataToFinalize);\n                }\n            } else if (customMode === 'finalize' || customMode === 'finalize-bin') {\n                dataToFinalize.name = custName.value;\n                var m = custCS.value;\n                if (m != '__default__') {\n                    dataToFinalize.mapping = m;\n                } else {\n                    dataToFinalize.mapping = undefined;\n                }\n                if (custQuant) {\n                    dataToFinalize.maxbins = custQuant.checked;\n                }\n\n                if (custUser.value.length > 1 && custPass.value.length > 1) {\n                    dataToFinalize.xUser = custUser.value;\n                    dataToFinalize.xPass = custPass.value;\n                }\n\n                thisB.addTier(dataToFinalize);\n\n                if (customMode == 'finalize-bin')\n                    switchToBinMode();\n                else\n                    switchToCustomMode();\n            } else if (customMode === 'hub-connect') {\n                var curi = custURL.value.trim();\n                if (!/^.+:\\/\\//.exec(curi)) {\n                    curi = 'http://' + curi;\n                }\n                \n                tryAddHub(curi);\n            } else if (customMode === 'multiple') {\n                for (var mi = 0; mi < multipleSet.length; ++mi) {\n                    var s = multipleSet[mi];\n                    if (s.hidden)\n                        continue;\n\n                    if (s.tier_type == 'bam' && !s.indexBlob && !s.indexUri)\n                        continue;\n                    if (s.tier_type == 'tabix' && !s.indexBlob && !s.indexUri)\n                        continue;\n\n                    var nds = makeSourceConfig(s);\n                    if (nds) {\n                        nds.noPersist = true;\n                        thisB.addTier(nds);\n                    }\n                }\n\n                switchToBinMode();\n            }\n        } else {\n            thisB.removeAllPopups();\n        }\n    };\n\n    function tryAddHub(curi, opts, retry) {\n        opts = opts || {};\n        for (var hi = 0; hi < thisB.hubObjects.length; ++hi) {\n            var h = thisB.hubObjects[hi];\n            if (h.hub.url == curi) {\n                for (var bi = 0; bi < addModeButtons.length; ++bi) {\n                    if (addModeButtons[bi].hub == h) {\n                        activateButton(addModeButtons, addModeButtons[bi]);\n                    }\n                }\n                h.getTracks(function(tracks, err) {\n                    if (err) {\n                        console.log(err);\n                    }\n                    makeHubStab(tracks);\n                });\n                return;\n            }\n\n        }\n        \n        connectTrackHub(curi, function(hub, err) {\n            if (err) {\n                if (!retry) {\n                    return tryAddHub(curi, {credentials: true}, true);\n                }\n                removeChildren(stabHolder);\n                stabHolder.appendChild(makeElement('h2', 'Error connecting to track hub'))\n                stabHolder.appendChild(makeElement('p', err));\n                customMode = 'reset-hub';\n                return;\n            } else {\n                var bestHub = null;\n                var bestHubButton = null;\n                for (var genome in hub.genomes) {\n                    var mapping = null;\n                    var okay = false;\n\n                    if (genome == thisB.coordSystem.ucscName) {\n                        okay = true;\n                    } else {\n                         for (var mid in thisB.chains) {\n                            var m = thisB.chains[mid];\n                            if (genome == m.coords.ucscName) {\n                                mapping = mid;\n                                okay = true;\n                            }\n                         }\n                    }\n\n                    if (okay) {\n                        var hc = {url: curi, genome: genome};\n                        if (opts.credentials)\n                            hc.credentials = true;\n                        if (mapping) {\n                            hc.mapping = mapping;\n                            hub.genomes[genome].mapping = mapping;\n                        }\n                        thisB.hubs.push(hc);\n                        thisB.hubObjects.push(hub.genomes[genome]);\n                        \n                        var hubButton = makeHubButton(hub.genomes[genome]);\n                        modeButtonHolder.appendChild(hubButton);\n\n                        if (!mapping || !bestHub) {\n                            bestHub = hub.genomes[genome];\n                            bestHubButton = hubButton;\n                        }\n                    }\n                }\n\n                if (bestHub) {\n                    thisB.notifyTier();\n                    activateButton(addModeButtons, bestHubButton);\n                    bestHub.getTracks(function(tracks, err) {\n                        makeHubStab(tracks);\n                    });\n                } else {\n                    removeChildren(stabHolder);\n                    stabHolder.appendChild(makeElement('h2', 'No data for this genome'))\n                    stabHolder.appendChild(makeElement('p', 'This URL appears to be a valid track-hub, but it doesn\\'t contain any data for the coordinate system of this browser'));\n                    stabHolder.appendChild(makeElement('p', 'coordSystem.ucscName = ' + thisB.coordSystem.ucscName));\n                    customMode = 'reset-hub';\n                    return;\n                }\n            }\n        }, opts);\n    }\n\n    var tryAddDAS = function(nds, retry) {\n        var knownSpace = thisB.knownSpace;\n        if (!knownSpace) {\n            alert(\"Can't confirm track-addition to an uninit browser.\");\n            return;\n        }\n        var tsm = Math.max(knownSpace.min, (knownSpace.min + knownSpace.max - 100) / 2)|0;\n        var testSegment = new DASSegment(knownSpace.chr, tsm, Math.min(tsm + 99, knownSpace.max));\n        nds.features(testSegment, {}, function(features, status) {\n            if (status) {\n                if (!retry) {\n                    nds.credentials = true;\n                    tryAddDAS(nds, true);\n                } else {\n                    removeChildren(stabHolder);\n                    stabHolder.appendChild(makeElement('h2', 'Custom data not found'));\n                    stabHolder.appendChild(makeElement('p', 'DAS uri: ' + nds.uri + ' is not answering features requests'));\n                    customMode = 'reset';\n                    return;\n                }\n            } else {\n                var nameExtractPattern = new RegExp('/([^/]+)/?$');\n                var match = nameExtractPattern.exec(nds.uri);\n                if (match) {\n                    nds.name = match[1];\n                }\n\n                tryAddDASxSources(nds);\n                return;\n            }\n        });\n    }\n\n    function tryAddDASxSources(nds, retry) {\n        var uri = nds.uri;\n        if (retry) {\n            var match = /(.+)\\/[^\\/]+\\/?/.exec(uri);\n            if (match) {\n                uri = match[1] + '/sources';\n            }\n        }\n        function sqfail() {\n            if (!retry) {\n                return tryAddDASxSources(nds, true);\n            } else {\n                return addDasCompletionPage(nds);\n            }\n        }\n        new DASRegistry(uri, {credentials: nds.credentials}).sources(\n            function(sources) {\n                if (!sources || sources.length == 0) {\n                    return sqfail();\n                } \n\n                var fs = null;\n                if (sources.length == 1) {\n                    fs = sources[0];\n                } else {\n                    for (var i = 0; i < sources.length; ++i) {\n                        if (sources[i].uri === nds.uri) {\n                            fs = sources[i];\n                            break;\n                        }\n                    }\n                }\n\n                var coordsDetermined = false, quantDetermined = false;\n                if (fs) {\n                    nds.name = fs.name;\n                    nds.desc = fs.desc;\n                    if (fs.maxbins) {\n                        nds.maxbins = true;\n                    } else {\n                        nds.maxbins = false;\n                    }\n                    if (fs.capabilities) {\n                        nds.capabilities = fs.capabilities;\n                    }\n                    quantDetermined = true\n                    \n                    if (fs.coords && fs.coords.length == 1) {\n                        var coords = fs.coords[0];\n                        if (coordsMatch(coords, thisB.coordSystem)) {\n                            coordsDetermined = true;\n                        } else if (thisB.chains) {\n                            for (var k in thisB.chains) {\n                                if (coordsMatch(coords, thisB.chains[k].coords)) {\n                                    nds.mapping = k;\n                                    coordsDetermined = true;\n                                }\n                            }\n                        }\n                    }\n                    \n                }\n                return addDasCompletionPage(nds, coordsDetermined, quantDetermined);\n            },\n            function() {\n                return sqfail();\n            }\n        );\n    }\n\n    var makeSourceConfig = function(s) {\n        var nds = {name: s.name};\n        if (s.credentials)\n            nds.credentials = s.credentials;\n        \n        if (s.mapping && s.mapping != '__default__')\n            nds.mapping = s.mapping;\n\n        if (s.transport)\n            nds.transport = s.transport;\n\n        if (s.tier_type == 'bwg') {\n            if (s.blob)\n                nds.bwgBlob = s.blob;\n            else if (s.uri)\n                nds.bwgURI = s.uri;\n            return nds;\n        } else if (s.tier_type == 'bam') {\n            if (s.blob) {\n                nds.bamBlob = s.blob;\n                nds.baiBlob = s.indexBlob;\n            } else {\n                nds.bamURI = s.uri;\n                nds.baiURI = s.indexUri;\n            }\n            return nds;\n        } else if (s.tier_type == 'tabix') {\n            nds.tier_type = 'tabix';\n            nds.payload = s.payload;\n            if (s.blob) {\n                nds.blob = s.blob;\n                nds.indexBlob = s.indexBlob;\n            } else {\n                nds.uri = s.uri;\n                nds.indexUri = s.indexUri;\n            }\n            return nds;\n        } else if (s.tier_type == 'memstore') {\n            nds.tier_type = 'memstore';\n            nds.payload = s.payload;\n            if (s.blob)\n                nds.blob = s.blob;\n            else\n                nds.uri = s.uri;\n            return nds;\n        }\n    }\n\n    var tryAddBin = function(source) {\n        probeResource(source, function(source, err) {\n            if (err) {\n                removeChildren(stabHolder);\n                var tabError = makeElement('div');\n                tabError.appendChild(makeElement('h2', \"Couldn't access custom data\"));\n                tabError.appendChild(makeElement('p', '' + err));\n                stabHolder.appendChild(tabError);\n                console.log(source);\n                if (window.location.protocol === 'https:' && source.uri.indexOf('http:') == 0) {\n                    thisB.canFetchPlainHTTP().then(\n                        function(can) {\n                            if (!can) {\n                                tabError.appendChild(\n                                    makeElement('p', [\n                                        makeElement('strong', 'HTTP warning: '),\n                                        'you may not be able to access HTTP resources from an instance of Biodalliance which you are accessing via HTTPS.',\n                                        makeElement('a', '[More info]', {href: thisB.httpWarningURL, target: \"_blank\"})\n                                      ]\n                                   )\n                                );\n                            }\n                        }\n                    );\n                }\n                customMode = 'reset-bin';\n            } else {\n                var nds = makeSourceConfig(source);\n                if (source.tier_type == 'bam') {\n                    return completeBAM(nds);\n                } else if (source.tier_type == 'tabix') {\n                    return completeTabixVCF(nds);\n                } else {\n                    return addDasCompletionPage(nds, false, false, true);\n                }\n            }\n        });\n    }\n\n    function promptForBAI(nds) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'inline';\n\n        removeChildren(stabHolder);\n        customMode = 'prompt-bai'\n        stabHolder.appendChild(makeElement('h2', 'Select an index file'));\n        stabHolder.appendChild(makeElement('p', 'Dalliance requires a BAM index (.bai) file when displaying BAM data.  These normally accompany BAM files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));\n\n        stabHolder.appendChild(document.createTextNode('Index file: '));\n        custFile = makeElement('input', null, {type: 'file'});\n        stabHolder.appendChild(custFile);\n        dataToFinalize = nds;\n    }\n\n    function promptForTabix(nds) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'inline';\n\n        removeChildren(stabHolder);\n        customMode = 'prompt-tbi'\n        stabHolder.appendChild(makeElement('h2', 'Select an index file'));\n        stabHolder.appendChild(makeElement('p', 'Dalliance requires a Tabix index (.tbi) file when displaying VCF data.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate BAI file'));\n\n        stabHolder.appendChild(document.createTextNode('Index file: '));\n        custFile = makeElement('input', null, {type: 'file'});\n        stabHolder.appendChild(custFile);\n        dataToFinalize = nds;\n    }\n\n    function completeBAM(nds) {\n        var indexF;\n        if (nds.baiBlob) \n            indexF = new BlobFetchable(nds.baiBlob);\n        else if (nds.transport == 'encode')\n            indexF = new EncodeFetchable(nds.bamURI + '.bai');\n        else\n            indexF = new URLFetchable(nds.bamURI + '.bai', {credentials: nds.credentials});\n\n        indexF.slice(0, 256).fetch(function(r) {\n                var hasBAI = false;\n                if (r) {\n                    var ba = new Uint8Array(r);\n                    var magic2 = readInt(ba, 0);\n                    hasBAI = (magic2 == BAI_MAGIC);\n                }\n                if (hasBAI) {\n                    return addDasCompletionPage(nds, false, false, true);\n                } else {\n                    return binFormatErrorPage('You have selected a valid BAM file, but a corresponding index (.bai) file was not found.  Please index your BAM (samtools index) and place the BAI file in the same directory');\n                }\n        });\n    }\n\n    function completeTabixVCF(nds) {\n        var indexF;\n        if (nds.indexBlob) {\n            indexF = new BlobFetchable(nds.indexBlob);\n        } else {\n            indexF = new URLFetchable(nds.uri + '.tbi');\n        }\n        indexF.slice(0, 1<<16).fetch(function(r) {\n            var hasTabix = false;\n            if (r) {\n                var ba = new Uint8Array(r);\n                if (ba[0] == 31 || ba[1] == 139) {\n                    var unc = unbgzf(r);\n                    ba = new Uint8Array(unc);\n                    var m2 = readInt(ba, 0);\n                    hasTabix = (m2 == TABIX_MAGIC);\n                }\n            }\n            if (hasTabix) {\n                return addDasCompletionPage(nds, false, false, true);\n            } else {\n                return binFormatErrorPage('You have selected a valid VCF file, but a corresponding index (.tbi) file was not found.  Please index your VCF (\"tabix -p vcf -f myfile.vcf.gz\") and place the .tbi file in the same directory');\n            }\n        });\n    }\n\n    function binFormatErrorPage(message) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'inline';\n\n        removeChildren(stabHolder);\n        message = message || 'Custom data format not recognized';\n        stabHolder.appendChild(makeElement('h2', 'Error adding custom data'));\n        stabHolder.appendChild(makeElement('p', message));\n        stabHolder.appendChild(makeElement('p', 'Currently supported formats are bigBed, bigWig, and BAM.'));\n        customMode = 'reset-bin';\n        return;\n    }\n                     \n    var addDasCompletionPage = function(nds, coordsDetermined, quantDetermined, quantIrrelevant) {\n        refreshButton.style.display = 'none';\n        addButton.style.display = 'inline';\n        canButton.style.display = 'inline';\n\n        removeChildren(stabHolder);\n        stabHolder.appendChild(makeElement('h2', 'Add custom data: step 2'));\n        stabHolder.appendChild(document.createTextNode('Label: '));\n        custName = makeElement('input', '', {value: nds.name});\n        stabHolder.appendChild(custName);\n\n\n        // stabHolder.appendChild(document.createTextNode('User: '));\n        custUser = makeElement('input', '');\n        // stabHolder.appendChild(custUser);\n        //stabHolder.appendChild(document.createTextNode('Pass: '));\n        custPass = makeElement('input', '');\n        // stabHolder.appendChild(custPass);\n        \n\n        stabHolder.appendChild(makeElement('br'));\n        stabHolder.appendChild(makeElement('br'));\n        stabHolder.appendChild(makeElement('h4', 'Coordinate system: '));\n        custCS = makeElement('select', null);\n        custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), {value: '__default__'}));\n        if (thisB.chains) {\n            for (var csk in thisB.chains) {\n                var cs = thisB.chains[csk].coords;\n                custCS.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), {value: csk}));\n            }\n        }\n        custCS.value = nds.mapping || '__default__';\n        stabHolder.appendChild(custCS);\n\n        if (coordsDetermined) {\n            stabHolder.appendChild(makeElement('p', \"(Based on server response, probably doesn't need changing.)\"));\n        } else {\n            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), \"unable to determine the correct value from server responses.  Please check carefully.\"]));\n            stabHolder.appendChild(makeElement('p', \"If you don't see the mapping you're looking for, please contact thomas@biodalliance.org\"));\n        }\n\n        if (!quantIrrelevant) {\n            stabHolder.appendChild(document.createTextNode('Quantitative: '));\n            custQuant = makeElement('input', null, {type: 'checkbox', checked: true});\n            if (typeof nds.maxbins !== 'undefined') {\n                custQuant.checked = nds.maxbins;\n            }\n            stabHolder.appendChild(custQuant);\n            if (quantDetermined) {\n                stabHolder.appendChild(makeElement('p', \"(Based on server response, probably doesn't need changing.)\"));\n            } else {\n                stabHolder.appendChild(makeElement('p', [makeElement('b', \"Warning: \"), \"unable to determine correct value.  If in doubt, leave checked.\"]));\n            }\n        }\n\n        if (nds.bwgBlob) {\n            stabHolder.appendChild(makeElement('p', [makeElement('b', 'Warning: '), 'data added from local file.  Due to the browser security model, the track will disappear if you reload Dalliance.']));\n        }\n\n        custName.focus();\n\n        if (customMode === 'bin' || customMode === 'prompt-bai' || customMode === 'prompt-tbi')\n            customMode = 'finalize-bin';\n        else\n            customMode = 'finalize';\n        dataToFinalize = nds;\n    }\n\n    var multipleSet = null;\n    var tryAddMultiple = function(fileList) {\n        var newSources = multipleSet = [];\n        customMode = 'multiple';\n        for (var fi = 0; fi < fileList.length; ++fi) {\n            var f = fileList[fi];\n            if (f) {\n                newSources.push({blob: f});\n            }\n        }\n\n        for (var fi = 0; fi < newSources.length; ++fi) {\n            probeMultiple(newSources[fi]);\n        }\n        updateMultipleStatus();\n    }\n\n    var probeMultiple = function(ns) {\n        probeResource(ns, function(source, err) {\n            if (err) {\n                source.error = err;\n            }\n\n            var usedIndices = [];\n            var bams = {}, tabixes = {};\n            for (var si = 0; si < multipleSet.length; ++si) {\n                var s = multipleSet[si];\n                if (s.tier_type == 'bam' && !s.indexBlob) {\n                    bams[s.blob.name] = s;\n                }\n                if (s.tier_type == 'tabix' && !s.indexBlob) {\n                    tabixes[s.blob.name] = s;\n                }\n            }\n\n            for (var si = 0; si < multipleSet.length; ++si) {\n                var s = multipleSet[si];\n                if (s.tier_type === 'bai') {\n                    var baiPattern = new RegExp('(.+)\\\\.bai$');\n                    var match = baiPattern.exec(s.blob.name);\n                    if (match && bams[match[1]]) {\n                        bams[match[1]].indexBlob = s.blob;\n                        usedIndices.push(si);\n                    }\n                } else if (s.tier_type === 'tabix-index') {\n                    var tbiPattern = new RegExp('(.+)\\\\.tbi$');\n                    var match = tbiPattern.exec(s.blob.name);\n                    if (match && tabixes[match[1]]) {\n                        tabixes[match[1]].indexBlob = s.blob;\n                        usedIndices.push(si);\n                    }\n                }\n            }\n\n            for (var bi = usedIndices.length - 1; bi >= 0; --bi) {\n                multipleSet.splice(usedIndices[bi], 1);\n            }\n\n            updateMultipleStatus();\n        });\n    }\n\n    var updateMultipleStatus = function() {\n        removeChildren(stabHolder);\n        var needsIndex = false;\n        var multTable = makeElement('table', multipleSet\n          .filter(function(s) {return !s.hidden})\n          .map(function(s) {\n            var row = makeElement('tr');\n            row.appendChild(makeElement('td', s.name || s.blob.name));\n            var typeContent;\n            if (s.error) {\n                typeContent = makeElement('span', 'Error', null, {color: 'red'});\n            } else if (s.tier_type) {\n                typeContent = s.payload || s.tier_type;\n            } else {\n                typeContent = thisB.makeLoader(16);\n            }\n\n            var ccs;\n            var state = 'unknown';\n            if (s.tier_type == 'bwg' || s.tier_type == 'memstore') {\n                state = 'okay';\n            } else if (s.tier_type == 'bam') {\n                state = s.indexBlob ? 'okay' : 'needs-index';\n            } else if (s.tier_type == 'tabix') {\n                state = s.indexBlob ? 'okay' : 'needs-index';\n            }\n\n            if (state == 'okay') {\n                ccs = makeElement('select', null, null, {width: '150px'});\n                ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(thisB.coordSystem), {value: '__default__'}));\n                if (thisB.chains) {\n                    for (var csk in thisB.chains) {\n                        var cs = thisB.chains[csk].coords;\n                        ccs.appendChild(makeElement('option', thisB.nameForCoordSystem(cs), {value: csk}));\n                    }\n                }\n                ccs.value = s.mapping || '__default__';\n\n                ccs.addEventListener('change', function(ev) {\n                    s.mapping = ccs.value;\n                    console.log(s);\n                }, false);\n            } else if (state == 'needs-index') {\n                ccs = makeElement('span', 'Needs index', {}, {color: 'red'});\n                needsIndex = true;\n            }\n\n            return makeElement('tr', [makeElement('td', s.name || s.blob.name),\n                                      makeElement('td', typeContent),\n                                      makeElement('td', ccs)]);\n\n        }), {className: 'table table-striped table-condensed'});\n        stabHolder.appendChild(multTable);\n\n        if (needsIndex) {\n            stabHolder.appendChild(makeElement('p', 'Some of these files are missing required index (.bai or .tbi) files.  For security reasons, web applications like Dalliance can only access local files which you have explicity selected.  Please use the file chooser below to select the appropriate index file'));\n            stabHolder.appendChild(document.createTextNode('Index file(s): '));\n            var indexFile = makeElement('input', null, {type: 'file', multiple: 'multiple'});\n            stabHolder.appendChild(indexFile);\n            indexFile.addEventListener('change', function(ev) {\n                console.log('fileset changed');\n                var fileList = indexFile.files || [];\n                for (var fi = 0; fi < fileList.length; ++fi) {\n                    var f = fileList[fi];\n                    if (f) {\n                        var ns = {blob: f, hidden: true};\n                        multipleSet.push(ns);\n                        probeMultiple(ns);\n                    }\n                }\n            }, false);\n        }\n    }\n\n    var canButton = makeElement('button', 'Cancel', {className: 'btn'});\n    canButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        if (customMode === 'finalize-bin')\n            switchToBinMode();\n        else\n            switchToCustomMode();\n    }, false);\n\n    var refreshButton = makeElement('button', 'Refresh', {className: 'btn'});\n    refreshButton.addEventListener('click', function(ev) {\n        ev.stopPropagation(); ev.preventDefault();\n        thisB.queryRegistry(__mapping);\n    }, false);\n    this.makeTooltip(refreshButton, 'Click to re-fetch data from the DAS registry');\n\n    var buttonHolder = makeElement('div', [addButton, ' ', canButton, ' ', refreshButton]);\n    buttonHolder.style.margin = '10px';\n    asform.appendChild(buttonHolder);\n\n    popup.appendChild(asform);\n    makeStab(thisB.availableSources);\n\n    this.showToolPanel(popup);\n    this.setUiMode('add');\n\n    if (firstDefButton) {\n        activateButton(addModeButtons, firstDefButton);\n        makeStab(new Observed(firstDefSources));\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// trix.js: UCSC-style free text indices\n//\n\n\"use strict\";\n\nfunction connectTrix(ix, ixx, callback) {\n    ixx.fetchAsText(function(ixxData) {\n        if (!ixxData) \n            return callback(null, \"Couldn't fetch index-index\");\n\n        var toks = ixxData.split(/(.+)([0-9A-F]{10})\\n/);\n\n        var keys = [];\n        var offsets = [];\n        for (var ti = 1; ti < toks.length; ti += 3) {\n            keys.push(toks[ti]);\n            offsets.push(parseInt(toks[ti+1], 16));\n        }\n\n        return callback(new TrixIndex(keys, offsets, ix));\n    });\n}\n\nfunction TrixIndex(keys, offsets, ix) {\n    this.keys = keys;\n    this.offsets = offsets;\n    this.ix = ix;\n}\n\nTrixIndex.prototype.lookup = function(query, callback) {\n    var ixslice;\n\n    var qtag = (query + '     ').substring(0,5).toLowerCase();\n    for (var i = 0; i < this.keys.length; ++i) {\n        if (qtag.localeCompare(this.keys[i]) < 0) {\n            ixslice = this.ix.slice(this.offsets[i - 1], this.offsets[i] - this.offsets[i - 1]);\n            break;\n        }\n    }\n\n    if (!ixslice) {\n        ixslice = this.ix.slice(this.offsets[this.offsets.length - 1]);\n    }\n\n    ixslice.fetchAsText(function(ist) {\n        var lines = ist.split('\\n');\n        for (var li = 0; li < lines.length; ++li) {\n            if (lines[li].indexOf(query.toLowerCase() + ' ') == 0) {\n                return callback(lines[li].split(' '));\n            }\n        }\n        return callback(null);\n    });\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        connectTrix: connectTrix\n    };\n}","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// twoBit.js: packed-binary reference sequences\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var bin = require('./bin');\n    var readInt = bin.readInt;\n    var readIntBE = bin.readIntBE;\n\n    var spans = require('./spans');\n    var Range = spans.Range;\n    var union = spans.union;\n    var intersection = spans.intersection;\n}\n\nvar TWOBIT_MAGIC = 0x1a412743;\nvar TWOBIT_MAGIC_BE = 0x4327411a;\nvar HEADER_BLOCK_SIZE = 12500;\n\nfunction TwoBitFile() {\n}\n\nfunction makeTwoBit(fetchable, cnt) {\n    var tb = new TwoBitFile();\n    tb.data = fetchable;\n    var headerBlockSize = HEADER_BLOCK_SIZE;\n    var headerBlocksFetched=0;\n    \n    tb.data.slice(0, headerBlockSize).fetch(function(r) {\n        if (!r) {\n            return cnt(null, \"Couldn't access data\");\n        }\n        var ba = new Uint8Array(r);\n        var magic = readInt(ba, 0);\n        if (magic == TWOBIT_MAGIC) {\n            tb.readInt = readInt;\n        } else if (magic == TWOBIT_MAGIC_BE) {\n            tb.readInt = readIntBE;\n        } else {\n            return cnt(null, \"Not a .2bit file, magic=0x\" + magic.toString(16));\n        }\n\n        var version = tb.readInt(ba, 4);\n        if (version != 0) {\n            return cnt(null, 'Unsupported version ' + version);\n        }\n\n        tb.seqCount = tb.readInt(ba, 8);\n        tb.seqDict = {};\n\n        var p = 16, i=0;\n        var o = 0;  // Offset of the current block if we need to fetch multiple header blocks.\n\n        var parseSeqInfo = function() {\n            while (i < tb.seqCount) {\n                var ns = ba[p];\n                if (p + ns + 6 >= ba.length) {\n                    headerBlocksFetched += headerBlockSize;\n                    headerBlockSize = Math.max(HEADER_BLOCK_SIZE,Math.floor(headerBlocksFetched*tb.seqCount/i));\n                    return tb.data.slice(o + p, headerBlockSize).fetch(function (r) {\n                        o += p;\n                        p = 0;\n                        ba = new Uint8Array(r);\n                        parseSeqInfo();\n                    });\n                } else {\n                    ++p;\n                    var name = '';\n                    for (var j = 1; j <= ns; ++j) {\n                        name += String.fromCharCode(ba[p++]);\n                    }\n                    var offset = tb.readInt(ba, p);\n                    p += 4;\n                    tb.seqDict[name] = new TwoBitSeq(tb, offset);\n                    ++i;\n                }\n            }\n            return cnt(tb);\n        }\n\n        parseSeqInfo();\n        \n    });\n}\n\nTwoBitFile.prototype.getSeq = function(chr) {\n    var seq = this.seqDict[chr];\n    if (!seq) {\n        seq = this.seqDict['chr' + chr];\n    }\n    return seq;\n}\n\nTwoBitFile.prototype.fetch = function(chr, min, max, cnt) {\n    var seq = this.getSeq(chr);\n    if (!seq) {\n        return cnt(null, \"Couldn't find \" + chr);\n    } else if (max <= min) {\n        return cnt('');\n    } else {\n        seq.fetch(min, max, cnt);\n    }\n}\n\nfunction TwoBitSeq(tbf, offset) {\n    this.tbf = tbf;\n    this.offset = offset;\n}\n\nTwoBitSeq.prototype.init = function(cnt) {\n    if (this.seqOffset) {\n        return cnt();\n    }\n\n    var thisB = this;\n    thisB.tbf.data.slice(thisB.offset, 8).fetch(function(r1) {\n        if (!r1) {\n            return cnt('Fetch failed');\n        }\n        var ba = new Uint8Array(r1);\n        thisB._length = thisB.tbf.readInt(ba, 0);\n        thisB.nBlockCnt = thisB.tbf.readInt(ba, 4);\n        thisB.tbf.data.slice(thisB.offset + 8, thisB.nBlockCnt*8 + 4).fetch(function(r2) {\n            if (!r2) {\n                return cnt('Fetch failed');\n            }\n            var ba = new Uint8Array(r2);\n            var nbs = null;\n            for (var b = 0; b < thisB.nBlockCnt; ++b) {\n                var nbMin = thisB.tbf.readInt(ba, b * 4);\n                var nbLen = thisB.tbf.readInt(ba, (b + thisB.nBlockCnt) * 4);\n                var nb = new Range(nbMin, nbMin + nbLen - 1);\n                if (!nbs) {\n                    nbs = nb;\n                } else {\n                    nbs = union(nbs, nb);\n                }\n            }\n            thisB.nBlocks = nbs;\n            thisB.mBlockCnt = thisB.tbf.readInt(ba, thisB.nBlockCnt*8);\n            thisB.seqLength = ((thisB._length + 3)/4)|0;\n            thisB.seqOffset = thisB.offset + 16 + ((thisB.nBlockCnt + thisB.mBlockCnt) * 8);\n            return cnt();\n        });\n    });\n}\n\nvar TWOBIT_TABLE = ['T', 'C', 'A', 'G'];\n\nTwoBitSeq.prototype.fetch = function(min, max, cnt) {\n    --min; --max;       // Switch to zero-based.\n    var thisB = this;\n    this.init(function(error) {\n        if (error) {\n            return cnt(null, error);\n        }\n\n        var fetchMin = min >> 2;\n        var fetchMax = max + 3 >> 2;\n        if (fetchMin < 0 || fetchMax > thisB.seqLength) {\n            return cnt('Coordinates out of bounds: ' + min + ':' + max);\n        }\n\n        thisB.tbf.data.slice(thisB.seqOffset + fetchMin, fetchMax - fetchMin).salted().fetch(function(r) {\n            if (r == null) {\n                return cnt('SeqFetch failed');\n            }\n            var seqData = new Uint8Array(r);\n\n            var nSpans = [];\n            if (thisB.nBlocks) {\n                var intr = intersection(new Range(min, max), thisB.nBlocks);\n                if (intr) {\n                    nSpans = intr.ranges();\n                }\n            }\n            \n            var seqstr = '';\n            var ptr = min;\n            function fillSeq(fsm) {\n                while (ptr <= fsm) {\n                    var bb = (ptr >> 2) - fetchMin;\n                    var ni = ptr & 0x3;\n                    var bv = seqData[bb];\n                    var n;\n                    if (ni == 0) {\n                        n = (bv >> 6) & 0x3;\n                    } else if (ni == 1) {\n                        n = (bv >> 4) & 0x3;\n                    } else if (ni == 2) {\n                        n = (bv >> 2) & 0x3;\n                    } else {\n                        n = (bv) & 0x3;\n                    }\n                    seqstr += TWOBIT_TABLE[n];\n                    ++ptr;\n                }\n            }\n            \n            for (var b = 0; b < nSpans.length; ++b) {\n                var nb = nSpans[b];\n                if (ptr > nb.min()) {\n                    throw 'N mismatch...';\n                }\n                if (ptr < nb.min()) {\n                    fillSeq(nb.min() - 1);\n                }\n                while (ptr <= nb.max()) {\n                    seqstr += 'N';\n                    ++ptr;\n                }\n            }\n            if (ptr <= max) {\n                fillSeq(max);\n            }\n            return cnt(seqstr);\n        });\n    });\n}\n\nTwoBitSeq.prototype.length = function(cnt) {\n    var thisB = this;\n    this.init(function(error) {\n        if (error) {\n            return cnt(null, error);\n        } else {\n            return cnt(thisB._length);\n        }\n    });\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        makeTwoBit: makeTwoBit\n    };\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// utils.js: odds, sods, and ends.\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sha1 = require('./sha1');\n    var b64_sha1 = sha1.b64_sha1;\n}\n\nvar NUM_REGEXP = new RegExp('[0-9]+');\n\nfunction stringToNumbersArray(str) {\n    var nums = new Array();\n    var m;\n    while (m = NUM_REGEXP.exec(str)) {\n        nums.push(m[0]);\n        str=str.substring(m.index + (m[0].length));\n    }\n    return nums;\n}\n\nvar STRICT_NUM_REGEXP = new RegExp('^[0-9]+$');\n\nfunction stringToInt(str) {\n    str = str.replace(new RegExp(',', 'g'), '');\n    if (!STRICT_NUM_REGEXP.test(str)) {\n        return null;\n    }\n    return str|0;\n}\n\nfunction pushnew(a, v) {\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] == v) {\n            return;\n        }\n    }\n    a.push(v);\n}\n\nfunction pusho(obj, k, v) {\n    if (obj[k]) {\n        obj[k].push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\nfunction pushnewo(obj, k, v) {\n    var a = obj[k];\n    if (a) {\n        for (var i = 0; i < a.length; ++i) {    // indexOf requires JS16 :-(.\n            if (a[i] == v) {\n                return;\n            }\n        }\n        a.push(v);\n    } else {\n        obj[k] = [v];\n    }\n}\n\n\nfunction pick(a, b, c, d)\n{\n    if (a) {\n        return a;\n    } else if (b) {\n        return b;\n    } else if (c) {\n        return c;\n    } else if (d) {\n        return d;\n    }\n}\n\nfunction pushnew(l, o)\n{\n    for (var i = 0; i < l.length; ++i) {\n        if (l[i] == o) {\n            return;\n        }\n    }\n    l.push(o);\n}\n\n\n\nfunction arrayIndexOf(a, x) {\n    if (!a) {\n        return -1;\n    }\n\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i] === x) {\n            return i;\n        }\n    }\n    return -1;\n}\n\nfunction arrayRemove(a, x) {\n    var i = arrayIndexOf(a, x);\n    if (i >= 0) {\n        a.splice(i, 1);\n        return true;\n    }\n    return false;\n}\n\n//\n// DOM utilities\n//\n\n\nfunction makeElement(tag, children, attribs, styles)\n{\n    var ele = document.createElement(tag);\n    if (children) {\n        if (! (children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (c) {\n                if (typeof c == 'string') {\n                    c = document.createTextNode(c);\n                } else if (typeof c == 'number') {\n                    c = document.createTextNode('' + c);\n                }\n                ele.appendChild(c);\n            }\n        }\n    }\n    \n    if (attribs) {\n        for (var l in attribs) {\n            try {\n                ele[l] = attribs[l];\n            } catch (e) {\n                console.log('error setting ' + l);\n                throw(e);\n            }\n        }\n    }\n    if (styles) {\n        for (var l in styles) {\n            ele.style[l] = styles[l];\n        }\n    }\n    return ele;\n}\n\nfunction makeElementNS(namespace, tag, children, attribs)\n{\n    var ele = document.createElementNS(namespace, tag);\n    if (children) {\n        if (! (children instanceof Array)) {\n            children = [children];\n        }\n        for (var i = 0; i < children.length; ++i) {\n            var c = children[i];\n            if (typeof c == 'string') {\n                c = document.createTextNode(c);\n            }\n            ele.appendChild(c);\n        }\n    }\n    \n    setAttrs(ele, attribs);\n    return ele;\n}\n\nvar attr_name_cache = {};\n\nfunction setAttr(node, key, value)\n{\n    var attr = attr_name_cache[key];\n    if (!attr) {\n        var _attr = '';\n        for (var c = 0; c < key.length; ++c) {\n            var cc = key.substring(c, c+1);\n            var lcc = cc.toLowerCase();\n            if (lcc != cc) {\n                _attr = _attr + '-' + lcc;\n            } else {\n                _attr = _attr + cc;\n            }\n        }\n        attr_name_cache[key] = _attr;\n        attr = _attr;\n    }\n    node.setAttribute(attr, value);\n}\n\nfunction setAttrs(node, attribs)\n{\n    if (attribs) {\n        for (var l in attribs) {\n            setAttr(node, l, attribs[l]);\n        }\n    }\n}\n\n\n\nfunction removeChildren(node)\n{\n    if (!node || !node.childNodes) {\n        return;\n    }\n\n    while (node.childNodes.length > 0) {\n        node.removeChild(node.firstChild);\n    }\n}\n\n\n\n//\n// WARNING: not for general use!\n//\n\nfunction miniJSONify(o, exc) {\n    if (typeof o === 'undefined') {\n        return 'undefined';\n    } else if (o == null) {\n        return 'null';\n    } else if (typeof o == 'string') {\n        return \"'\" + o + \"'\";\n    } else if (typeof o == 'number') {\n        return \"\" + o;\n    } else if (typeof o == 'boolean') {\n        return \"\" + o;\n    } else if (typeof o == 'object') {\n        if (o instanceof Array) {\n            var s = null;\n            for (var i = 0; i < o.length; ++i) {\n                s = (s == null ? '' : (s + ', ')) + miniJSONify(o[i], exc);\n            }\n            return '[' + (s?s:'') + ']';\n        } else {\n            exc = exc || {};\n            var s = null;\n            for (var k in o) {\n                if (exc[k])\n                    continue;\n                if (k != undefined && typeof(o[k]) != 'function') {\n                    s = (s == null ? '' : (s + ', ')) + k + ': ' + miniJSONify(o[k], exc);\n                }\n            }\n            return '{' + (s?s:'') + '}';\n        }\n    } else {\n        return (typeof o);\n    }\n}\n\nfunction shallowCopy(o) {\n    var n = {};\n    for (var k in o) {\n        n[k] = o[k];\n    }\n    return n;\n}\n\nfunction Observed(x) {\n    this.value = x;\n    this.listeners = [];\n}\n\nObserved.prototype.addListener = function(f) {\n    this.listeners.push(f);\n}\n\nObserved.prototype.addListenerAndFire = function(f) {\n    this.listeners.push(f);\n    f(this.value);\n}\n\nObserved.prototype.removeListener = function(f) {\n    arrayRemove(this.listeners, f);\n}\n\nObserved.prototype.get = function() {\n    return this.value;\n}\n\nObserved.prototype.set = function(x) {\n    this.value = x;\n    for (var i = 0; i < this.listeners.length; ++i) {\n        this.listeners[i](x);\n    }\n}\n\nfunction Awaited() {\n    this.queue = [];\n}\n\nAwaited.prototype.provide = function(x) {\n    if (this.res !== undefined) {\n        throw \"Resource has already been provided.\";\n    }\n\n    this.res = x;\n    for (var i = 0; i < this.queue.length; ++i) {\n        this.queue[i](x);\n    }\n    this.queue = null;   // avoid leaking closures.\n}\n\nAwaited.prototype.await = function(f) {\n    if (this.res !== undefined) {\n        f(this.res);\n        return this.res;\n    } else {\n        this.queue.push(f);\n    }\n}\n\nvar __dalliance_saltSeed = 0;\n\nfunction saltURL(url) {\n    return url + '?salt=' + b64_sha1('' + Date.now() + ',' + (++__dalliance_saltSeed));\n}\n\nfunction textXHR(url, callback, opts) {\n    if (opts && opts.salt) \n        url = saltURL(url);\n\n    try {\n        var timeout;\n        if (opts.timeout) {\n            timeout = setTimeout(\n                function() {\n                    console.log('timing out ' + url);\n                    req.abort();\n                    return callback(null, 'Timeout');\n                },\n                opts.timeout\n            );\n        }\n\n        var req = new XMLHttpRequest();\n        req.onreadystatechange = function() {\n    \t    if (req.readyState == 4) {\n                if (timeout)\n                    clearTimeout(timeout);\n    \t        if (req.status < 200 || req.status >= 300) {\n    \t\t    callback(null, 'Error code ' + req.status);\n    \t        } else {\n    \t\t    callback(req.responseText);\n    \t        }\n    \t    }\n        };\n        \n        req.open('GET', url, true);\n        req.responseType = 'text';\n\n        if (opts && opts.credentials) {\n            req.withCredentials = true;\n        }\n        req.send('');\n    } catch (e) {\n        callback(null, 'Exception ' + e);\n    }\n}\n\nfunction relativeURL(base, rel) {\n    // FIXME quite naive -- good enough for trackhubs?\n\n    if (rel.indexOf('http:') == 0 || rel.indexOf('https:') == 0) {\n        return rel;\n    }\n\n    var li = base.lastIndexOf('/');\n    if (li >= 0) {\n        return base.substr(0, li + 1) + rel;\n    } else {\n        return rel;\n    }\n}\n\nvar AMINO_ACID_TRANSLATION = {\n    'TTT': 'F',\n    'TTC': 'F',\n    'TTA': 'L',\n    'TTG': 'L',\n    'CTT': 'L',\n    'CTC': 'L',\n    'CTA': 'L',\n    'CTG': 'L',\n    'ATT': 'I',\n    'ATC': 'I',\n    'ATA': 'I',\n    'ATG': 'M',\n    'GTT': 'V',\n    'GTC': 'V',\n    'GTA': 'V',\n    'GTG': 'V',\n    'TCT': 'S',\n    'TCC': 'S',\n    'TCA': 'S',\n    'TCG': 'S',\n    'CCT': 'P',\n    'CCC': 'P',\n    'CCA': 'P',\n    'CCG': 'P',\n    'ACT': 'T',\n    'ACC': 'T',\n    'ACA': 'T',\n    'ACG': 'T',\n    'GCT': 'A',\n    'GCC': 'A',\n    'GCA': 'A',\n    'GCG': 'A',\n    'TAT': 'Y',\n    'TAC': 'Y',\n    'TAA': '*',  // stop\n    'TAG': '*',  // stop\n    'CAT': 'H',\n    'CAC': 'H',\n    'CAA': 'Q',\n    'CAG': 'Q',\n    'AAT': 'N',\n    'AAC': 'N',\n    'AAA': 'K',\n    'AAG': 'K',\n    'GAT': 'D',\n    'GAC': 'D',\n    'GAA': 'E',\n    'GAG': 'E',\n    'TGT': 'C',\n    'TGC': 'C',\n    'TGA': '*',  // stop\n    'TGG': 'W',\n    'CGT': 'R',\n    'CGC': 'R',\n    'CGA': 'R',\n    'CGG': 'R',\n    'AGT': 'S',\n    'AGC': 'S',\n    'AGA': 'R',\n    'AGG': 'R',\n    'GGT': 'G',\n    'GGC': 'G',\n    'GGA': 'G',\n    'GGG': 'G'\n}\n\nfunction resolveUrlToPage(rel) {\n    return makeElement('a', null, {href: rel}).href;\n}\n\n//\n// Missing APIs\n// \n\nif (!('trim' in String.prototype)) {\n    String.prototype.trim = function() {\n        return this.replace(/^\\s+/, '').replace(/\\s+$/, '');\n    };\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = {\n        textXHR: textXHR,\n        relativeURL: relativeURL,\n        resolveUrlToPage: resolveUrlToPage,\n        shallowCopy: shallowCopy,\n        pusho: pusho,\n        pushnew: pushnew,\n        pushnewo: pushnewo,\n        arrayIndexOf: arrayIndexOf,\n        pick: pick,\n\n        makeElement: makeElement,\n        makeElementNS: makeElementNS,\n        removeChildren: removeChildren,\n\n        miniJSONify: miniJSONify,\n\n        Observed: Observed,\n        Awaited: Awaited,\n\n        AMINO_ACID_TRANSLATION: AMINO_ACID_TRANSLATION\n    }\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// vcf.js\n//\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var sa = require('./sourceadapters');\n    var dalliance_registerParserFactory = sa.registerParserFactory;\n\n    var das = require('./das');\n    var DASStylesheet = das.DASStylesheet;\n    var DASStyle = das.DASStyle;\n    var DASFeature = das.DASFeature;\n    var DASGroup = das.DASGroup;\n}\n\nfunction VCFParser() {\n    this.info = [];\n}\n\nvar VCF_INFO_RE = /([^;=]+)(=([^;]+))?;?/;\nvar VCF_INFO_HEADER = /##INFO=<([^>]+)>/;\nvar VCF_INFO_HEADER_TOK = /([^,=]+)=([^,]+|\"[^\"]+\"),?/\n\nVCFParser.prototype.createSession = function(sink) {\n    return new VCFParseSession(this, sink);\n}\n\nfunction VCFParseSession(parser, sink) {\n    this.parser = parser;\n    this.sink  = sink;\n}\n\nVCFParseSession.prototype.parse = function(line) {\n    if (line.length == 0)\n        return;\n    if (line[0] == '#') {\n        if (line.length > 1 && line[1] == '#') {\n            var m = VCF_INFO_HEADER.exec(line);\n            if (m) {\n                var toks = m[1].split(VCF_INFO_HEADER_TOK);\n                var id = null, desc = null;\n                for (var ti = 0; ti < toks.length - 1; ti += 3) {\n                    var key = toks[ti + 1];\n                    var value = toks[ti + 2].replace(/\"/g, '');\n                    if (key == 'ID') {\n                        id = value;\n                    } else if (key == 'Description') {\n                        desc = value;\n                    }\n                }\n                if (id && desc) {\n                    this.parser.info.push(\n                        {id: id,\n                         desc: desc}\n                    );\n                }\n            }\n            return;\n        } else {\n            return;\n        }\n    }\n\n    var toks = line.split('\\t');\n    var f = new DASFeature();\n    f.segment = toks[0];\n    f.id = toks[2]\n    f.refAllele = toks[3];\n    f.altAlleles = toks[4].split(',');\n    f.min = parseInt(toks[1]);\n    f.max = f.min + f.refAllele.length - 1;\n\n    var infoToks = toks[7].split(VCF_INFO_RE);\n    f.info = {};\n    for (var ti = 0; ti < infoToks.length; ti += 4) {\n        f.info[infoToks[ti + 1]] = infoToks[ti + 3];\n    }\n\n\n    var alt = f.altAlleles[0];\n    var ref = f.refAllele;\n    if (alt.length > ref.length) {\n        f.type = \"insertion\";\n        if (alt.indexOf(ref) == 0) {\n            f.insertion = alt.substr(ref.length);\n            f.min += ref.length;\n            f.max = f.min - 1; // Effectively \"between\" bases.\n        } else {\n            f.insertion = alt;\n        }\n    } else if (alt.length < ref.length) {\n        f.type = \"deletion\";\n    } else {\n        f.type = 'substitution';\n    }\n\n    this.sink(f);\n}\n\nVCFParseSession.prototype.flush = function() {};\n\nVCFParser.prototype.getStyleSheet = function(callback) {\n    var stylesheet = new DASStylesheet();\n\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = '__INSERTION';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.FGCOLOR = 'rgb(50,80,255)';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.STROKECOLOR = 'black';\n        stylesheet.pushStyle({type: 'insertion'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'PLIMSOLL';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.FGCOLOR = 'rgb(255, 60, 60)';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.STROKECOLOR = 'black';\n        stylesheet.pushStyle({type: 'deletion'}, null, varStyle);\n    }\n    {\n        var varStyle = new DASStyle();\n        varStyle.glyph = 'PLIMSOLL';\n        varStyle.BUMP = 'yes';\n        varStyle.LABEL = 'no';\n        varStyle.FGCOLOR = 'rgb(50,80,255)';\n        varStyle.BGCOLOR = '#888888';\n        varStyle.STROKECOLOR = 'black';\n        stylesheet.pushStyle({type: 'default'}, null, varStyle);\n    }\n\n    return callback(stylesheet);\n}\n\nVCFParser.prototype.getDefaultFIPs = function(callback) {\n    var self = this;\n    var fip = function(feature, featureInfo) {\n        featureInfo.add(\"Ref. allele\", feature.refAllele);\n        featureInfo.add(\"Alt. alleles\", feature.altAlleles.join(','));\n\n        if (feature.info) {\n            for (var ii = 0; ii < self.info.length; ++ii) {\n                var info = self.info[ii];\n                var val = feature.info[info.id];\n                if (val !== undefined) {\n                    featureInfo.add(info.desc, val);\n                }\n            }\n        }\n    };\n    callback(fip);\n}\n\ndalliance_registerParserFactory('vcf', function() {return new VCFParser()});\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2010\n//\n// version.js\n//\n\n\"use strict\";\n\nvar VERSION = {\n    CONFIG: 5,\n    MAJOR:  0,\n    MINOR:  13,\n    MICRO:  6,\n    PATCH:  'a',\n    BRANCH: 'dev'\n};\n\nVERSION.toString = function() {\n    var vs = '' + this.MAJOR + '.' + this.MINOR + '.' + this.MICRO;\n    if (this.PATCH) {\n        vs = vs + this.PATCH;\n    }\n    if (this.BRANCH && this.BRANCH != '') {\n        vs = vs + '-' + this.BRANCH;\n    }\n    return vs;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = VERSION;\n}\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Dalliance Genome Explorer\n// (c) Thomas Down 2006-2014\n//\n// zoomslider.js: custom slider component\n//\n\n\n\"use strict\";\n\nif (typeof(require) !== 'undefined') {\n    var utils = require('./utils');\n    var makeElement = utils.makeElement;\n}\n\nfunction makeZoomSlider(opts) {\n    opts = opts || {};\n    \n    var minPos = 0, maxPos = opts.width || 200;\n    var min = 0, max = 200;\n    var pos = 50, pos2 = 100;\n    var labels = [];\n    var track = makeElement('hr', null, {className: 'slider-track'}, {width: '' + (maxPos|0) + 'px'});\n    var thumb = makeElement('hr', null, {className: 'slider-thumb active'});\n    var thumb2 = makeElement('hr', null, {className: 'slider-thumb'});\n    var slider = makeElement('div', [track, thumb, thumb2], {className: 'slider'},  {width: '' + ((maxPos|0) + 10) + 'px'});\n\n    slider.removeLabels = function() {\n        for (var li = 0; li < labels.length; ++li) {\n            slider.removeChild(labels[li]);\n        }\n        labels = [];\n    }\n\n    slider.addLabel = function(val, txt) {\n        var pos = (minPos + ((val - min) * (maxPos - minPos))/(max-min))|0;\n        var label = makeElement('div', txt, {className: 'slider-label'}, {\n            left: '' + ((minPos + ((val - min) * (maxPos - minPos))/(max-min))|0) + 'px'\n        });\n        slider.appendChild(label);\n        labels.push(label);\n    }\n\n    var onChange = document.createEvent('HTMLEvents');\n    onChange.initEvent('change', true, false);\n\n    function setPos(np) {\n        np = Math.min(np, maxPos);\n        np = Math.max(np, minPos);\n        pos = np;\n        thumb.style.left = '' + pos + 'px';\n    }\n\n    function setPos2(np) {\n        np = Math.min(np, maxPos);\n        np = Math.max(np, minPos);\n        pos2 = np;\n        thumb2.style.left = '' + pos2 + 'px';\n    }\n\n    Object.defineProperty(slider, 'value', {\n        get: function()  {return min + (((pos-minPos) * (max-min)) / (maxPos - minPos));},\n        set: function(v) {\n          var np = minPos + ((v-min) * (maxPos-minPos))/(max-min);\n          setPos(np);\n        }\n    });\n\n    Object.defineProperty(slider, 'value2', {\n        get: function()  {return min + (((pos2-minPos) * (max-min)) / (maxPos - minPos));},\n        set: function(v) {\n          var np = minPos + ((v-min) * (maxPos-minPos))/(max-min);\n          setPos2(np);\n        }\n    });\n\n    Object.defineProperty(slider, 'active', {\n        get: function() {return thumb.classList.contains('active') ? 1 : 2},\n        set: function(x) {\n            if (x == 1) {\n                thumb.classList.add('active');\n                thumb2.classList.remove('active');\n            } else {\n                thumb2.classList.add('active');\n                thumb.classList.remove('active');\n            }\n        }\n    });\n\n    Object.defineProperty(slider, 'min', {\n      get: function() {return min},\n      set: function(v) {min = v}\n    });\n\n    Object.defineProperty(slider, 'max', {\n      get: function() {return max},\n      set: function(v) {max = v}\n    });\n\n    var offset;\n    var which;\n\n    var thumbMouseDown = function(ev) {\n        which = this == thumb ? 1 : 2;\n        if (which != slider.active) {\n            slider.active = which;\n            slider.dispatchEvent(onChange);\n        }\n        ev.stopPropagation(); ev.preventDefault();\n        window.addEventListener('mousemove', thumbDragHandler, false);\n        window.addEventListener('mouseup', thumbDragEndHandler, false);\n        offset = ev.clientX - (which == 1 ? pos : pos2);\n    };\n\n    thumb.addEventListener('mousedown', thumbMouseDown, false);\n    thumb2.addEventListener('mousedown', thumbMouseDown, false);\n\n    var thumbDragHandler = function(ev) {\n        if (which == 1)\n            setPos(ev.clientX - offset);\n        else\n            setPos2(ev.clientX - offset);\n        slider.dispatchEvent(onChange);\n    };\n\n    var thumbDragEndHandler = function(ev) {\n        window.removeEventListener('mousemove', thumbDragHandler, false);\n        window.removeEventListener('mouseup', thumbDragEndHandler, false);\n    }\n\n    return slider;\n}\n\nif (typeof(module) !== 'undefined') {\n    module.exports = makeZoomSlider;\n}\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = setTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    clearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*!\n * @overview es6-promise - a tiny implementation of Promises/A+.\n * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)\n * @license   Licensed under MIT license\n *            See https://raw.githubusercontent.com/jakearchibald/es6-promise/master/LICENSE\n * @version   3.0.2\n */\n\n(function() {\n    \"use strict\";\n    function lib$es6$promise$utils$$objectOrFunction(x) {\n      return typeof x === 'function' || (typeof x === 'object' && x !== null);\n    }\n\n    function lib$es6$promise$utils$$isFunction(x) {\n      return typeof x === 'function';\n    }\n\n    function lib$es6$promise$utils$$isMaybeThenable(x) {\n      return typeof x === 'object' && x !== null;\n    }\n\n    var lib$es6$promise$utils$$_isArray;\n    if (!Array.isArray) {\n      lib$es6$promise$utils$$_isArray = function (x) {\n        return Object.prototype.toString.call(x) === '[object Array]';\n      };\n    } else {\n      lib$es6$promise$utils$$_isArray = Array.isArray;\n    }\n\n    var lib$es6$promise$utils$$isArray = lib$es6$promise$utils$$_isArray;\n    var lib$es6$promise$asap$$len = 0;\n    var lib$es6$promise$asap$$toString = {}.toString;\n    var lib$es6$promise$asap$$vertxNext;\n    var lib$es6$promise$asap$$customSchedulerFn;\n\n    var lib$es6$promise$asap$$asap = function asap(callback, arg) {\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len] = callback;\n      lib$es6$promise$asap$$queue[lib$es6$promise$asap$$len + 1] = arg;\n      lib$es6$promise$asap$$len += 2;\n      if (lib$es6$promise$asap$$len === 2) {\n        // If len is 2, that means that we need to schedule an async flush.\n        // If additional callbacks are queued before the queue is flushed, they\n        // will be processed by this flush that we are scheduling.\n        if (lib$es6$promise$asap$$customSchedulerFn) {\n          lib$es6$promise$asap$$customSchedulerFn(lib$es6$promise$asap$$flush);\n        } else {\n          lib$es6$promise$asap$$scheduleFlush();\n        }\n      }\n    }\n\n    function lib$es6$promise$asap$$setScheduler(scheduleFn) {\n      lib$es6$promise$asap$$customSchedulerFn = scheduleFn;\n    }\n\n    function lib$es6$promise$asap$$setAsap(asapFn) {\n      lib$es6$promise$asap$$asap = asapFn;\n    }\n\n    var lib$es6$promise$asap$$browserWindow = (typeof window !== 'undefined') ? window : undefined;\n    var lib$es6$promise$asap$$browserGlobal = lib$es6$promise$asap$$browserWindow || {};\n    var lib$es6$promise$asap$$BrowserMutationObserver = lib$es6$promise$asap$$browserGlobal.MutationObserver || lib$es6$promise$asap$$browserGlobal.WebKitMutationObserver;\n    var lib$es6$promise$asap$$isNode = typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';\n\n    // test for web worker but not in IE10\n    var lib$es6$promise$asap$$isWorker = typeof Uint8ClampedArray !== 'undefined' &&\n      typeof importScripts !== 'undefined' &&\n      typeof MessageChannel !== 'undefined';\n\n    // node\n    function lib$es6$promise$asap$$useNextTick() {\n      // node version 0.10.x displays a deprecation warning when nextTick is used recursively\n      // see https://github.com/cujojs/when/issues/410 for details\n      return function() {\n        process.nextTick(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    // vertx\n    function lib$es6$promise$asap$$useVertxTimer() {\n      return function() {\n        lib$es6$promise$asap$$vertxNext(lib$es6$promise$asap$$flush);\n      };\n    }\n\n    function lib$es6$promise$asap$$useMutationObserver() {\n      var iterations = 0;\n      var observer = new lib$es6$promise$asap$$BrowserMutationObserver(lib$es6$promise$asap$$flush);\n      var node = document.createTextNode('');\n      observer.observe(node, { characterData: true });\n\n      return function() {\n        node.data = (iterations = ++iterations % 2);\n      };\n    }\n\n    // web worker\n    function lib$es6$promise$asap$$useMessageChannel() {\n      var channel = new MessageChannel();\n      channel.port1.onmessage = lib$es6$promise$asap$$flush;\n      return function () {\n        channel.port2.postMessage(0);\n      };\n    }\n\n    function lib$es6$promise$asap$$useSetTimeout() {\n      return function() {\n        setTimeout(lib$es6$promise$asap$$flush, 1);\n      };\n    }\n\n    var lib$es6$promise$asap$$queue = new Array(1000);\n    function lib$es6$promise$asap$$flush() {\n      for (var i = 0; i < lib$es6$promise$asap$$len; i+=2) {\n        var callback = lib$es6$promise$asap$$queue[i];\n        var arg = lib$es6$promise$asap$$queue[i+1];\n\n        callback(arg);\n\n        lib$es6$promise$asap$$queue[i] = undefined;\n        lib$es6$promise$asap$$queue[i+1] = undefined;\n      }\n\n      lib$es6$promise$asap$$len = 0;\n    }\n\n    function lib$es6$promise$asap$$attemptVertx() {\n      try {\n        var r = require;\n        var vertx = r('vertx');\n        lib$es6$promise$asap$$vertxNext = vertx.runOnLoop || vertx.runOnContext;\n        return lib$es6$promise$asap$$useVertxTimer();\n      } catch(e) {\n        return lib$es6$promise$asap$$useSetTimeout();\n      }\n    }\n\n    var lib$es6$promise$asap$$scheduleFlush;\n    // Decide what async method to use to triggering processing of queued callbacks:\n    if (lib$es6$promise$asap$$isNode) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useNextTick();\n    } else if (lib$es6$promise$asap$$BrowserMutationObserver) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMutationObserver();\n    } else if (lib$es6$promise$asap$$isWorker) {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useMessageChannel();\n    } else if (lib$es6$promise$asap$$browserWindow === undefined && typeof require === 'function') {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$attemptVertx();\n    } else {\n      lib$es6$promise$asap$$scheduleFlush = lib$es6$promise$asap$$useSetTimeout();\n    }\n\n    function lib$es6$promise$$internal$$noop() {}\n\n    var lib$es6$promise$$internal$$PENDING   = void 0;\n    var lib$es6$promise$$internal$$FULFILLED = 1;\n    var lib$es6$promise$$internal$$REJECTED  = 2;\n\n    var lib$es6$promise$$internal$$GET_THEN_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$selfFulfillment() {\n      return new TypeError(\"You cannot resolve a promise with itself\");\n    }\n\n    function lib$es6$promise$$internal$$cannotReturnOwn() {\n      return new TypeError('A promises callback cannot return that same promise.');\n    }\n\n    function lib$es6$promise$$internal$$getThen(promise) {\n      try {\n        return promise.then;\n      } catch(error) {\n        lib$es6$promise$$internal$$GET_THEN_ERROR.error = error;\n        return lib$es6$promise$$internal$$GET_THEN_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$tryThen(then, value, fulfillmentHandler, rejectionHandler) {\n      try {\n        then.call(value, fulfillmentHandler, rejectionHandler);\n      } catch(e) {\n        return e;\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleForeignThenable(promise, thenable, then) {\n       lib$es6$promise$asap$$asap(function(promise) {\n        var sealed = false;\n        var error = lib$es6$promise$$internal$$tryThen(then, thenable, function(value) {\n          if (sealed) { return; }\n          sealed = true;\n          if (thenable !== value) {\n            lib$es6$promise$$internal$$resolve(promise, value);\n          } else {\n            lib$es6$promise$$internal$$fulfill(promise, value);\n          }\n        }, function(reason) {\n          if (sealed) { return; }\n          sealed = true;\n\n          lib$es6$promise$$internal$$reject(promise, reason);\n        }, 'Settle: ' + (promise._label || ' unknown promise'));\n\n        if (!sealed && error) {\n          sealed = true;\n          lib$es6$promise$$internal$$reject(promise, error);\n        }\n      }, promise);\n    }\n\n    function lib$es6$promise$$internal$$handleOwnThenable(promise, thenable) {\n      if (thenable._state === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, thenable._result);\n      } else if (thenable._state === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, thenable._result);\n      } else {\n        lib$es6$promise$$internal$$subscribe(thenable, undefined, function(value) {\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      }\n    }\n\n    function lib$es6$promise$$internal$$handleMaybeThenable(promise, maybeThenable) {\n      if (maybeThenable.constructor === promise.constructor) {\n        lib$es6$promise$$internal$$handleOwnThenable(promise, maybeThenable);\n      } else {\n        var then = lib$es6$promise$$internal$$getThen(maybeThenable);\n\n        if (then === lib$es6$promise$$internal$$GET_THEN_ERROR) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$GET_THEN_ERROR.error);\n        } else if (then === undefined) {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        } else if (lib$es6$promise$utils$$isFunction(then)) {\n          lib$es6$promise$$internal$$handleForeignThenable(promise, maybeThenable, then);\n        } else {\n          lib$es6$promise$$internal$$fulfill(promise, maybeThenable);\n        }\n      }\n    }\n\n    function lib$es6$promise$$internal$$resolve(promise, value) {\n      if (promise === value) {\n        lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$selfFulfillment());\n      } else if (lib$es6$promise$utils$$objectOrFunction(value)) {\n        lib$es6$promise$$internal$$handleMaybeThenable(promise, value);\n      } else {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publishRejection(promise) {\n      if (promise._onerror) {\n        promise._onerror(promise._result);\n      }\n\n      lib$es6$promise$$internal$$publish(promise);\n    }\n\n    function lib$es6$promise$$internal$$fulfill(promise, value) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n\n      promise._result = value;\n      promise._state = lib$es6$promise$$internal$$FULFILLED;\n\n      if (promise._subscribers.length !== 0) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, promise);\n      }\n    }\n\n    function lib$es6$promise$$internal$$reject(promise, reason) {\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) { return; }\n      promise._state = lib$es6$promise$$internal$$REJECTED;\n      promise._result = reason;\n\n      lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publishRejection, promise);\n    }\n\n    function lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection) {\n      var subscribers = parent._subscribers;\n      var length = subscribers.length;\n\n      parent._onerror = null;\n\n      subscribers[length] = child;\n      subscribers[length + lib$es6$promise$$internal$$FULFILLED] = onFulfillment;\n      subscribers[length + lib$es6$promise$$internal$$REJECTED]  = onRejection;\n\n      if (length === 0 && parent._state) {\n        lib$es6$promise$asap$$asap(lib$es6$promise$$internal$$publish, parent);\n      }\n    }\n\n    function lib$es6$promise$$internal$$publish(promise) {\n      var subscribers = promise._subscribers;\n      var settled = promise._state;\n\n      if (subscribers.length === 0) { return; }\n\n      var child, callback, detail = promise._result;\n\n      for (var i = 0; i < subscribers.length; i += 3) {\n        child = subscribers[i];\n        callback = subscribers[i + settled];\n\n        if (child) {\n          lib$es6$promise$$internal$$invokeCallback(settled, child, callback, detail);\n        } else {\n          callback(detail);\n        }\n      }\n\n      promise._subscribers.length = 0;\n    }\n\n    function lib$es6$promise$$internal$$ErrorObject() {\n      this.error = null;\n    }\n\n    var lib$es6$promise$$internal$$TRY_CATCH_ERROR = new lib$es6$promise$$internal$$ErrorObject();\n\n    function lib$es6$promise$$internal$$tryCatch(callback, detail) {\n      try {\n        return callback(detail);\n      } catch(e) {\n        lib$es6$promise$$internal$$TRY_CATCH_ERROR.error = e;\n        return lib$es6$promise$$internal$$TRY_CATCH_ERROR;\n      }\n    }\n\n    function lib$es6$promise$$internal$$invokeCallback(settled, promise, callback, detail) {\n      var hasCallback = lib$es6$promise$utils$$isFunction(callback),\n          value, error, succeeded, failed;\n\n      if (hasCallback) {\n        value = lib$es6$promise$$internal$$tryCatch(callback, detail);\n\n        if (value === lib$es6$promise$$internal$$TRY_CATCH_ERROR) {\n          failed = true;\n          error = value.error;\n          value = null;\n        } else {\n          succeeded = true;\n        }\n\n        if (promise === value) {\n          lib$es6$promise$$internal$$reject(promise, lib$es6$promise$$internal$$cannotReturnOwn());\n          return;\n        }\n\n      } else {\n        value = detail;\n        succeeded = true;\n      }\n\n      if (promise._state !== lib$es6$promise$$internal$$PENDING) {\n        // noop\n      } else if (hasCallback && succeeded) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      } else if (failed) {\n        lib$es6$promise$$internal$$reject(promise, error);\n      } else if (settled === lib$es6$promise$$internal$$FULFILLED) {\n        lib$es6$promise$$internal$$fulfill(promise, value);\n      } else if (settled === lib$es6$promise$$internal$$REJECTED) {\n        lib$es6$promise$$internal$$reject(promise, value);\n      }\n    }\n\n    function lib$es6$promise$$internal$$initializePromise(promise, resolver) {\n      try {\n        resolver(function resolvePromise(value){\n          lib$es6$promise$$internal$$resolve(promise, value);\n        }, function rejectPromise(reason) {\n          lib$es6$promise$$internal$$reject(promise, reason);\n        });\n      } catch(e) {\n        lib$es6$promise$$internal$$reject(promise, e);\n      }\n    }\n\n    function lib$es6$promise$enumerator$$Enumerator(Constructor, input) {\n      var enumerator = this;\n\n      enumerator._instanceConstructor = Constructor;\n      enumerator.promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (enumerator._validateInput(input)) {\n        enumerator._input     = input;\n        enumerator.length     = input.length;\n        enumerator._remaining = input.length;\n\n        enumerator._init();\n\n        if (enumerator.length === 0) {\n          lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n        } else {\n          enumerator.length = enumerator.length || 0;\n          enumerator._enumerate();\n          if (enumerator._remaining === 0) {\n            lib$es6$promise$$internal$$fulfill(enumerator.promise, enumerator._result);\n          }\n        }\n      } else {\n        lib$es6$promise$$internal$$reject(enumerator.promise, enumerator._validationError());\n      }\n    }\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validateInput = function(input) {\n      return lib$es6$promise$utils$$isArray(input);\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._validationError = function() {\n      return new Error('Array Methods must be provided an Array');\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._init = function() {\n      this._result = new Array(this.length);\n    };\n\n    var lib$es6$promise$enumerator$$default = lib$es6$promise$enumerator$$Enumerator;\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._enumerate = function() {\n      var enumerator = this;\n\n      var length  = enumerator.length;\n      var promise = enumerator.promise;\n      var input   = enumerator._input;\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        enumerator._eachEntry(input[i], i);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._eachEntry = function(entry, i) {\n      var enumerator = this;\n      var c = enumerator._instanceConstructor;\n\n      if (lib$es6$promise$utils$$isMaybeThenable(entry)) {\n        if (entry.constructor === c && entry._state !== lib$es6$promise$$internal$$PENDING) {\n          entry._onerror = null;\n          enumerator._settledAt(entry._state, i, entry._result);\n        } else {\n          enumerator._willSettleAt(c.resolve(entry), i);\n        }\n      } else {\n        enumerator._remaining--;\n        enumerator._result[i] = entry;\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._settledAt = function(state, i, value) {\n      var enumerator = this;\n      var promise = enumerator.promise;\n\n      if (promise._state === lib$es6$promise$$internal$$PENDING) {\n        enumerator._remaining--;\n\n        if (state === lib$es6$promise$$internal$$REJECTED) {\n          lib$es6$promise$$internal$$reject(promise, value);\n        } else {\n          enumerator._result[i] = value;\n        }\n      }\n\n      if (enumerator._remaining === 0) {\n        lib$es6$promise$$internal$$fulfill(promise, enumerator._result);\n      }\n    };\n\n    lib$es6$promise$enumerator$$Enumerator.prototype._willSettleAt = function(promise, i) {\n      var enumerator = this;\n\n      lib$es6$promise$$internal$$subscribe(promise, undefined, function(value) {\n        enumerator._settledAt(lib$es6$promise$$internal$$FULFILLED, i, value);\n      }, function(reason) {\n        enumerator._settledAt(lib$es6$promise$$internal$$REJECTED, i, reason);\n      });\n    };\n    function lib$es6$promise$promise$all$$all(entries) {\n      return new lib$es6$promise$enumerator$$default(this, entries).promise;\n    }\n    var lib$es6$promise$promise$all$$default = lib$es6$promise$promise$all$$all;\n    function lib$es6$promise$promise$race$$race(entries) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n\n      if (!lib$es6$promise$utils$$isArray(entries)) {\n        lib$es6$promise$$internal$$reject(promise, new TypeError('You must pass an array to race.'));\n        return promise;\n      }\n\n      var length = entries.length;\n\n      function onFulfillment(value) {\n        lib$es6$promise$$internal$$resolve(promise, value);\n      }\n\n      function onRejection(reason) {\n        lib$es6$promise$$internal$$reject(promise, reason);\n      }\n\n      for (var i = 0; promise._state === lib$es6$promise$$internal$$PENDING && i < length; i++) {\n        lib$es6$promise$$internal$$subscribe(Constructor.resolve(entries[i]), undefined, onFulfillment, onRejection);\n      }\n\n      return promise;\n    }\n    var lib$es6$promise$promise$race$$default = lib$es6$promise$promise$race$$race;\n    function lib$es6$promise$promise$resolve$$resolve(object) {\n      /*jshint validthis:true */\n      var Constructor = this;\n\n      if (object && typeof object === 'object' && object.constructor === Constructor) {\n        return object;\n      }\n\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$resolve(promise, object);\n      return promise;\n    }\n    var lib$es6$promise$promise$resolve$$default = lib$es6$promise$promise$resolve$$resolve;\n    function lib$es6$promise$promise$reject$$reject(reason) {\n      /*jshint validthis:true */\n      var Constructor = this;\n      var promise = new Constructor(lib$es6$promise$$internal$$noop);\n      lib$es6$promise$$internal$$reject(promise, reason);\n      return promise;\n    }\n    var lib$es6$promise$promise$reject$$default = lib$es6$promise$promise$reject$$reject;\n\n    var lib$es6$promise$promise$$counter = 0;\n\n    function lib$es6$promise$promise$$needsResolver() {\n      throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');\n    }\n\n    function lib$es6$promise$promise$$needsNew() {\n      throw new TypeError(\"Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.\");\n    }\n\n    var lib$es6$promise$promise$$default = lib$es6$promise$promise$$Promise;\n    /**\n      Promise objects represent the eventual result of an asynchronous operation. The\n      primary way of interacting with a promise is through its `then` method, which\n      registers callbacks to receive either a promise's eventual value or the reason\n      why the promise cannot be fulfilled.\n\n      Terminology\n      -----------\n\n      - `promise` is an object or function with a `then` method whose behavior conforms to this specification.\n      - `thenable` is an object or function that defines a `then` method.\n      - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).\n      - `exception` is a value that is thrown using the throw statement.\n      - `reason` is a value that indicates why a promise was rejected.\n      - `settled` the final resting state of a promise, fulfilled or rejected.\n\n      A promise can be in one of three states: pending, fulfilled, or rejected.\n\n      Promises that are fulfilled have a fulfillment value and are in the fulfilled\n      state.  Promises that are rejected have a rejection reason and are in the\n      rejected state.  A fulfillment value is never a thenable.\n\n      Promises can also be said to *resolve* a value.  If this value is also a\n      promise, then the original promise's settled state will match the value's\n      settled state.  So a promise that *resolves* a promise that rejects will\n      itself reject, and a promise that *resolves* a promise that fulfills will\n      itself fulfill.\n\n\n      Basic Usage:\n      ------------\n\n      ```js\n      var promise = new Promise(function(resolve, reject) {\n        // on success\n        resolve(value);\n\n        // on failure\n        reject(reason);\n      });\n\n      promise.then(function(value) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Advanced Usage:\n      ---------------\n\n      Promises shine when abstracting away asynchronous interactions such as\n      `XMLHttpRequest`s.\n\n      ```js\n      function getJSON(url) {\n        return new Promise(function(resolve, reject){\n          var xhr = new XMLHttpRequest();\n\n          xhr.open('GET', url);\n          xhr.onreadystatechange = handler;\n          xhr.responseType = 'json';\n          xhr.setRequestHeader('Accept', 'application/json');\n          xhr.send();\n\n          function handler() {\n            if (this.readyState === this.DONE) {\n              if (this.status === 200) {\n                resolve(this.response);\n              } else {\n                reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));\n              }\n            }\n          };\n        });\n      }\n\n      getJSON('/posts.json').then(function(json) {\n        // on fulfillment\n      }, function(reason) {\n        // on rejection\n      });\n      ```\n\n      Unlike callbacks, promises are great composable primitives.\n\n      ```js\n      Promise.all([\n        getJSON('/posts'),\n        getJSON('/comments')\n      ]).then(function(values){\n        values[0] // => postsJSON\n        values[1] // => commentsJSON\n\n        return values;\n      });\n      ```\n\n      @class Promise\n      @param {function} resolver\n      Useful for tooling.\n      @constructor\n    */\n    function lib$es6$promise$promise$$Promise(resolver) {\n      this._id = lib$es6$promise$promise$$counter++;\n      this._state = undefined;\n      this._result = undefined;\n      this._subscribers = [];\n\n      if (lib$es6$promise$$internal$$noop !== resolver) {\n        if (!lib$es6$promise$utils$$isFunction(resolver)) {\n          lib$es6$promise$promise$$needsResolver();\n        }\n\n        if (!(this instanceof lib$es6$promise$promise$$Promise)) {\n          lib$es6$promise$promise$$needsNew();\n        }\n\n        lib$es6$promise$$internal$$initializePromise(this, resolver);\n      }\n    }\n\n    lib$es6$promise$promise$$Promise.all = lib$es6$promise$promise$all$$default;\n    lib$es6$promise$promise$$Promise.race = lib$es6$promise$promise$race$$default;\n    lib$es6$promise$promise$$Promise.resolve = lib$es6$promise$promise$resolve$$default;\n    lib$es6$promise$promise$$Promise.reject = lib$es6$promise$promise$reject$$default;\n    lib$es6$promise$promise$$Promise._setScheduler = lib$es6$promise$asap$$setScheduler;\n    lib$es6$promise$promise$$Promise._setAsap = lib$es6$promise$asap$$setAsap;\n    lib$es6$promise$promise$$Promise._asap = lib$es6$promise$asap$$asap;\n\n    lib$es6$promise$promise$$Promise.prototype = {\n      constructor: lib$es6$promise$promise$$Promise,\n\n    /**\n      The primary way of interacting with a promise is through its `then` method,\n      which registers callbacks to receive either a promise's eventual value or the\n      reason why the promise cannot be fulfilled.\n\n      ```js\n      findUser().then(function(user){\n        // user is available\n      }, function(reason){\n        // user is unavailable, and you are given the reason why\n      });\n      ```\n\n      Chaining\n      --------\n\n      The return value of `then` is itself a promise.  This second, 'downstream'\n      promise is resolved with the return value of the first promise's fulfillment\n      or rejection handler, or rejected if the handler throws an exception.\n\n      ```js\n      findUser().then(function (user) {\n        return user.name;\n      }, function (reason) {\n        return 'default name';\n      }).then(function (userName) {\n        // If `findUser` fulfilled, `userName` will be the user's name, otherwise it\n        // will be `'default name'`\n      });\n\n      findUser().then(function (user) {\n        throw new Error('Found user, but still unhappy');\n      }, function (reason) {\n        throw new Error('`findUser` rejected and we're unhappy');\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.\n        // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.\n      });\n      ```\n      If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.\n\n      ```js\n      findUser().then(function (user) {\n        throw new PedagogicalException('Upstream error');\n      }).then(function (value) {\n        // never reached\n      }).then(function (value) {\n        // never reached\n      }, function (reason) {\n        // The `PedgagocialException` is propagated all the way down to here\n      });\n      ```\n\n      Assimilation\n      ------------\n\n      Sometimes the value you want to propagate to a downstream promise can only be\n      retrieved asynchronously. This can be achieved by returning a promise in the\n      fulfillment or rejection handler. The downstream promise will then be pending\n      until the returned promise is settled. This is called *assimilation*.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // The user's comments are now available\n      });\n      ```\n\n      If the assimliated promise rejects, then the downstream promise will also reject.\n\n      ```js\n      findUser().then(function (user) {\n        return findCommentsByAuthor(user);\n      }).then(function (comments) {\n        // If `findCommentsByAuthor` fulfills, we'll have the value here\n      }, function (reason) {\n        // If `findCommentsByAuthor` rejects, we'll have the reason here\n      });\n      ```\n\n      Simple Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var result;\n\n      try {\n        result = findResult();\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n      findResult(function(result, err){\n        if (err) {\n          // failure\n        } else {\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findResult().then(function(result){\n        // success\n      }, function(reason){\n        // failure\n      });\n      ```\n\n      Advanced Example\n      --------------\n\n      Synchronous Example\n\n      ```javascript\n      var author, books;\n\n      try {\n        author = findAuthor();\n        books  = findBooksByAuthor(author);\n        // success\n      } catch(reason) {\n        // failure\n      }\n      ```\n\n      Errback Example\n\n      ```js\n\n      function foundBooks(books) {\n\n      }\n\n      function failure(reason) {\n\n      }\n\n      findAuthor(function(author, err){\n        if (err) {\n          failure(err);\n          // failure\n        } else {\n          try {\n            findBoooksByAuthor(author, function(books, err) {\n              if (err) {\n                failure(err);\n              } else {\n                try {\n                  foundBooks(books);\n                } catch(reason) {\n                  failure(reason);\n                }\n              }\n            });\n          } catch(error) {\n            failure(err);\n          }\n          // success\n        }\n      });\n      ```\n\n      Promise Example;\n\n      ```javascript\n      findAuthor().\n        then(findBooksByAuthor).\n        then(function(books){\n          // found books\n      }).catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method then\n      @param {Function} onFulfilled\n      @param {Function} onRejected\n      Useful for tooling.\n      @return {Promise}\n    */\n      then: function(onFulfillment, onRejection) {\n        var parent = this;\n        var state = parent._state;\n\n        if (state === lib$es6$promise$$internal$$FULFILLED && !onFulfillment || state === lib$es6$promise$$internal$$REJECTED && !onRejection) {\n          return this;\n        }\n\n        var child = new this.constructor(lib$es6$promise$$internal$$noop);\n        var result = parent._result;\n\n        if (state) {\n          var callback = arguments[state - 1];\n          lib$es6$promise$asap$$asap(function(){\n            lib$es6$promise$$internal$$invokeCallback(state, child, callback, result);\n          });\n        } else {\n          lib$es6$promise$$internal$$subscribe(parent, child, onFulfillment, onRejection);\n        }\n\n        return child;\n      },\n\n    /**\n      `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same\n      as the catch block of a try/catch statement.\n\n      ```js\n      function findAuthor(){\n        throw new Error('couldn't find that author');\n      }\n\n      // synchronous\n      try {\n        findAuthor();\n      } catch(reason) {\n        // something went wrong\n      }\n\n      // async with promises\n      findAuthor().catch(function(reason){\n        // something went wrong\n      });\n      ```\n\n      @method catch\n      @param {Function} onRejection\n      Useful for tooling.\n      @return {Promise}\n    */\n      'catch': function(onRejection) {\n        return this.then(null, onRejection);\n      }\n    };\n    function lib$es6$promise$polyfill$$polyfill() {\n      var local;\n\n      if (typeof global !== 'undefined') {\n          local = global;\n      } else if (typeof self !== 'undefined') {\n          local = self;\n      } else {\n          try {\n              local = Function('return this')();\n          } catch (e) {\n              throw new Error('polyfill failed because global object is unavailable in this environment');\n          }\n      }\n\n      var P = local.Promise;\n\n      if (P && Object.prototype.toString.call(P.resolve()) === '[object Promise]' && !P.cast) {\n        return;\n      }\n\n      local.Promise = lib$es6$promise$promise$$default;\n    }\n    var lib$es6$promise$polyfill$$default = lib$es6$promise$polyfill$$polyfill;\n\n    var lib$es6$promise$umd$$ES6Promise = {\n      'Promise': lib$es6$promise$promise$$default,\n      'polyfill': lib$es6$promise$polyfill$$default\n    };\n\n    /* global define:true module:true window: true */\n    if (typeof define === 'function' && define['amd']) {\n      define(function() { return lib$es6$promise$umd$$ES6Promise; });\n    } else if (typeof module !== 'undefined' && module['exports']) {\n      module['exports'] = lib$es6$promise$umd$$ES6Promise;\n    } else if (typeof this !== 'undefined') {\n      this['ES6Promise'] = lib$es6$promise$umd$$ES6Promise;\n    }\n\n    lib$es6$promise$polyfill$$default();\n}).call(this);\n\n","/* -*- mode: javascript; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n\n// \n// Javascript ZLib\n// By Thomas Down 2010-2011\n//\n// Based very heavily on portions of jzlib (by ymnk@jcraft.com), who in\n// turn credits Jean-loup Gailly and Mark Adler for the original zlib code.\n//\n// inflate.js: ZLib inflate code\n//\n\n//\n// Shared constants\n//\n\nvar MAX_WBITS=15; // 32K LZ77 window\nvar DEF_WBITS=MAX_WBITS;\nvar MAX_MEM_LEVEL=9;\nvar MANY=1440;\nvar BMAX = 15;\n\n// preset dictionary flag in zlib header\nvar PRESET_DICT=0x20;\n\nvar Z_NO_FLUSH=0;\nvar Z_PARTIAL_FLUSH=1;\nvar Z_SYNC_FLUSH=2;\nvar Z_FULL_FLUSH=3;\nvar Z_FINISH=4;\n\nvar Z_DEFLATED=8;\n\nvar Z_OK=0;\nvar Z_STREAM_END=1;\nvar Z_NEED_DICT=2;\nvar Z_ERRNO=-1;\nvar Z_STREAM_ERROR=-2;\nvar Z_DATA_ERROR=-3;\nvar Z_MEM_ERROR=-4;\nvar Z_BUF_ERROR=-5;\nvar Z_VERSION_ERROR=-6;\n\nvar METHOD=0;   // waiting for method byte\nvar FLAG=1;     // waiting for flag byte\nvar DICT4=2;    // four dictionary check bytes to go\nvar DICT3=3;    // three dictionary check bytes to go\nvar DICT2=4;    // two dictionary check bytes to go\nvar DICT1=5;    // one dictionary check byte to go\nvar DICT0=6;    // waiting for inflateSetDictionary\nvar BLOCKS=7;   // decompressing blocks\nvar CHECK4=8;   // four check bytes to go\nvar CHECK3=9;   // three check bytes to go\nvar CHECK2=10;  // two check bytes to go\nvar CHECK1=11;  // one check byte to go\nvar DONE=12;    // finished check, done\nvar BAD=13;     // got an error--stay here\n\nvar inflate_mask = [0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff];\n\nvar IB_TYPE=0;  // get type bits (3, including end bit)\nvar IB_LENS=1;  // get lengths for stored\nvar IB_STORED=2;// processing stored block\nvar IB_TABLE=3; // get table lengths\nvar IB_BTREE=4; // get bit lengths tree for a dynamic block\nvar IB_DTREE=5; // get length, distance trees for a dynamic block\nvar IB_CODES=6; // processing fixed or dynamic block\nvar IB_DRY=7;   // output remaining window bytes\nvar IB_DONE=8;  // finished last block, done\nvar IB_BAD=9;   // ot a data error--stuck here\n\nvar fixed_bl = 9;\nvar fixed_bd = 5;\n\nvar fixed_tl = [\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,192,\n    80,7,10, 0,8,96, 0,8,32, 0,9,160,\n    0,8,0, 0,8,128, 0,8,64, 0,9,224,\n    80,7,6, 0,8,88, 0,8,24, 0,9,144,\n    83,7,59, 0,8,120, 0,8,56, 0,9,208,\n    81,7,17, 0,8,104, 0,8,40, 0,9,176,\n    0,8,8, 0,8,136, 0,8,72, 0,9,240,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,200,\n    81,7,13, 0,8,100, 0,8,36, 0,9,168,\n    0,8,4, 0,8,132, 0,8,68, 0,9,232,\n    80,7,8, 0,8,92, 0,8,28, 0,9,152,\n    84,7,83, 0,8,124, 0,8,60, 0,9,216,\n    82,7,23, 0,8,108, 0,8,44, 0,9,184,\n    0,8,12, 0,8,140, 0,8,76, 0,9,248,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,196,\n    81,7,11, 0,8,98, 0,8,34, 0,9,164,\n    0,8,2, 0,8,130, 0,8,66, 0,9,228,\n    80,7,7, 0,8,90, 0,8,26, 0,9,148,\n    84,7,67, 0,8,122, 0,8,58, 0,9,212,\n    82,7,19, 0,8,106, 0,8,42, 0,9,180,\n    0,8,10, 0,8,138, 0,8,74, 0,9,244,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,204,\n    81,7,15, 0,8,102, 0,8,38, 0,9,172,\n    0,8,6, 0,8,134, 0,8,70, 0,9,236,\n    80,7,9, 0,8,94, 0,8,30, 0,9,156,\n    84,7,99, 0,8,126, 0,8,62, 0,9,220,\n    82,7,27, 0,8,110, 0,8,46, 0,9,188,\n    0,8,14, 0,8,142, 0,8,78, 0,9,252,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,194,\n    80,7,10, 0,8,97, 0,8,33, 0,9,162,\n    0,8,1, 0,8,129, 0,8,65, 0,9,226,\n    80,7,6, 0,8,89, 0,8,25, 0,9,146,\n    83,7,59, 0,8,121, 0,8,57, 0,9,210,\n    81,7,17, 0,8,105, 0,8,41, 0,9,178,\n    0,8,9, 0,8,137, 0,8,73, 0,9,242,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,202,\n    81,7,13, 0,8,101, 0,8,37, 0,9,170,\n    0,8,5, 0,8,133, 0,8,69, 0,9,234,\n    80,7,8, 0,8,93, 0,8,29, 0,9,154,\n    84,7,83, 0,8,125, 0,8,61, 0,9,218,\n    82,7,23, 0,8,109, 0,8,45, 0,9,186,\n    0,8,13, 0,8,141, 0,8,77, 0,9,250,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,198,\n    81,7,11, 0,8,99, 0,8,35, 0,9,166,\n    0,8,3, 0,8,131, 0,8,67, 0,9,230,\n    80,7,7, 0,8,91, 0,8,27, 0,9,150,\n    84,7,67, 0,8,123, 0,8,59, 0,9,214,\n    82,7,19, 0,8,107, 0,8,43, 0,9,182,\n    0,8,11, 0,8,139, 0,8,75, 0,9,246,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,206,\n    81,7,15, 0,8,103, 0,8,39, 0,9,174,\n    0,8,7, 0,8,135, 0,8,71, 0,9,238,\n    80,7,9, 0,8,95, 0,8,31, 0,9,158,\n    84,7,99, 0,8,127, 0,8,63, 0,9,222,\n    82,7,27, 0,8,111, 0,8,47, 0,9,190,\n    0,8,15, 0,8,143, 0,8,79, 0,9,254,\n    96,7,256, 0,8,80, 0,8,16, 84,8,115,\n    82,7,31, 0,8,112, 0,8,48, 0,9,193,\n\n    80,7,10, 0,8,96, 0,8,32, 0,9,161,\n    0,8,0, 0,8,128, 0,8,64, 0,9,225,\n    80,7,6, 0,8,88, 0,8,24, 0,9,145,\n    83,7,59, 0,8,120, 0,8,56, 0,9,209,\n    81,7,17, 0,8,104, 0,8,40, 0,9,177,\n    0,8,8, 0,8,136, 0,8,72, 0,9,241,\n    80,7,4, 0,8,84, 0,8,20, 85,8,227,\n    83,7,43, 0,8,116, 0,8,52, 0,9,201,\n    81,7,13, 0,8,100, 0,8,36, 0,9,169,\n    0,8,4, 0,8,132, 0,8,68, 0,9,233,\n    80,7,8, 0,8,92, 0,8,28, 0,9,153,\n    84,7,83, 0,8,124, 0,8,60, 0,9,217,\n    82,7,23, 0,8,108, 0,8,44, 0,9,185,\n    0,8,12, 0,8,140, 0,8,76, 0,9,249,\n    80,7,3, 0,8,82, 0,8,18, 85,8,163,\n    83,7,35, 0,8,114, 0,8,50, 0,9,197,\n    81,7,11, 0,8,98, 0,8,34, 0,9,165,\n    0,8,2, 0,8,130, 0,8,66, 0,9,229,\n    80,7,7, 0,8,90, 0,8,26, 0,9,149,\n    84,7,67, 0,8,122, 0,8,58, 0,9,213,\n    82,7,19, 0,8,106, 0,8,42, 0,9,181,\n    0,8,10, 0,8,138, 0,8,74, 0,9,245,\n    80,7,5, 0,8,86, 0,8,22, 192,8,0,\n    83,7,51, 0,8,118, 0,8,54, 0,9,205,\n    81,7,15, 0,8,102, 0,8,38, 0,9,173,\n    0,8,6, 0,8,134, 0,8,70, 0,9,237,\n    80,7,9, 0,8,94, 0,8,30, 0,9,157,\n    84,7,99, 0,8,126, 0,8,62, 0,9,221,\n    82,7,27, 0,8,110, 0,8,46, 0,9,189,\n    0,8,14, 0,8,142, 0,8,78, 0,9,253,\n    96,7,256, 0,8,81, 0,8,17, 85,8,131,\n    82,7,31, 0,8,113, 0,8,49, 0,9,195,\n    80,7,10, 0,8,97, 0,8,33, 0,9,163,\n    0,8,1, 0,8,129, 0,8,65, 0,9,227,\n    80,7,6, 0,8,89, 0,8,25, 0,9,147,\n    83,7,59, 0,8,121, 0,8,57, 0,9,211,\n    81,7,17, 0,8,105, 0,8,41, 0,9,179,\n    0,8,9, 0,8,137, 0,8,73, 0,9,243,\n    80,7,4, 0,8,85, 0,8,21, 80,8,258,\n    83,7,43, 0,8,117, 0,8,53, 0,9,203,\n    81,7,13, 0,8,101, 0,8,37, 0,9,171,\n    0,8,5, 0,8,133, 0,8,69, 0,9,235,\n    80,7,8, 0,8,93, 0,8,29, 0,9,155,\n    84,7,83, 0,8,125, 0,8,61, 0,9,219,\n    82,7,23, 0,8,109, 0,8,45, 0,9,187,\n    0,8,13, 0,8,141, 0,8,77, 0,9,251,\n    80,7,3, 0,8,83, 0,8,19, 85,8,195,\n    83,7,35, 0,8,115, 0,8,51, 0,9,199,\n    81,7,11, 0,8,99, 0,8,35, 0,9,167,\n    0,8,3, 0,8,131, 0,8,67, 0,9,231,\n    80,7,7, 0,8,91, 0,8,27, 0,9,151,\n    84,7,67, 0,8,123, 0,8,59, 0,9,215,\n    82,7,19, 0,8,107, 0,8,43, 0,9,183,\n    0,8,11, 0,8,139, 0,8,75, 0,9,247,\n    80,7,5, 0,8,87, 0,8,23, 192,8,0,\n    83,7,51, 0,8,119, 0,8,55, 0,9,207,\n    81,7,15, 0,8,103, 0,8,39, 0,9,175,\n    0,8,7, 0,8,135, 0,8,71, 0,9,239,\n    80,7,9, 0,8,95, 0,8,31, 0,9,159,\n    84,7,99, 0,8,127, 0,8,63, 0,9,223,\n    82,7,27, 0,8,111, 0,8,47, 0,9,191,\n    0,8,15, 0,8,143, 0,8,79, 0,9,255\n];\nvar fixed_td = [\n    80,5,1, 87,5,257, 83,5,17, 91,5,4097,\n    81,5,5, 89,5,1025, 85,5,65, 93,5,16385,\n    80,5,3, 88,5,513, 84,5,33, 92,5,8193,\n    82,5,9, 90,5,2049, 86,5,129, 192,5,24577,\n    80,5,2, 87,5,385, 83,5,25, 91,5,6145,\n    81,5,7, 89,5,1537, 85,5,97, 93,5,24577,\n    80,5,4, 88,5,769, 84,5,49, 92,5,12289,\n    82,5,13, 90,5,3073, 86,5,193, 192,5,24577\n];\n\n  // Tables for deflate from PKZIP's appnote.txt.\n  var cplens = [ // Copy lengths for literal codes 257..285\n        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n  ];\n\n  // see note #13 above about 258\n  var cplext = [ // Extra bits for literal codes 257..285\n        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,\n        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112  // 112==invalid\n  ];\n\n var cpdist = [ // Copy offsets for distance codes 0..29\n        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n        8193, 12289, 16385, 24577\n  ];\n\n  var cpdext = [ // Extra bits for distance codes\n        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,\n        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,\n        12, 12, 13, 13];\n\n//\n// ZStream.java\n//\n\nfunction ZStream() {\n}\n\n\nZStream.prototype.inflateInit = function(w, nowrap) {\n    if (!w) {\n\tw = DEF_WBITS;\n    }\n    if (nowrap) {\n\tnowrap = false;\n    }\n    this.istate = new Inflate();\n    return this.istate.inflateInit(this, nowrap?-w:w);\n}\n\nZStream.prototype.inflate = function(f) {\n    if(this.istate==null) return Z_STREAM_ERROR;\n    return this.istate.inflate(this, f);\n}\n\nZStream.prototype.inflateEnd = function(){\n    if(this.istate==null) return Z_STREAM_ERROR;\n    var ret=istate.inflateEnd(this);\n    this.istate = null;\n    return ret;\n}\nZStream.prototype.inflateSync = function(){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSync(this);\n}\nZStream.prototype.inflateSetDictionary = function(dictionary, dictLength){\n    // if(istate == null) return Z_STREAM_ERROR;\n    return istate.inflateSetDictionary(this, dictionary, dictLength);\n}\n\n/*\n\n  public int deflateInit(int level){\n    return deflateInit(level, MAX_WBITS);\n  }\n  public int deflateInit(int level, boolean nowrap){\n    return deflateInit(level, MAX_WBITS, nowrap);\n  }\n  public int deflateInit(int level, int bits){\n    return deflateInit(level, bits, false);\n  }\n  public int deflateInit(int level, int bits, boolean nowrap){\n    dstate=new Deflate();\n    return dstate.deflateInit(this, level, nowrap?-bits:bits);\n  }\n  public int deflate(int flush){\n    if(dstate==null){\n      return Z_STREAM_ERROR;\n    }\n    return dstate.deflate(this, flush);\n  }\n  public int deflateEnd(){\n    if(dstate==null) return Z_STREAM_ERROR;\n    int ret=dstate.deflateEnd();\n    dstate=null;\n    return ret;\n  }\n  public int deflateParams(int level, int strategy){\n    if(dstate==null) return Z_STREAM_ERROR;\n    return dstate.deflateParams(this, level, strategy);\n  }\n  public int deflateSetDictionary (byte[] dictionary, int dictLength){\n    if(dstate == null)\n      return Z_STREAM_ERROR;\n    return dstate.deflateSetDictionary(this, dictionary, dictLength);\n  }\n\n*/\n\n/*\n  // Flush as much pending output as possible. All deflate() output goes\n  // through this function so some applications may wish to modify it\n  // to avoid allocating a large strm->next_out buffer and copying into it.\n  // (See also read_buf()).\n  void flush_pending(){\n    int len=dstate.pending;\n\n    if(len>avail_out) len=avail_out;\n    if(len==0) return;\n\n    if(dstate.pending_buf.length<=dstate.pending_out ||\n       next_out.length<=next_out_index ||\n       dstate.pending_buf.length<(dstate.pending_out+len) ||\n       next_out.length<(next_out_index+len)){\n      System.out.println(dstate.pending_buf.length+\", \"+dstate.pending_out+\n\t\t\t \", \"+next_out.length+\", \"+next_out_index+\", \"+len);\n      System.out.println(\"avail_out=\"+avail_out);\n    }\n\n    System.arraycopy(dstate.pending_buf, dstate.pending_out,\n\t\t     next_out, next_out_index, len);\n\n    next_out_index+=len;\n    dstate.pending_out+=len;\n    total_out+=len;\n    avail_out-=len;\n    dstate.pending-=len;\n    if(dstate.pending==0){\n      dstate.pending_out=0;\n    }\n  }\n\n  // Read a new buffer from the current input stream, update the adler32\n  // and total number of bytes read.  All deflate() input goes through\n  // this function so some applications may wish to modify it to avoid\n  // allocating a large strm->next_in buffer and copying from it.\n  // (See also flush_pending()).\n  int read_buf(byte[] buf, int start, int size) {\n    int len=avail_in;\n\n    if(len>size) len=size;\n    if(len==0) return 0;\n\n    avail_in-=len;\n\n    if(dstate.noheader==0) {\n      adler=_adler.adler32(adler, next_in, next_in_index, len);\n    }\n    System.arraycopy(next_in, next_in_index, buf, start, len);\n    next_in_index  += len;\n    total_in += len;\n    return len;\n  }\n\n  public void free(){\n    next_in=null;\n    next_out=null;\n    msg=null;\n    _adler=null;\n  }\n}\n*/\n\n\n//\n// Inflate.java\n//\n\nfunction Inflate() {\n    this.was = [0];\n}\n\nInflate.prototype.inflateReset = function(z) {\n    if(z == null || z.istate == null) return Z_STREAM_ERROR;\n    \n    z.total_in = z.total_out = 0;\n    z.msg = null;\n    z.istate.mode = z.istate.nowrap!=0 ? BLOCKS : METHOD;\n    z.istate.blocks.reset(z, null);\n    return Z_OK;\n}\n\nInflate.prototype.inflateEnd = function(z){\n    if(this.blocks != null)\n      this.blocks.free(z);\n    this.blocks=null;\n    return Z_OK;\n}\n\nInflate.prototype.inflateInit = function(z, w){\n    z.msg = null;\n    this.blocks = null;\n\n    // handle undocumented nowrap option (no zlib header or check)\n    nowrap = 0;\n    if(w < 0){\n      w = - w;\n      nowrap = 1;\n    }\n\n    // set window size\n    if(w<8 ||w>15){\n      this.inflateEnd(z);\n      return Z_STREAM_ERROR;\n    }\n    this.wbits=w;\n\n    z.istate.blocks=new InfBlocks(z, \n\t\t\t\t  z.istate.nowrap!=0 ? null : this,\n\t\t\t\t  1<<w);\n\n    // reset state\n    this.inflateReset(z);\n    return Z_OK;\n  }\n\nInflate.prototype.inflate = function(z, f){\n    var r, b;\n\n    if(z == null || z.istate == null || z.next_in == null)\n      return Z_STREAM_ERROR;\n    f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n    r = Z_BUF_ERROR;\n    while (true){\n      switch (z.istate.mode){\n      case METHOD:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        if(((z.istate.method = z.next_in[z.next_in_index++])&0xf)!=Z_DEFLATED){\n          z.istate.mode = BAD;\n          z.msg=\"unknown compression method\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        if((z.istate.method>>4)+8>z.istate.wbits){\n          z.istate.mode = BAD;\n          z.msg=\"invalid window size\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n        z.istate.mode=FLAG;\n      case FLAG:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        b = (z.next_in[z.next_in_index++])&0xff;\n\n        if((((z.istate.method << 8)+b) % 31)!=0){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect header check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        if((b&PRESET_DICT)==0){\n          z.istate.mode = BLOCKS;\n          break;\n        }\n        z.istate.mode = DICT4;\n      case DICT4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=DICT3;\n      case DICT3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode=DICT2;\n      case DICT2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode=DICT1;\n      case DICT1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need += (z.next_in[z.next_in_index++]&0xff);\n        z.adler = z.istate.need;\n        z.istate.mode = DICT0;\n        return Z_NEED_DICT;\n      case DICT0:\n        z.istate.mode = BAD;\n        z.msg = \"need dictionary\";\n        z.istate.marker = 0;       // can try inflateSync\n        return Z_STREAM_ERROR;\n      case BLOCKS:\n\n        r = z.istate.blocks.proc(z, r);\n        if(r == Z_DATA_ERROR){\n          z.istate.mode = BAD;\n          z.istate.marker = 0;     // can try inflateSync\n          break;\n        }\n        if(r == Z_OK){\n          r = f;\n        }\n        if(r != Z_STREAM_END){\n          return r;\n        }\n        r = f;\n        z.istate.blocks.reset(z, z.istate.was);\n        if(z.istate.nowrap!=0){\n          z.istate.mode=DONE;\n          break;\n        }\n        z.istate.mode=CHECK4;\n      case CHECK4:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need=((z.next_in[z.next_in_index++]&0xff)<<24)&0xff000000;\n        z.istate.mode=CHECK3;\n      case CHECK3:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<16)&0xff0000;\n        z.istate.mode = CHECK2;\n      case CHECK2:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=((z.next_in[z.next_in_index++]&0xff)<<8)&0xff00;\n        z.istate.mode = CHECK1;\n      case CHECK1:\n\n        if(z.avail_in==0)return r;r=f;\n\n        z.avail_in--; z.total_in++;\n        z.istate.need+=(z.next_in[z.next_in_index++]&0xff);\n\n        if(((z.istate.was[0])) != ((z.istate.need))){\n          z.istate.mode = BAD;\n          z.msg = \"incorrect data check\";\n          z.istate.marker = 5;       // can't try inflateSync\n          break;\n        }\n\n        z.istate.mode = DONE;\n      case DONE:\n        return Z_STREAM_END;\n      case BAD:\n        return Z_DATA_ERROR;\n      default:\n        return Z_STREAM_ERROR;\n      }\n    }\n  }\n\n\nInflate.prototype.inflateSetDictionary = function(z,  dictionary, dictLength) {\n    var index=0;\n    var length = dictLength;\n    if(z==null || z.istate == null|| z.istate.mode != DICT0)\n      return Z_STREAM_ERROR;\n\n    if(z._adler.adler32(1, dictionary, 0, dictLength)!=z.adler){\n      return Z_DATA_ERROR;\n    }\n\n    z.adler = z._adler.adler32(0, null, 0, 0);\n\n    if(length >= (1<<z.istate.wbits)){\n      length = (1<<z.istate.wbits)-1;\n      index=dictLength - length;\n    }\n    z.istate.blocks.set_dictionary(dictionary, index, length);\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n  }\n\n//  static private byte[] mark = {(byte)0, (byte)0, (byte)0xff, (byte)0xff};\nvar mark = [0, 0, 255, 255]\n\nInflate.prototype.inflateSync = function(z){\n    var n;       // number of bytes to look at\n    var p;       // pointer to bytes\n    var m;       // number of marker bytes found in a row\n    var r, w;   // temporaries to save total_in and total_out\n\n    // set up\n    if(z == null || z.istate == null)\n      return Z_STREAM_ERROR;\n    if(z.istate.mode != BAD){\n      z.istate.mode = BAD;\n      z.istate.marker = 0;\n    }\n    if((n=z.avail_in)==0)\n      return Z_BUF_ERROR;\n    p=z.next_in_index;\n    m=z.istate.marker;\n\n    // search\n    while (n!=0 && m < 4){\n      if(z.next_in[p] == mark[m]){\n        m++;\n      }\n      else if(z.next_in[p]!=0){\n        m = 0;\n      }\n      else{\n        m = 4 - m;\n      }\n      p++; n--;\n    }\n\n    // restore\n    z.total_in += p-z.next_in_index;\n    z.next_in_index = p;\n    z.avail_in = n;\n    z.istate.marker = m;\n\n    // return no joy or set up to restart on a new block\n    if(m != 4){\n      return Z_DATA_ERROR;\n    }\n    r=z.total_in;  w=z.total_out;\n    this.inflateReset(z);\n    z.total_in=r;  z.total_out = w;\n    z.istate.mode = BLOCKS;\n    return Z_OK;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n  // implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH\n  // but removes the length bytes of the resulting empty stored block. When\n  // decompressing, PPP checks that at the end of input packet, inflate is\n  // waiting for these length bytes.\nInflate.prototype.inflateSyncPoint = function(z){\n    if(z == null || z.istate == null || z.istate.blocks == null)\n      return Z_STREAM_ERROR;\n    return z.istate.blocks.sync_point();\n}\n\n\n//\n// InfBlocks.java\n//\n\nvar INFBLOCKS_BORDER = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\nfunction InfBlocks(z, checkfn, w) {\n    this.hufts=new Int32Array(MANY*3);\n    this.window=new Uint8Array(w);\n    this.end=w;\n    this.checkfn = checkfn;\n    this.mode = IB_TYPE;\n    this.reset(z, null);\n\n    this.left = 0;            // if STORED, bytes left to copy \n\n    this.table = 0;           // table lengths (14 bits) \n    this.index = 0;           // index into blens (or border) \n    this.blens = null;         // bit lengths of codes \n    this.bb=new Int32Array(1); // bit length tree depth \n    this.tb=new Int32Array(1); // bit length decoding tree \n\n    this.codes = new InfCodes();\n\n    this.last = 0;            // true if this block is the last block \n\n  // mode independent information \n    this.bitk = 0;            // bits in bit buffer \n    this.bitb = 0;            // bit buffer \n    this.read = 0;            // window read pointer \n    this.write = 0;           // window write pointer \n    this.check = 0;          // check on output \n\n    this.inftree=new InfTree();\n}\n\n\n\n\nInfBlocks.prototype.reset = function(z, c){\n    if(c) c[0]=this.check;\n    if(this.mode==IB_CODES){\n      this.codes.free(z);\n    }\n    this.mode=IB_TYPE;\n    this.bitk=0;\n    this.bitb=0;\n    this.read=this.write=0;\n\n    if(this.checkfn)\n      z.adler=this.check=z._adler.adler32(0, null, 0, 0);\n  }\n\n InfBlocks.prototype.proc = function(z, r){\n    var t;              // temporary storage\n    var b;              // bit buffer\n    var k;              // bits in bit buffer\n    var p;              // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n\n    // copy input/output information to locals (UPDATE macro restores)\n    {p=z.next_in_index;n=z.avail_in;b=this.bitb;k=this.bitk;}\n    {q=this.write;m=(q<this.read ? this.read-q-1 : this.end-q);}\n\n    // process input based on current state\n    while(true){\n      switch (this.mode){\n      case IB_TYPE:\n\n\twhile(k<(3)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\tt = (b & 7);\n\tthis.last = t & 1;\n\n\tswitch (t >>> 1){\n        case 0:                         // stored \n          {b>>>=(3);k-=(3);}\n          t = k & 7;                    // go to byte boundary\n\n          {b>>>=(t);k-=(t);}\n          this.mode = IB_LENS;                  // get length of stored block\n          break;\n        case 1:                         // fixed\n          {\n              var bl=new Int32Array(1);\n\t      var bd=new Int32Array(1);\n              var tl=[];\n\t      var td=[];\n\n\t      inflate_trees_fixed(bl, bd, tl, td, z);\n              this.codes.init(bl[0], bd[0], tl[0], 0, td[0], 0, z);\n          }\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_CODES;\n          break;\n        case 2:                         // dynamic\n\n          {b>>>=(3);k-=(3);}\n\n          this.mode = IB_TABLE;\n          break;\n        case 3:                         // illegal\n\n          {b>>>=(3);k-=(3);}\n          this.mode = BAD;\n          z.msg = \"invalid block type\";\n          r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tbreak;\n      case IB_LENS:\n\twhile(k<(32)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)){\n\t  this.mode = BAD;\n\t  z.msg = \"invalid stored block lengths\";\n\t  r = Z_DATA_ERROR;\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\tthis.left = (b & 0xffff);\n\tb = k = 0;                       // dump bits\n\tthis.mode = this.left!=0 ? IB_STORED : (this.last!=0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_STORED:\n\tif (n == 0){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tif(m==0){\n\t  if(q==end&&read!=0){\n\t    q=0; m=(q<this.read ? this.read-q-1 : this.end-q);\n\t  }\n\t  if(m==0){\n\t    this.write=q; \n\t    r=this.inflate_flush(z,r);\n\t    q=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    if(q==this.end && this.read != 0){\n\t      q=0; m = (q < this.read ? this.read-q-1 : this.end-q);\n\t    }\n\t    if(m==0){\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\tt = this.left;\n\tif(t>n) t = n;\n\tif(t>m) t = m;\n\tarrayCopy(z.next_in, p, this.window, q, t);\n\tp += t;  n -= t;\n\tq += t;  m -= t;\n\tif ((this.left -= t) != 0)\n\t  break;\n\tthis.mode = (this.last != 0 ? IB_DRY : IB_TYPE);\n\tbreak;\n      case IB_TABLE:\n\n\twhile(k<(14)){\n\t  if(n!=0){\n\t    r=Z_OK;\n\t  }\n\t  else{\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;\n\t    z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  };\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.table = t = (b & 0x3fff);\n\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)\n\t  {\n\t    this.mode = IB_BAD;\n\t    z.msg = \"too many length or distance symbols\";\n\t    r = Z_DATA_ERROR;\n\n\t    this.bitb=b; this.bitk=k; \n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    this.write=q;\n\t    return this.inflate_flush(z,r);\n\t  }\n\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\tif(this.blens==null || this.blens.length<t){\n\t    this.blens=new Int32Array(t);\n\t}\n\telse{\n\t  for(var i=0; i<t; i++){\n              this.blens[i]=0;\n          }\n\t}\n\n\t{b>>>=(14);k-=(14);}\n\n\tthis.index = 0;\n\tmode = IB_BTREE;\n      case IB_BTREE:\n\twhile (this.index < 4 + (this.table >>> 10)){\n\t  while(k<(3)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = b&7;\n\n\t  {b>>>=(3);k-=(3);}\n\t}\n\n\twhile(this.index < 19){\n\t  this.blens[INFBLOCKS_BORDER[this.index++]] = 0;\n\t}\n\n\tthis.bb[0] = 7;\n\tt = this.inftree.inflate_trees_bits(this.blens, this.bb, this.tb, this.hufts, z);\n\tif (t != Z_OK){\n\t  r = t;\n\t  if (r == Z_DATA_ERROR){\n\t    this.blens=null;\n\t    this.mode = IB_BAD;\n\t  }\n\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  write=q;\n\t  return this.inflate_flush(z,r);\n\t}\n\n\tthis.index = 0;\n\tthis.mode = IB_DTREE;\n      case IB_DTREE:\n\twhile (true){\n\t  t = this.table;\n\t  if(!(this.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))){\n\t    break;\n\t  }\n\n\t  var h; //int[]\n\t  var i, j, c;\n\n\t  t = this.bb[0];\n\n\t  while(k<(t)){\n\t    if(n!=0){\n\t      r=Z_OK;\n\t    }\n\t    else{\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;\n\t      z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    };\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;\n\t    k+=8;\n\t  }\n\n//\t  if (this.tb[0]==-1){\n//            dlog(\"null...\");\n//\t  }\n\n\t  t=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+1];\n\t  c=this.hufts[(this.tb[0]+(b & inflate_mask[t]))*3+2];\n\n\t  if (c < 16){\n\t    b>>>=(t);k-=(t);\n\t    this.blens[this.index++] = c;\n\t  }\n\t  else { // c == 16..18\n\t    i = c == 18 ? 7 : c - 14;\n\t    j = c == 18 ? 11 : 3;\n\n\t    while(k<(t+i)){\n\t      if(n!=0){\n\t\tr=Z_OK;\n\t      }\n\t      else{\n\t\tthis.bitb=b; this.bitk=k; \n\t\tz.avail_in=n;\n\t\tz.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\tthis.write=q;\n\t\treturn this.inflate_flush(z,r);\n\t      };\n\t      n--;\n\t      b|=(z.next_in[p++]&0xff)<<k;\n\t      k+=8;\n\t    }\n\n\t    b>>>=(t);k-=(t);\n\n\t    j += (b & inflate_mask[i]);\n\n\t    b>>>=(i);k-=(i);\n\n\t    i = this.index;\n\t    t = this.table;\n\t    if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||\n\t\t(c == 16 && i < 1)){\n\t      this.blens=null;\n\t      this.mode = IB_BAD;\n\t      z.msg = \"invalid bit length repeat\";\n\t      r = Z_DATA_ERROR;\n\n\t      this.bitb=b; this.bitk=k; \n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      this.write=q;\n\t      return this.inflate_flush(z,r);\n\t    }\n\n\t    c = c == 16 ? this.blens[i-1] : 0;\n\t    do{\n\t      this.blens[i++] = c;\n\t    }\n\t    while (--j!=0);\n\t    this.index = i;\n\t  }\n\t}\n\n\tthis.tb[0]=-1;\n\t{\n\t    var bl=new Int32Array(1);\n\t    var bd=new Int32Array(1);\n\t    var tl=new Int32Array(1);\n\t    var td=new Int32Array(1);\n\t    bl[0] = 9;         // must be <= 9 for lookahead assumptions\n\t    bd[0] = 6;         // must be <= 9 for lookahead assumptions\n\n\t    t = this.table;\n\t    t = this.inftree.inflate_trees_dynamic(257 + (t & 0x1f), \n\t\t\t\t\t      1 + ((t >> 5) & 0x1f),\n\t\t\t\t\t      this.blens, bl, bd, tl, td, this.hufts, z);\n\n\t    if (t != Z_OK){\n\t        if (t == Z_DATA_ERROR){\n\t            this.blens=null;\n\t            this.mode = BAD;\n\t        }\n\t        r = t;\n\n\t        this.bitb=b; this.bitk=k; \n\t        z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t        this.write=q;\n\t        return this.inflate_flush(z,r);\n\t    }\n\t    this.codes.init(bl[0], bd[0], this.hufts, tl[0], this.hufts, td[0], z);\n\t}\n\tthis.mode = IB_CODES;\n      case IB_CODES:\n\tthis.bitb=b; this.bitk=k;\n\tz.avail_in=n; z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\n\tif ((r = this.codes.proc(this, z, r)) != Z_STREAM_END){\n\t  return this.inflate_flush(z, r);\n\t}\n\tr = Z_OK;\n\tthis.codes.free(z);\n\n\tp=z.next_in_index; n=z.avail_in;b=this.bitb;k=this.bitk;\n\tq=this.write;m = (q < this.read ? this.read-q-1 : this.end-q);\n\n\tif (this.last==0){\n\t  this.mode = IB_TYPE;\n\t  break;\n\t}\n\tthis.mode = IB_DRY;\n      case IB_DRY:\n\tthis.write=q; \n\tr = this.inflate_flush(z, r); \n\tq=this.write; m = (q < this.read ? this.read-q-1 : this.end-q);\n\tif (this.read != this.write){\n\t  this.bitb=b; this.bitk=k; \n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  this.write=q;\n\t  return this.inflate_flush(z, r);\n\t}\n\tmode = DONE;\n      case IB_DONE:\n\tr = Z_STREAM_END;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      case IB_BAD:\n\tr = Z_DATA_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\tthis.bitb=b; this.bitk=k; \n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\tthis.write=q;\n\treturn this.inflate_flush(z, r);\n      }\n    }\n  }\n\nInfBlocks.prototype.free = function(z){\n    this.reset(z, null);\n    this.window=null;\n    this.hufts=null;\n}\n\nInfBlocks.prototype.set_dictionary = function(d, start, n){\n    arrayCopy(d, start, window, 0, n);\n    this.read = this.write = n;\n}\n\n  // Returns true if inflate is currently at the end of a block generated\n  // by Z_SYNC_FLUSH or Z_FULL_FLUSH. \nInfBlocks.prototype.sync_point = function(){\n    return this.mode == IB_LENS;\n}\n\n  // copy as much as possible from the sliding window to the output area\nInfBlocks.prototype.inflate_flush = function(z, r){\n    var n;\n    var p;\n    var q;\n\n    // local copies of source and destination pointers\n    p = z.next_out_index;\n    q = this.read;\n\n    // compute number of bytes to copy as far as end of window\n    n = ((q <= this.write ? this.write : this.end) - q);\n    if (n > z.avail_out) n = z.avail_out;\n    if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n    // update counters\n    z.avail_out -= n;\n    z.total_out += n;\n\n    // update check information\n    if(this.checkfn != null)\n      z.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n    // copy as far as end of window\n    arrayCopy(this.window, q, z.next_out, p, n);\n    p += n;\n    q += n;\n\n    // see if more to copy at beginning of window\n    if (q == this.end){\n      // wrap pointers\n      q = 0;\n      if (this.write == this.end)\n        this.write = 0;\n\n      // compute bytes to copy\n      n = this.write - q;\n      if (n > z.avail_out) n = z.avail_out;\n      if (n!=0 && r == Z_BUF_ERROR) r = Z_OK;\n\n      // update counters\n      z.avail_out -= n;\n      z.total_out += n;\n\n      // update check information\n      if(this.checkfn != null)\n\tz.adler=this.check=z._adler.adler32(this.check, this.window, q, n);\n\n      // copy\n      arrayCopy(this.window, q, z.next_out, p, n);\n      p += n;\n      q += n;\n    }\n\n    // update pointers\n    z.next_out_index = p;\n    this.read = q;\n\n    // done\n    return r;\n  }\n\n//\n// InfCodes.java\n//\n\nvar IC_START=0;  // x: set up for LEN\nvar IC_LEN=1;    // i: get length/literal/eob next\nvar IC_LENEXT=2; // i: getting length extra (have base)\nvar IC_DIST=3;   // i: get distance next\nvar IC_DISTEXT=4;// i: getting distance extra\nvar IC_COPY=5;   // o: copying bytes in window, waiting for space\nvar IC_LIT=6;    // o: got literal, waiting for output space\nvar IC_WASH=7;   // o: got eob, possibly still output waiting\nvar IC_END=8;    // x: got eob and all data flushed\nvar IC_BADCODE=9;// x: got error\n\nfunction InfCodes() {\n}\n\nInfCodes.prototype.init = function(bl, bd, tl, tl_index, td, td_index, z) {\n    this.mode=IC_START;\n    this.lbits=bl;\n    this.dbits=bd;\n    this.ltree=tl;\n    this.ltree_index=tl_index;\n    this.dtree = td;\n    this.dtree_index=td_index;\n    this.tree=null;\n}\n\nInfCodes.prototype.proc = function(s, z, r){ \n    var j;              // temporary storage\n    var t;              // temporary pointer (int[])\n    var tindex;         // temporary pointer\n    var e;              // extra bits or operation\n    var b=0;            // bit buffer\n    var k=0;            // bits in bit buffer\n    var p=0;            // input data pointer\n    var n;              // bytes available there\n    var q;              // output window write pointer\n    var m;              // bytes to end of window or read pointer\n    var f;              // pointer to copy strings from\n\n    // copy input/output information to locals (UPDATE macro restores)\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // process input and output based on current state\n    while (true){\n      switch (this.mode){\n\t// waiting for \"i:\"=input, \"o:\"=output, \"x:\"=nothing\n      case IC_START:         // x: set up for LEN\n\tif (m >= 258 && n >= 10){\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  r = this.inflate_fast(this.lbits, this.dbits, \n\t\t\t   this.ltree, this.ltree_index, \n\t\t\t   this.dtree, this.dtree_index,\n\t\t\t   s, z);\n\n\t  p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n\t  q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t  if (r != Z_OK){\n\t    this.mode = r == Z_STREAM_END ? IC_WASH : IC_BADCODE;\n\t    break;\n\t  }\n\t}\n\tthis.need = this.lbits;\n\tthis.tree = this.ltree;\n\tthis.tree_index=this.ltree_index;\n\n\tthis.mode = IC_LEN;\n      case IC_LEN:           // i: get length/literal/eob next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--;\n\t  b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b&inflate_mask[j]))*3;\n\n\tb>>>=(this.tree[tindex+1]);\n\tk-=(this.tree[tindex+1]);\n\n\te=this.tree[tindex];\n\n\tif(e == 0){               // literal\n\t  this.lit = this.tree[tindex+2];\n\t  this.mode = IC_LIT;\n\t  break;\n\t}\n\tif((e & 16)!=0 ){          // length\n\t  this.get = e & 15;\n\t  this.len = this.tree[tindex+2];\n\t  this.mode = IC_LENEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tif ((e & 32)!=0){               // end of block\n\t  this.mode = IC_WASH;\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid literal/length code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_LENEXT:        // i: getting length extra (have base)\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.len += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.need = this.dbits;\n\tthis.tree = this.dtree;\n\tthis.tree_index = this.dtree_index;\n\tthis.mode = IC_DIST;\n      case IC_DIST:          // i: get distance next\n\tj = this.need;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\ttindex=(this.tree_index+(b & inflate_mask[j]))*3;\n\n\tb>>=this.tree[tindex+1];\n\tk-=this.tree[tindex+1];\n\n\te = (this.tree[tindex]);\n\tif((e & 16)!=0){               // distance\n\t  this.get = e & 15;\n\t  this.dist = this.tree[tindex+2];\n\t  this.mode = IC_DISTEXT;\n\t  break;\n\t}\n\tif ((e & 64) == 0){        // next table\n\t  this.need = e;\n\t  this.tree_index = tindex/3 + this.tree[tindex+2];\n\t  break;\n\t}\n\tthis.mode = IC_BADCODE;        // invalid code\n\tz.msg = \"invalid distance code\";\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_DISTEXT:       // i: getting distance extra\n\tj = this.get;\n\n\twhile(k<(j)){\n\t  if(n!=0)r=Z_OK;\n\t  else{\n\n\t    s.bitb=b;s.bitk=k;\n\t    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t    s.write=q;\n\t    return s.inflate_flush(z,r);\n\t  }\n\t  n--; b|=(z.next_in[p++]&0xff)<<k;\n\t  k+=8;\n\t}\n\n\tthis.dist += (b & inflate_mask[j]);\n\n\tb>>=j;\n\tk-=j;\n\n\tthis.mode = IC_COPY;\n      case IC_COPY:          // o: copying bytes in window, waiting for space\n        f = q - this.dist;\n        while(f < 0){     // modulo window size-\"while\" instead\n          f += s.end;     // of \"if\" handles invalid distances\n\t}\n\twhile (this.len!=0){\n\n\t  if(m==0){\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.write=q; r=s.inflate_flush(z,r);\n\t      q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t      if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\n\t      if(m==0){\n\t\ts.bitb=b;s.bitk=k;\n\t\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t\ts.write=q;\n\t\treturn s.inflate_flush(z,r);\n\t      }  \n\t    }\n\t  }\n\n\t  s.window[q++]=s.window[f++]; m--;\n\n\t  if (f == s.end)\n            f = 0;\n\t  this.len--;\n\t}\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_LIT:           // o: got literal, waiting for output space\n\tif(m==0){\n\t  if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t  if(m==0){\n\t    s.write=q; r=s.inflate_flush(z,r);\n\t    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\t    if(q==s.end&&s.read!=0){q=0;m=q<s.read?s.read-q-1:s.end-q;}\n\t    if(m==0){\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\t      return s.inflate_flush(z,r);\n\t    }\n\t  }\n\t}\n\tr=Z_OK;\n\n\ts.window[q++]=this.lit; m--;\n\n\tthis.mode = IC_START;\n\tbreak;\n      case IC_WASH:           // o: got eob, possibly more output\n\tif (k > 7){        // return unused byte, if any\n\t  k -= 8;\n\t  n++;\n\t  p--;             // can always return one\n\t}\n\n\ts.write=q; r=s.inflate_flush(z,r);\n\tq=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n\tif (s.read != s.write){\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\t  return s.inflate_flush(z,r);\n\t}\n\tthis.mode = IC_END;\n      case IC_END:\n\tr = Z_STREAM_END;\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      case IC_BADCODE:       // x: got error\n\n\tr = Z_DATA_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n\n      default:\n\tr = Z_STREAM_ERROR;\n\n\ts.bitb=b;s.bitk=k;\n\tz.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\ts.write=q;\n\treturn s.inflate_flush(z,r);\n      }\n    }\n  }\n\nInfCodes.prototype.free = function(z){\n    //  ZFREE(z, c);\n}\n\n  // Called with number of bytes left to write in window at least 258\n  // (the maximum string length) and number of input bytes available\n  // at least ten.  The ten bytes are six bytes for the longest length/\n  // distance pair plus four bytes for overloading the bit buffer.\n\nInfCodes.prototype.inflate_fast = function(bl, bd, tl, tl_index, td, td_index, s, z) {\n    var t;                // temporary pointer\n    var   tp;             // temporary pointer (int[])\n    var tp_index;         // temporary pointer\n    var e;                // extra bits or operation\n    var b;                // bit buffer\n    var k;                // bits in bit buffer\n    var p;                // input data pointer\n    var n;                // bytes available there\n    var q;                // output window write pointer\n    var m;                // bytes to end of window or read pointer\n    var ml;               // mask for literal/length tree\n    var md;               // mask for distance tree\n    var c;                // bytes to copy\n    var d;                // distance back to copy from\n    var r;                // copy source pointer\n\n    var tp_index_t_3;     // (tp_index+t)*3\n\n    // load input, output, bit values\n    p=z.next_in_index;n=z.avail_in;b=s.bitb;k=s.bitk;\n    q=s.write;m=q<s.read?s.read-q-1:s.end-q;\n\n    // initialize masks\n    ml = inflate_mask[bl];\n    md = inflate_mask[bd];\n\n    // do until not enough input or output space for fast loop\n    do {                          // assume called with m >= 258 && n >= 10\n      // get literal/length code\n      while(k<(20)){              // max bits for literal/length code\n\tn--;\n\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n      }\n\n      t= b&ml;\n      tp=tl; \n      tp_index=tl_index;\n      tp_index_t_3=(tp_index+t)*3;\n      if ((e = tp[tp_index_t_3]) == 0){\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\ts.window[q++] = tp[tp_index_t_3+2];\n\tm--;\n\tcontinue;\n      }\n      do {\n\n\tb>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\tif((e&16)!=0){\n\t  e &= 15;\n\t  c = tp[tp_index_t_3+2] + (b & inflate_mask[e]);\n\n\t  b>>=e; k-=e;\n\n\t  // decode distance base of block to copy\n\t  while(k<(15)){           // max bits for distance code\n\t    n--;\n\t    b|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t  }\n\n\t  t= b&md;\n\t  tp=td;\n\t  tp_index=td_index;\n          tp_index_t_3=(tp_index+t)*3;\n\t  e = tp[tp_index_t_3];\n\n\t  do {\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    if((e&16)!=0){\n\t      // get extra bits to add to distance base\n\t      e &= 15;\n\t      while(k<(e)){         // get extra bits (up to 13)\n\t\tn--;\n\t\tb|=(z.next_in[p++]&0xff)<<k;k+=8;\n\t      }\n\n\t      d = tp[tp_index_t_3+2] + (b&inflate_mask[e]);\n\n\t      b>>=(e); k-=(e);\n\n\t      // do the copy\n\t      m -= c;\n\t      if (q >= d){                // offset before dest\n\t\t//  just copy\n\t\tr=q-d;\n\t\tif(q-r>0 && 2>(q-r)){           \n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t\telse{\n\t\t  s.window[q++]=s.window[r++]; // minimum count is three,\n\t\t  s.window[q++]=s.window[r++]; // so unroll loop a little\n\t\t  c-=2;\n\t\t}\n\t      }\n\t      else{                  // else offset after destination\n                r=q-d;\n                do{\n                  r+=s.end;          // force pointer in window\n                }while(r<0);         // covers invalid distances\n\t\te=s.end-r;\n\t\tif(c>e){             // if source crosses,\n\t\t  c-=e;              // wrapped copy\n\t\t  if(q-r>0 && e>(q-r)){           \n\t\t    do{s.window[q++] = s.window[r++];}\n\t\t    while(--e!=0);\n\t\t  }\n\t\t  else{\n\t\t    arrayCopy(s.window, r, s.window, q, e);\n\t\t    q+=e; r+=e; e=0;\n\t\t  }\n\t\t  r = 0;                  // copy rest from start of window\n\t\t}\n\n\t      }\n\n\t      // copy all or what's left\n              do{s.window[q++] = s.window[r++];}\n\t\twhile(--c!=0);\n\t      break;\n\t    }\n\t    else if((e&64)==0){\n\t      t+=tp[tp_index_t_3+2];\n\t      t+=(b&inflate_mask[e]);\n\t      tp_index_t_3=(tp_index+t)*3;\n\t      e=tp[tp_index_t_3];\n\t    }\n\t    else{\n\t      z.msg = \"invalid distance code\";\n\n\t      c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t      s.bitb=b;s.bitk=k;\n\t      z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t      s.write=q;\n\n\t      return Z_DATA_ERROR;\n\t    }\n\t  }\n\t  while(true);\n\t  break;\n\t}\n\n\tif((e&64)==0){\n\t  t+=tp[tp_index_t_3+2];\n\t  t+=(b&inflate_mask[e]);\n\t  tp_index_t_3=(tp_index+t)*3;\n\t  if((e=tp[tp_index_t_3])==0){\n\n\t    b>>=(tp[tp_index_t_3+1]); k-=(tp[tp_index_t_3+1]);\n\n\t    s.window[q++]=tp[tp_index_t_3+2];\n\t    m--;\n\t    break;\n\t  }\n\t}\n\telse if((e&32)!=0){\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n \n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_STREAM_END;\n\t}\n\telse{\n\t  z.msg=\"invalid literal/length code\";\n\n\t  c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n\t  s.bitb=b;s.bitk=k;\n\t  z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n\t  s.write=q;\n\n\t  return Z_DATA_ERROR;\n\t}\n      } \n      while(true);\n    } \n    while(m>=258 && n>= 10);\n\n    // not enough input or output--restore pointers and return\n    c=z.avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;\n\n    s.bitb=b;s.bitk=k;\n    z.avail_in=n;z.total_in+=p-z.next_in_index;z.next_in_index=p;\n    s.write=q;\n\n    return Z_OK;\n}\n\n//\n// InfTree.java\n//\n\nfunction InfTree() {\n}\n\nInfTree.prototype.huft_build = function(b, bindex, n, s, d, e, t, m, hp, hn, v) {\n\n    // Given a list of code lengths and a maximum table size, make a set of\n    // tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR\n    // if the given code set is incomplete (the tables are still built in this\n    // case), Z_DATA_ERROR if the input is invalid (an over-subscribed set of\n    // lengths), or Z_MEM_ERROR if not enough memory.\n\n    var a;                       // counter for codes of length k\n    var f;                       // i repeats in table every f entries\n    var g;                       // maximum code length\n    var h;                       // table level\n    var i;                       // counter, current code\n    var j;                       // counter\n    var k;                       // number of bits in current code\n    var l;                       // bits per table (returned in m)\n    var mask;                    // (1 << w) - 1, to avoid cc -O bug on HP\n    var p;                       // pointer into c[], b[], or v[]\n    var q;                       // points to current table\n    var w;                       // bits before this table == (l * h)\n    var xp;                      // pointer into x\n    var y;                       // number of dummy codes added\n    var z;                       // number of entries in current table\n\n    // Generate counts for each bit length\n\n    p = 0; i = n;\n    do {\n      this.c[b[bindex+p]]++; p++; i--;   // assume all entries <= BMAX\n    }while(i!=0);\n\n    if(this.c[0] == n){                // null input--all zero length codes\n      t[0] = -1;\n      m[0] = 0;\n      return Z_OK;\n    }\n\n    // Find minimum and maximum length, bound *m by those\n    l = m[0];\n    for (j = 1; j <= BMAX; j++)\n      if(this.c[j]!=0) break;\n    k = j;                        // minimum code length\n    if(l < j){\n      l = j;\n    }\n    for (i = BMAX; i!=0; i--){\n      if(this.c[i]!=0) break;\n    }\n    g = i;                        // maximum code length\n    if(l > i){\n      l = i;\n    }\n    m[0] = l;\n\n    // Adjust last length count to fill out codes, if needed\n    for (y = 1 << j; j < i; j++, y <<= 1){\n      if ((y -= this.c[j]) < 0){\n        return Z_DATA_ERROR;\n      }\n    }\n    if ((y -= this.c[i]) < 0){\n      return Z_DATA_ERROR;\n    }\n    this.c[i] += y;\n\n    // Generate starting offsets into the value table for each length\n    this.x[1] = j = 0;\n    p = 1;  xp = 2;\n    while (--i!=0) {                 // note that i == g from above\n      this.x[xp] = (j += this.c[p]);\n      xp++;\n      p++;\n    }\n\n    // Make a table of values in order of bit lengths\n    i = 0; p = 0;\n    do {\n      if ((j = b[bindex+p]) != 0){\n        this.v[this.x[j]++] = i;\n      }\n      p++;\n    }\n    while (++i < n);\n    n = this.x[g];                     // set n to length of v\n\n    // Generate the Huffman codes and for each, make the table entries\n    this.x[0] = i = 0;                 // first Huffman code is zero\n    p = 0;                        // grab values in bit order\n    h = -1;                       // no tables yet--level -1\n    w = -l;                       // bits decoded == (l * h)\n    this.u[0] = 0;                     // just to keep compilers happy\n    q = 0;                        // ditto\n    z = 0;                        // ditto\n\n    // go through the bit lengths (k already is bits in shortest code)\n    for (; k <= g; k++){\n      a = this.c[k];\n      while (a--!=0){\n\t// here i is the Huffman code of length k bits for value *p\n\t// make tables up to required level\n        while (k > w + l){\n          h++;\n          w += l;                 // previous table always l bits\n\t  // compute minimum size table less than or equal to l bits\n          z = g - w;\n          z = (z > l) ? l : z;        // table size upper limit\n          if((f=1<<(j=k-w))>a+1){     // try a k-w bit table\n                                      // too few codes for k-w bit table\n            f -= a + 1;               // deduct codes from patterns left\n            xp = k;\n            if(j < z){\n              while (++j < z){        // try smaller tables up to z bits\n                if((f <<= 1) <= this.c[++xp])\n                  break;              // enough codes to use up j bits\n                f -= this.c[xp];           // else deduct codes from patterns\n              }\n\t    }\n          }\n          z = 1 << j;                 // table entries for j-bit table\n\n\t  // allocate new table\n          if (this.hn[0] + z > MANY){       // (note: doesn't matter for fixed)\n            return Z_DATA_ERROR;       // overflow of MANY\n          }\n          this.u[h] = q = /*hp+*/ this.hn[0];   // DEBUG\n          this.hn[0] += z;\n \n\t  // connect to last table, if there is one\n\t  if(h!=0){\n            this.x[h]=i;           // save pattern for backing up\n            this.r[0]=j;     // bits in this table\n            this.r[1]=l;     // bits to dump before this table\n            j=i>>>(w - l);\n            this.r[2] = (q - this.u[h-1] - j);               // offset to this table\n            arrayCopy(this.r, 0, hp, (this.u[h-1]+j)*3, 3); // connect to last table\n          }\n          else{\n            t[0] = q;               // first table is returned result\n\t  }\n        }\n\n\t// set up table entry in r\n        this.r[1] = (k - w);\n        if (p >= n){\n          this.r[0] = 128 + 64;      // out of values--invalid code\n\t}\n        else if (v[p] < s){\n          this.r[0] = (this.v[p] < 256 ? 0 : 32 + 64);  // 256 is end-of-block\n          this.r[2] = this.v[p++];          // simple code is just the value\n        }\n        else{\n          this.r[0]=(e[this.v[p]-s]+16+64); // non-simple--look up in lists\n          this.r[2]=d[this.v[p++] - s];\n        }\n\n        // fill code-like entries with r\n        f=1<<(k-w);\n        for (j=i>>>w;j<z;j+=f){\n          arrayCopy(this.r, 0, hp, (q+j)*3, 3);\n\t}\n\n\t// backwards increment the k-bit code i\n        for (j = 1 << (k - 1); (i & j)!=0; j >>>= 1){\n          i ^= j;\n\t}\n        i ^= j;\n\n\t// backup over finished tables\n        mask = (1 << w) - 1;      // needed on HP, cc -O bug\n        while ((i & mask) != this.x[h]){\n          h--;                    // don't need to update q\n          w -= l;\n          mask = (1 << w) - 1;\n        }\n      }\n    }\n    // Return Z_BUF_ERROR if we were given an incomplete table\n    return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n}\n\nInfTree.prototype.inflate_trees_bits = function(c, bb, tb, hp, z) {\n    var result;\n    this.initWorkArea(19);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, 19, 19, null, null, tb, bb, hp, this.hn, this.v);\n\n    if(result == Z_DATA_ERROR){\n      z.msg = \"oversubscribed dynamic bit lengths tree\";\n    }\n    else if(result == Z_BUF_ERROR || bb[0] == 0){\n      z.msg = \"incomplete dynamic bit lengths tree\";\n      result = Z_DATA_ERROR;\n    }\n    return result;\n}\n\nInfTree.prototype.inflate_trees_dynamic = function(nl, nd, c, bl, bd, tl, td, hp, z) {\n    var result;\n\n    // build literal/length tree\n    this.initWorkArea(288);\n    this.hn[0]=0;\n    result = this.huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, this.hn, this.v);\n    if (result != Z_OK || bl[0] == 0){\n      if(result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed literal/length tree\";\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"incomplete literal/length tree\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    // build distance tree\n    this.initWorkArea(288);\n    result = this.huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, this.hn, this.v);\n\n    if (result != Z_OK || (bd[0] == 0 && nl > 257)){\n      if (result == Z_DATA_ERROR){\n        z.msg = \"oversubscribed distance tree\";\n      }\n      else if (result == Z_BUF_ERROR) {\n        z.msg = \"incomplete distance tree\";\n        result = Z_DATA_ERROR;\n      }\n      else if (result != Z_MEM_ERROR){\n        z.msg = \"empty distance tree with lengths\";\n        result = Z_DATA_ERROR;\n      }\n      return result;\n    }\n\n    return Z_OK;\n}\n/*\n  static int inflate_trees_fixed(int[] bl,  //literal desired/actual bit depth\n                                 int[] bd,  //distance desired/actual bit depth\n                                 int[][] tl,//literal/length tree result\n                                 int[][] td,//distance tree result \n                                 ZStream z  //for memory allocation\n\t\t\t\t ){\n\n*/\n\nfunction inflate_trees_fixed(bl, bd, tl, td, z) {\n    bl[0]=fixed_bl;\n    bd[0]=fixed_bd;\n    tl[0]=fixed_tl;\n    td[0]=fixed_td;\n    return Z_OK;\n}\n\nInfTree.prototype.initWorkArea = function(vsize){\n    if(this.hn==null){\n        this.hn=new Int32Array(1);\n        this.v=new Int32Array(vsize);\n        this.c=new Int32Array(BMAX+1);\n        this.r=new Int32Array(3);\n        this.u=new Int32Array(BMAX);\n        this.x=new Int32Array(BMAX+1);\n    }\n    if(this.v.length<vsize){ \n        this.v=new Int32Array(vsize); \n    }\n    for(var i=0; i<vsize; i++){this.v[i]=0;}\n    for(var i=0; i<BMAX+1; i++){this.c[i]=0;}\n    for(var i=0; i<3; i++){this.r[i]=0;}\n//  for(int i=0; i<BMAX; i++){u[i]=0;}\n    arrayCopy(this.c, 0, this.u, 0, BMAX);\n//  for(int i=0; i<BMAX+1; i++){x[i]=0;}\n    arrayCopy(this.c, 0, this.x, 0, BMAX+1);\n}\n\nvar testArray = new Uint8Array(1);\nvar hasSubarray = (typeof testArray.subarray === 'function');\nvar hasSlice = false; /* (typeof testArray.slice === 'function'); */ // Chrome slice performance is so dire that we're currently not using it...\n\nfunction arrayCopy(src, srcOffset, dest, destOffset, count) {\n    if (count == 0) {\n        return;\n    } \n    if (!src) {\n        throw \"Undef src\";\n    } else if (!dest) {\n        throw \"Undef dest\";\n    }\n\n    if (srcOffset == 0 && count == src.length) {\n        arrayCopy_fast(src, dest, destOffset);\n    } else if (hasSubarray) {\n        arrayCopy_fast(src.subarray(srcOffset, srcOffset + count), dest, destOffset); \n    } else if (src.BYTES_PER_ELEMENT == 1 && count > 100) {\n        arrayCopy_fast(new Uint8Array(src.buffer, src.byteOffset + srcOffset, count), dest, destOffset);\n    } else { \n        arrayCopy_slow(src, srcOffset, dest, destOffset, count);\n    }\n\n}\n\nfunction arrayCopy_slow(src, srcOffset, dest, destOffset, count) {\n\n    // dlog('_slow call: srcOffset=' + srcOffset + '; destOffset=' + destOffset + '; count=' + count);\n\n     for (var i = 0; i < count; ++i) {\n        dest[destOffset + i] = src[srcOffset + i];\n    }\n}\n\nfunction arrayCopy_fast(src, dest, destOffset) {\n    dest.set(src, destOffset);\n}\n\n\n  // largest prime smaller than 65536\nvar ADLER_BASE=65521; \n  // NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1\nvar ADLER_NMAX=5552;\n\nfunction adler32(adler, /* byte[] */ buf,  index, len){\n    if(buf == null){ return 1; }\n\n    var s1=adler&0xffff;\n    var s2=(adler>>16)&0xffff;\n    var k;\n\n    while(len > 0) {\n      k=len<ADLER_NMAX?len:ADLER_NMAX;\n      len-=k;\n      while(k>=16){\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        s1+=buf[index++]&0xff; s2+=s1;\n        k-=16;\n      }\n      if(k!=0){\n        do{\n          s1+=buf[index++]&0xff; s2+=s1;\n        }\n        while(--k!=0);\n      }\n      s1%=ADLER_BASE;\n      s2%=ADLER_BASE;\n    }\n    return (s2<<16)|s1;\n}\n\n\n\nfunction jszlib_inflate_buffer(buffer, start, length, afterUncOffset) {\n    if (!start) {\n        buffer = new Uint8Array(buffer);\n    } else if (!length) {\n        buffer = new Uint8Array(buffer, start, buffer.byteLength - start);\n    } else {\n        buffer = new Uint8Array(buffer, start, length);\n    }\n\n    var z = new ZStream();\n    z.inflateInit(DEF_WBITS, true);\n    z.next_in = buffer;\n    z.next_in_index = 0;\n    z.avail_in = buffer.length;\n\n    var oBlockList = [];\n    var totalSize = 0;\n    while (true) {\n        var obuf = new Uint8Array(32000);\n        z.next_out = obuf;\n        z.next_out_index = 0;\n        z.avail_out = obuf.length;\n        var status = z.inflate(Z_NO_FLUSH);\n        if (status != Z_OK && status != Z_STREAM_END && status != Z_BUF_ERROR) {\n            throw z.msg;\n        }\n        if (z.avail_out != 0) {\n            var newob = new Uint8Array(obuf.length - z.avail_out);\n            arrayCopy(obuf, 0, newob, 0, (obuf.length - z.avail_out));\n            obuf = newob;\n        }\n        oBlockList.push(obuf);\n        totalSize += obuf.length;\n        if (status == Z_STREAM_END || status == Z_BUF_ERROR) {\n            break;\n        }\n    }\n\n    if (afterUncOffset) {\n        afterUncOffset[0] = (start || 0) + z.next_in_index;\n    }\n\n    if (oBlockList.length == 1) {\n        return oBlockList[0].buffer;\n    } else {\n        var out = new Uint8Array(totalSize);\n        var cursor = 0;\n        for (var i = 0; i < oBlockList.length; ++i) {\n            var b = oBlockList[i];\n            arrayCopy(b, 0, out, cursor, b.length);\n            cursor += b.length;\n        }\n        return out.buffer;\n    }\n}\n\nif (typeof(module) !== 'undefined') {\n  module.exports = {\n    inflateBuffer: jszlib_inflate_buffer,\n    arrayCopy: arrayCopy\n  };\n}\n"]}